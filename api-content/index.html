{"posts":[{"title":"js之引用数据类型","content":"ja","link":"https://18279493170.github.io/kc79gbHFn/"},{"title":"websocket","content":"websocket","link":"https://18279493170.github.io/websocket/"},{"title":"css速览","content":"定义CSS：CascadingStyleSheet（层叠样式表）//写法选择器{属性名:属性值;}样式表三种样式表使用//内联样式&lt;divstyle=&quot;width:100px;height:100px;&quot;&gt;&lt;/div&gt;//内部样式表&lt;styletype=&quot;text/css&quot;&gt;div{width:100px;height:100px;}&lt;/style&gt;//外部样式表&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;&quot;&gt;三种样式表的权重和优先级内联样式&gt;内部样式表&gt;外部样式表选择器6大基础选择器//1、id选择器：唯一对应&lt;divid=&quot;box&quot;&gt;&lt;/div&gt;&lt;styletype=&quot;text/css&quot;&gt;#box{color:red;}&lt;/style&gt;//2、类class选择器：统一类&lt;divclass=&quot;box&quot;&gt;&lt;/div&gt;&lt;styletype=&quot;text/css&quot;&gt;.box{color:red;}&lt;/style&gt;//3、标签选择器：初始化标签使用&lt;div&gt;&lt;/div&gt;&lt;styletype=&quot;text/css&quot;&gt;div{color:red;}&lt;/style&gt;//4、*通配符标签&lt;styletype=&quot;text/css&quot;&gt;*{margin:0;}&lt;/style&gt;//5、属性选择器：表单中input常用&lt;divid=&quot;box1&quot;&gt;&lt;/div&gt;&lt;ahref=&quot;http://www.baidu.com&quot;&gt;&lt;/a&gt;&lt;styletype=&quot;text/css&quot;&gt;[id=&quot;box&quot;]{color:red;}[href]{text-decoration:none;}&lt;/style&gt;//6、最高优先权&lt;styletype=&quot;text/css&quot;&gt;div{background:red!important;}&lt;/style&gt;6大基础选择器优先级!important&gt;id&gt;class|属性&gt;标签&gt;*复合选择器//1、派生选择器（父子选择器），从右到左匹配。包含两种：包含选择器和子选择器&lt;header&gt;&lt;p&gt;&lt;em&gt;你好&lt;/em&gt;&lt;/p&gt;&lt;/header&gt;&lt;styletype=&quot;text/css&quot;&gt;/*包含选择器*/headerpem{color:red;}/*子选择器：必须层层父子级*/header&gt;p&gt;em{color:red;}/*直接父子选择器*/p&gt;em{color:red;}&lt;/style&gt;//2、相邻兄弟选择器：1、同父级；2、相邻；3、在其之后&lt;p&gt;这里是第一个P标签&lt;/p&gt;&lt;h2class='h2'&gt;标题H2&lt;/h2&gt;&lt;p&gt;这里是第一个P标签（变色）&lt;/p&gt;&lt;p&gt;这里是第二个P标签&lt;/p&gt;&lt;styletype=&quot;text/css&quot;&gt;.h2+p{color:red;}&lt;/style&gt;//3、兄弟选择器~（匹配选择器）&lt;p&gt;这里是第一个P标签&lt;/p&gt;&lt;h2class='h2'&gt;标题H2&lt;/h2&gt;&lt;p&gt;这里是第一个P标签（变色）&lt;/p&gt;&lt;p&gt;这里是第二个P标签（变色）&lt;/p&gt;&lt;styletype=&quot;text/css&quot;&gt;.h2~p{color:red;}&lt;/style&gt;//4、并列选择器&lt;h1class=&quot;title&quot;&gt;你好！&lt;/h1&gt;&lt;styletype=&quot;text/css&quot;&gt;h1.class{color:pink;}&lt;/style&gt;//5、分组选择器&lt;inputtype=&quot;text&quot;/&gt;&lt;br/&gt;&lt;textareacols=&quot;3&quot;rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;styletype=&quot;text/css&quot;&gt;input,textarea{outline:none;}&lt;/style&gt;CSS权重(256进制)计算规则分类权重*：0标签、伪元素：1class、属性、伪类：10id：100内联样式：1000!important：正无穷//基础选择器优先级正无穷&gt;100&gt;10&gt;1&gt;0!important&gt;id&gt;class|属性&gt;标签&gt;*//权重计算&lt;divid=&quot;div_id&quot;class=&quot;div_class&quot;&gt;&lt;h1id=&quot;h1_id&quot;class=&quot;h1_class&quot;&gt;你好！&lt;/h1&gt;&lt;/div&gt;&lt;styletype=&quot;text/css&quot;&gt;#div_idh1{color:pink;//100+1}.div_class.h1_class{color:purple;//10+10}.div_class#h1_id.h1_class{//10+100+10color:red;}&lt;/style&gt;伪类和伪元素伪类用来选择那些不能够被普通选择器选择的文档之外的元素，比如:hover。:active选择正在被激活的元素（匹配指定状态）:hover选择被鼠标悬浮着的元素（匹配指定状态）:link选择未被访问的元素（匹配指定状态）:visited选择已被访问的元素（匹配指定状态）:first-child选择满足是其父元素的第一个子元素的元素:lang(value)选择带有指定lang属性的元素:focus选择拥有键盘输入焦点的元素:enable选择每个已启动的元素:disable选择每个已禁止的元素:checked选择每个被选中的元素:target选择当前的锚点元素:first-of-type选择满足是其父元素的第一个某类型子元素的元素:last-of-type选择满足是其父元素的最后一个某类型子元素的元素:only-of-type选择满足是其父元素的唯一一个某类型子元素的元素:nth-of-type(n)选择满足是其父元素的第n个某类型子元素的元素:nth-last-of-type(n)选择满足是其父元素的倒数第n个某类型的元素:only-child选择满足是其父元素的唯一一个子元素的元素:last-child选择满足是其父元素的最后一个元素的元素:nth-child(n)选择满足是其父元素的第n个子元素的元素:nth-last-child(n)选择满足是其父元素的倒数第n个子元素的元素:empty选择满足没有子元素的元素:in-range选择满足值在指定范围内的元素:out-of-range选择值不在指定范围内的元素:invalid选择满足值为无效值的元素:valid选择满足值为有效值的元素:not(selector)选择不满足selector的元素:optional选择为可选项的表单元素，即没有“required”属性:read-only选择有&quot;readonly&quot;的表单元素:read-write选择没有&quot;readonly&quot;的表单元素:root选择根元素伪元素需要创建通常不存在于文档中的元素，比如::before。::afterp::after在每个&lt;p&gt;元素之后插入内容::beforep::before在每个&lt;p&gt;元素之前插入内容::first-letterp::first-letter匹配每个&lt;p&gt;元素中内容的首字母::first-linep::first-line匹配每个&lt;p&gt;元素中内容的首行::selectionp::selection匹配用户选择的元素部分::placeholderinput::placeholder匹配每个表单输入框（例如&lt;input&gt;）的placeholder属性CSS2中伪类和伪元素都是要单冒号（:）CSS3中伪类使用单冒号（:），伪元素使用双冒号（::）","link":"https://18279493170.github.io/css-su-lan/"},{"title":"python爬虫","content":"1、通用爬虫与聚焦爬虫通用网络爬虫是捜索引擎抓取系统（Baidu、Google、Yahoo等）的重要组成部分。主要目的是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。聚焦爬虫聚焦爬虫，是&quot;面向特定主题需求&quot;的一种网络爬虫程序，它与通用搜索引擎爬虫的区别在于：聚焦爬虫在实施网页抓取时会对内容进行处理筛选，尽量保证只抓取与需求相关的网页信息。2、浏览器发送HTTP请求的过程：当用户在浏览器的地址栏中输入一个URL地址并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为Get和Post两种方法。当我们在浏览器输入URLhttp://www.baidu.com的时候，浏览器发送一个Request请求去获取http://www.baidu.com的html文件，服务器把Response文件对象发送回给浏览器。浏览器分析Response中的HTML，发现其中引用了很多其他文件，比如Images文件，CSS文件，JS文件。浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件等。当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了3、URL基本格式基本格式：scheme://host[:port]/path/…/[?query-string][#anchor]#锚点scheme：协议(例如：http,https,ftp)host：服务器的IP地址或者域名port：服务器的端口（如果是走协议默认端口，缺省端口80）path：访问资源的路径query-string：参数，发送给http服务器的数据anchor：锚（跳转到网页的指定锚点位置）4、URL只是标识资源的位置，而HTTP是用来提交和获取资源。客户端发送一个HTTP请求到服务器的请求消息，包括以下格式：4、1请求行、请求头部、空行、请求数据图标见同级文件夹例子：GEThttps://www.baidu.com/HTTP/1.1Host:www.baidu.comConnection:keep-aliveUpgrade-Insecure-Requests:1User-Agent:Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/54.0.2840.99Safari/537.36Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Referer:http://www.baidu.com/Accept-Encoding:gzip,deflate,sdch,brAccept-Language:zh-CN,zh;q=0.8,en;q=0.6Cookie:BAIDUID=04E4001F34EA74AD4601512DD3C41A7B:FG=1;BIDUPSID=04E4001F34EA74AD4601512DD3C41A7B;PSTM=1470329258;MCITY=-343%3A340%3A;H_PS_PSSID=1447_18240_21105_21386_21454_21409_21554;BD_UPN=12314753;sug=3;sugstore=0;ORIGIN=0;bdime=0;H_PS_645EC=7e2ad3QHl181NSPbFbd7PRUCE1LlufzxrcFmwYin0E6b%2BW8bbTMKHZbDP0g;BDSVRTM=04、2常用的请求报头1.Host(主机和端口号)Host：对应网址URL中的Web名称和端口号，用于指定被请求资源的Internet主机和端口号，通常属于URL的Host部分。2.Connection(连接类型)Connection：表示客户端与服务连接类型，通常情况下：Client发起一个包含Connection:keep-alive的请求（HTTP/1.1使用keep-alive为默认值）Server收到请求后：如果Server支持keep-alive，回复一个包含Connection:keep-alive的响应，不关闭连接；如果Server不支持keep-alive，回复一个包含Connection:close的响应，关闭连接。如果client收到包含Connection:keep-alive的响应，向同一个连接发送下一个请求，直到一方主动关闭连接。Connection:keep-alive在很多情况下能够重用连接，减少资源消耗，缩短响应时间。比如当浏览器需要多个文件时(比如一个HTML文件和多个Image文件)，不需要每次都去请求建立连接。3.Upgrade-Insecure-Requests(升级为HTTPS请求)Upgrade-Insecure-Requests：升级不安全的请求，意思是会在加载http资源时自动替换成https请求，让浏览器不再显示https页面中的http请求警报。HTTPS是以安全为目标的HTTP通道，所以在HTTPS承载的页面上不允许出现HTTP请求，一旦出现就是提示或报错。4.User-Agent(浏览器名称)User-Agent：标识客户端身份的名称，通常页面会根据不同的User-Agent信息自动做出适配，甚至返回不同的响应内容。5.Accept(传输文件类型)Accept：指浏览器或其他客户端可以接受的MIME（MultipurposeInternetMailExtensions（多用途互联网邮件扩展））文件类型，服务器可以根据它判断并返回适当的文件格式。举例：Accept:*/*：表示什么都可以接收。Accept：image/gif：表明客户端希望接受GIF图像格式的资源；Accept：text/html：表明客户端希望接受html文本。Accept:text/html,application/xhtml+xml;q=0.9,image/*;q=0.8：表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。q是权重系数，范围0=&lt;q&lt;=1，q值越大，请求越倾向于获得其“;”之前的类型表示的内容。若没有指定q值，则默认为1，按从左到右排序顺序；若被赋值为0，则用于表示浏览器不接受此内容类型。Text：用于标准化地表示的文本信息，文本消息可以是多种字符集和或者多种格式的；Application用于传输应用程序数据或者二进制数据。详细请点击6.Referer(页面跳转来源)Referer：表明产生请求的网页来自于哪个URL，用户是从该Referer页面访问到当前请求的页面。这个属性可以用来跟踪Web请求来自哪个页面，是从什么网站来的等。防盗链：有时候遇到下载某网站图片，需要对应的referer，否则无法下载图片，那是因为人家做了防盗链，原理就是根据referer去判断是否是本网站的地址，如果不是，则拒绝，如果是，就可以下载。7.Accept-Encoding（文件编解码格式）Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式，许多情形下这可以减少大量的下载时间。举例：Accept-Encoding:gzip;q=1.0,identity;q=0.5,*;q=0如果有多个Encoding同时匹配,按照q值顺序排列，本例中按顺序支持gzip,identity压缩编码，支持gzip的浏览器会返回经过gzip编码的HTML页面。如果请求消息中没有设置这个报头，通常服务器假定客户端不支持压缩，直接返回文本。8.Accept-Language（语言种类）Accept-Langeuage：指出浏览器可以接受的语言种类，如en或en-us指英语，zh或者zh-cn指中文，当服务器能够提供一种以上的语言版本时要用到。如果目标网站支持多个语种的话，可以使用这个信息来决定返回什么语言的网页。9.Accept-Charset（字符编码）Accept-Charset：指出浏览器可以接受的字符编码。举例：Accept-Charset:iso-8859-1,gb2312,utf-8ISO8859-1：通常叫做Latin-1。Latin-1包括了书写所有西方欧洲语言不可缺少的附加字符，英文浏览器的默认值是ISO-8859-1.gb2312：标准简体中文字符集;utf-8：UNICODE的一种变长字符编码，可以解决多种语言文本显示问题，从而实现应用国际化和本地化。如果在请求消息中没有设置这个域，默认客户端是任何字符集都可以接受，则返回网页charset指定的编码。10.Cookie（Cookie）Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现模拟登陆，之后会详细讲。11.Content-Type(POST数据类型)Content-Type：POST请求里用来表示的内容类型。举例：Content-Type=Text/XML;charset=gb2312：指明该请求的消息体中包含的是纯文本的XML类型的数据，字符编码采用“gb2312”。4.3常用的响应报头1.Cache-Control：must-revalidate,no-cache,private。这个值告诉客户端，服务端不希望客户端缓存资源，在下次请求资源时，必须要从新请求服务器，不能从缓存副本中获取资源。Cache-Control是响应头中很重要的信息，当客户端请求头中包含Cache-Control:max-age=0请求，明确表示不会缓存服务器资源时,Cache-Control作为作为回应信息，通常会返回no-cache，意思就是说，&quot;那就不缓存呗&quot;。当客户端在请求头中没有包含Cache-Control时，服务端往往会定,不同的资源不同的缓存策略，比如说oschina在缓存图片资源的策略就是Cache-Control：max-age=86400,这个意思是，从当前时间开始，在86400秒的时间内，客户端可以直接从缓存副本中读取资源，而不需要向服务器请求。2.Connection：keep-alive这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。3.Content-Encoding:gzip告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。4.Content-Type：text/html;charset=UTF-8告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。5.Date：Sun,21Sep201606:18:21GMT这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。6.Expires:Sun,1Jan200001:00:00GMT这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。7.Pragma:no-cache这个含义与Cache-Control等同。8.Server：Tengine/1.4.6这个是服务器和相对应的版本，只是告诉客户端服务器的信息。9.Transfer-Encoding：chunked这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。10.Vary:Accept-Encoding告诉缓存服务器，缓存压缩文件和非压缩文件两个版本，现在这个字段用处并不大，因为现在的浏览器都是支持压缩的。5、请求方式1GET请求指定的页面信息，并返回实体主体。2POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件），数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。3HEAD类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头4PUT从客户端向服务器传送的数据取代指定的文档的内容。5DELETE请求服务器删除指定的页面。6CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。7OPTIONS允许客户端查看服务器的性能。8TRACE回显服务器收到的请求，主要用于测试或诊断。6、主要的请求方式以及对比，特别重要HTTP请求主要分为Get和Post两类：GET是从服务器上获取指定页面信息，POST是向服务器提交数据并获取页面信息。GET请求参数都显示在URL上，服务器根据该请求所包含URL中的参数来产生响应内容。&quot;Get&quot;请求的参数是URL的一部分。POST请求参数在请求体当中，消息长度没有限制而且以隐式的方式进行发送，通常用来向HTTP服务器提交量比较大的数据（比如请求中包含许多参数或者文件上传操作等）。&quot;POST&quot;请求的参数不在URL中，而在请求体中。页面的form表单一般都有method属性，默认值是&quot;get&quot;。举个栗子，登录时提交用户名和密码：如果用&quot;get&quot;方式，提交表单后，则用户输入的用户名和密码将在地址栏中暴露无遗；如果设置为&quot;post，则提交表单后，地址栏不会有用户名和密码的显示。所以处理登录页面的form表单时，发送的请求都是&quot;POST&quot;方式。7、常见的响应状态码100~199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。200~299：表示服务器成功接收请求并已完成整个处理过程。常用200（OK请求成功）。300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用302（所请求的页面已经临时转移至新的url）、307和304（使用缓存资源）。400~499：客户端的请求有错误，常用404（服务器无法找到被请求的页面）、403（服务器拒绝访问，权限不够）。500~599：服务器端出现错误，常用500（请求未完成。服务器遇到不可预知的情况）。8、HTTP代理器FIDDLERhttps://blog.csdn.net/qq_32252917/article/details/79074180Headers——显示客户端发送到服务器的HTTP请求的header，显示为一个分级视图，包含了Web客户端信息、Cookie、传输状态等。Textview——显示POST请求的body部分为文本。WebForms——显示请求的GET参数和POSTbody内容。HexView——用十六进制数据显示请求。Auth——显示响应header中的Proxy-Authorization(代理身份验证)和Authorization(授权)信息.Raw——将整个请求显示为纯文本。JSON-显示JSON格式文件。XML——如果请求的body是XML格式，就是用分级的XML树来显示它。Transformer——显示响应的编码信息。Headers——用分级视图显示响应的header。TextView——使用文本显示相应的body。ImageVies——如果请求是图片资源，显示响应的图片。HexView——用十六进制数据显示响应。WebView——响应在Web浏览器中的预览效果。Auth——显示响应header中的Proxy-Authorization(代理身份验证)和Authorization(授权)信息。Caching——显示此请求的缓存信息。Privacy——显示此请求的私密(P3P)信息。Raw——将整个响应显示为纯文本。JSON-显示JSON格式文件。XML——如果响应的body是XML格式，就是用分级的XML树来显示它。9、Python2与Python3的对比urllib2Python2.7自带的模块(不需要下载，导入即可使用)urllib.requestpython3中用10、urlopen的使用#urllib2_urlopen.py#导入urllib2库importurllib2#向指定的url发送请求，并返回服务器响应的类文件对象response=urllib2.urlopen(&quot;http://www.baidu.com&quot;)#类文件对象支持文件对象的操作方法，如read()方法读取文件全部内容，返回字符串html=response.read()#打印字符串printhtml11、隐藏身份，增加HTTP报头，创造请求实例11、1参数的学习data（默认空）：提交的Form表单数据，同时HTTP请求方法将从默认的&quot;GET&quot;方式改为&quot;POST&quot;方式。headers（默认空）：参数为字典类型，包含了需要发送的HTTP报头的键值对。11、2实例importurllib2#url作为Request()方法的参数，构造并返回一个Request对象request=urllib2.Request(&quot;http://www.baidu.com&quot;)#Request对象作为urlopen()方法的参数，发送给服务器并接收响应response=urllib2.urlopen(request)html=response.read()printhtml11、3模拟浏览器访问importurllib2url=&quot;http://www'baidu.cn&quot;#IE9.0的User-Agent，包含在user_agent里user_agent={&quot;User-Agent&quot;:&quot;Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0)&quot;}#url连同headers，一起构造Request请求，这个请求将附带IE9.0浏览器的User-Agentrequest=urllib2.Request(url,headers=user_agent)#向服务器发送这个请求response=urllib2.urlopen(request)html=response.read()printhtml11、4增加更多的请求头信息user_agent={&quot;User-Agent&quot;:&quot;Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0)&quot;}request=urllib2.Request(url,headers=user_agent)#也可以通过调用Request.add_header()添加/修改一个特定的headerrequest.add_header(&quot;Connection&quot;,&quot;keep-alive&quot;)#也可以通过调用Request.get_header()来查看header信息#request.get_header(header_name=&quot;Connection&quot;)查看响应状态码printresponse.code#可以查看响应状态码11.5实例importurllib2importrandomurl=&quot;http://www.baidu.com&quot;ua_list=[&quot;Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/537.1(KHTML,likeGecko)Chrome/22.0.1207.1Safari/537.1&quot;,&quot;Mozilla/5.0(X11;CrOSi6862268.111.0)AppleWebKit/536.11(KHTML,likeGecko)Chrome/20.0.1132.57Safari/536.11&quot;,&quot;Mozilla/5.0(WindowsNT6.1;WOW64)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1092.0Safari/536.6&quot;,&quot;Mozilla/5.0(WindowsNT6.1)AppleWebKit/536.6(KHTML,likeGecko)Chrome/20.0.1090.0Safari/536.6&quot;]user_agent=random.choice(ua_list)request=urllib2.Request(url)#也可以通过调用Request.add_header()添加/修改一个特定的headerrequest.add_header(&quot;User-Agent&quot;,user_agent)#get_header()的字符串参数，第一个字母大写，后面的全部小写request.get_header(&quot;User-agent&quot;)response=urllib2.urlopen(request)html=response.read()printhtml12、URL编码的问题urllib与urllib2的对比urllib模块仅可以接受URL，不能创建设置了headers的Request类实例urlencode方法用来产生GET查询字符串，而urllib2则没有，所以搭配使用查询紫川解码unquote()实例：importurllibword={&quot;kw&quot;:&quot;百度&quot;}#通过urllib.urlencode()方法，将字典键值对按URL编码转换，从而能被web服务器接受。urllib.urlencode(word)#通过urllib.unquote()方法，把URL编码字符串，转换回原先字符串。In[4]:printurllib.unquote(&quot;wd=zfds&quot;)总结：一般HTTP请求提交数据，需要编码成URL编码格式，然后做为url的一部分，或者作为参数传到Request对象中13、urlliburllib2结合使用13、1直接获取网页deftiebaSpider(url,beginPage,endPage):forpageinrange(beginPage,endPage+1):pn=(page-1)*50filename=&quot;第&quot;+str(page)+&quot;页.html&quot;fullurl=url+&quot;&amp;pn=&quot;+str(pn)#调用loadPage()发送请求获取HTML页面html=loadPage(fullurl,filename)#将获取到的HTML页面写入本地磁盘文件writeFile(html,filename)defloadPage(url,filename):print&quot;正在下载&quot;+filenameheaders={&quot;User-Agent&quot;:&quot;Mozilla/5.0(compatible;MSIE9.0;WindowsNT6.1;Trident/5.0;&quot;}request=urllib2.Request(url,headers=headers)response=urllib2.urlopen(request)returnresponse.read()defwriteFile(html,filename):print&quot;正在存储&quot;+filenamewithopen(filename,'w')asf:f.write(html)print&quot;-&quot;*20if__name__==&quot;__main__&quot;:kw=raw_input(&quot;请输入需要爬取的贴吧:&quot;)#输入起始页和终止页，str转成int类型beginPage=int(raw_input(&quot;请输入起始页：&quot;))endPage=int(raw_input(&quot;请输入终止页：&quot;))url=&quot;http://tieba.baidu.com/f?&quot;key=urllib.urlencode({&quot;kw&quot;:kw})#组合后的url示例：http://tieba.baidu.com/f?kw=lolurl=url+keytiebaSpider(url,beginPage,endPage)13、2ajax抓取AJAX请求一般返回给网页的是JSON文件，只要对AJAX请求地址进行POST或GET，就能返回JSON数据不能直接对网页url获取13、2、1第一个例子url=&quot;https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;&quot;headers={&quot;User-Agent&quot;:&quot;Mozilla....&quot;}#变动的是这两个参数，从start开始往后显示limit个formdata={'start':'0','limit':'10'}data=urllib.urlencode(formdata)request=urllib2.Request(url+data,headers=headers)response=urllib2.urlopen(request)printresponse.read()#demo2url=&quot;https://movie.douban.com/j/chart/top_list?&quot;headers={&quot;User-Agent&quot;:&quot;Mozilla....&quot;}#处理所有参数formdata={'type':'11','interval_id':'100:90','action':'','start':'0','limit':'10'}data=urllib.urlencode(formdata)request=urllib2.Request(url+data,headers=headers)response=urllib2.urlopen(request)printresponse.read()13、2、2发送post请求importurllibimporturllib2#POST请求的目标URLurl=&quot;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=null&quot;headers={&quot;User-Agent&quot;:&quot;Mozilla....&quot;}formdata={&quot;type&quot;:&quot;AUTO&quot;,&quot;i&quot;:&quot;ilovepython&quot;,&quot;doctype&quot;:&quot;json&quot;,&quot;xmlVersion&quot;:&quot;1.8&quot;,&quot;keyfrom&quot;:&quot;fanyi.web&quot;,&quot;ue&quot;:&quot;UTF-8&quot;,&quot;action&quot;:&quot;FY_BY_ENTER&quot;,&quot;typoResult&quot;:&quot;true&quot;}data=urllib.urlencode(formdata)request=urllib2.Request(url,data=data,headers=headers)response=urllib2.urlopen(request)printresponse.read()14、HTTP和HTTPS的区别urllib2可以为HTTPS请求验证SSL证书，模仿浏览器如果SSL证书验证不通过，或者操作系统不信任服务器的安全证书，比如浏览器在访问12306网站如：https://www.12306.cn/mormhweb/的时候，会警告用户证书不受信任。importssl#表示忽略未经核实的SSL证书认证context=ssl._create_unverified_context()#在urlopen()方法里指明添加context参数response=urllib2.urlopen(request,context=context)15、添加新的功能基本的urlopen()方法不支持代理、Cookie等其他的HTTP/HTTPS高级功能使用相关的Handler处理器来创建特定功能的处理器对象；然后通过urllib2.build_opener()方法使用这些处理器对象，创建自定义opener对象；使用自定义的opener对象，调用open()方法发送请求。注意：如果程序里所有的请求都使用自定义的opener，可以使用urllib2.install_opener()将自定义的opener对象定义为全局opener，表示如果之后凡是调用urlopen，都将使用这个opener（根据自己的需求来选择）。15、1自定义简单的openerimporturllib2#构建一个HTTPHandler处理器对象，支持处理HTTP请求http_handler=urllib2.HTTPHandler()#调用urllib2.build_opener()方法，创建支持处理HTTP请求的opener对象opener=urllib2.build_opener(http_handler)#构建Request请求request=urllib2.Request(&quot;http://www.baidu.com/&quot;)#调用自定义opener对象的open()方法，发送request请求#（注意区别：不再通过urllib2.urlopen()发送请求）response=opener.open(request)#获取服务器响应内容printresponse.read()15、2设置代理器加代理importurllib2#构建了两个代理Handler，一个有代理IP，一个没有代理IPhttpproxy_handler=urllib2.ProxyHandler({&quot;http&quot;:&quot;168.0.0.1:8100&quot;})nullproxy_handler=urllib2.ProxyHandler({})proxySwitch=True#定义一个代理开关#通过urllib2.build_opener()方法使用这些代理Handler对象，创建自定义opener对象#根据代理开关是否打开，使用不同的代理模式ifproxySwitch:opener=urllib2.build_opener(httpproxy_handler)else:opener=urllib2.build_opener(nullproxy_handler)request=urllib2.Request(&quot;http://www.baidu.com/&quot;)#1.如果这么写，只有使用opener.open()方法发送请求才使用自定义的代理，而urlopen()则不使用自定义代理。response=opener.open(request)#2.如果这么写，就是将opener应用到全局，之后所有的，不管是opener.open()还是urlopen()发送请求，都将使用自定义代理。#urllib2.install_opener(opener)#response=urlopen(request)printresponse.read()16、密码管理对象验证代理授权的用户名和密码(ProxyBasicAuthHandler())验证Web客户端的的用户名和密码(HTTPBasicAuthHandler())例如ftp17、cookie的使用Cookie：通过在客户端记录的信息确定用户的身份。Session：通过在服务器端记录的信息确定用户的身份Cookie名字（Name）Cookie的值（Value）Cookie的过期时间（Expires/Max-Age）Cookie作用路径（Path）Cookie所在域名（Domain），使用Cookie进行安全连接（Secure）Set－Cookie:NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE18、cookie在爬虫中的使用判定注册用户是否已经登录网站，在下一次进入此网站时保留用户信息，可以简化登录或其他验证过程实例：#获取一个有登录信息的Cookie模拟登陆importurllib2#1.构建一个已经登录过的用户的headers信息headers={&quot;Host&quot;:&quot;www.renren.com&quot;,&quot;Connection&quot;:&quot;keep-alive&quot;,&quot;Upgrade-Insecure-Requests&quot;:&quot;1&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/54.0.2840.99Safari/537.36&quot;,&quot;Accept&quot;:&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,&quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.8,en;q=0.6&quot;,#便于终端阅读，表示不支持文件压缩#Accept-Encoding:gzip,deflate,sdch,#重点：这个Cookie是一个保存了用户登录状态的Cookie&quot;Cookie&quot;:'iehfiowhjqo'}#2.通过headers里的报头信息（主要是Cookie信息），构建Request对象urllib2.Request(&quot;http://www.renren.com/&quot;,headers=headers)#3.直接访问renren主页，服务器会根据headers报头信息（主要是Cookie信息），判断这是一个已经登录的用户，并返回相应的页面response=urllib2.urlopen(request)#4.打印响应内容printresponse.read()19、cookielibHTTPCookieProcessorcookielib模块：主要作用是提供用于存储cookie的对象HTTPCookieProcessor处理器：主要作用是处理这些cookie对象，并构建handler对象19、1获取cookie，保存到cookiejar中importurllib2importcookielib#构建一个CookieJar对象实例来保存cookiecookiejar=cookielib.CookieJar()#使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象handler=urllib2.HTTPCookieProcessor(cookiejar)#通过build_opener()来构建openeropener=urllib2.build_opener(handler)#4.以get方法访问页面，访问之后会自动保存cookie到cookiejar中opener.open(&quot;http://www.baidu.com&quot;)##可以按标准格式将保存的Cookie打印出来cookieStr=&quot;&quot;foritemincookiejar:cookieStr=cookieStr+item.name+&quot;=&quot;+item.value+&quot;;&quot;##舍去最后一位的分号printcookieStr[:-1]19、2获取cookie，保存到文件中importcookielibimporturllib2#保存cookie的本地磁盘文件名filename='cookie.txt'#声明一个MozillaCookieJar(有save实现)对象实例来保存cookie，之后写入文件cookiejar=cookielib.MozillaCookieJar(filename)#使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象handler=urllib2.HTTPCookieProcessor(cookiejar)#通过build_opener()来构建openeropener=urllib2.build_opener(handler)#创建一个请求，原理同urllib2的urlopenresponse=opener.open(&quot;http://www.baidu.com&quot;)#保存cookie到本地文件cookiejar.save()19、3从文件中读取importcookielibimporturllib2#创建MozillaCookieJar(有load实现)实例对象cookiejar=cookielib.MozillaCookieJar()#从文件中读取cookie内容到变量cookie.load('cookie.txt')#使用HTTPCookieProcessor()来创建cookie处理器对象，参数为CookieJar()对象handler=urllib2.HTTPCookieProcessor(cookiejar)#通过build_opener()来构建openeropener=urllib2.build_opener(handler)response=opener.open(&quot;http://www.baidu.com&quot;)20、错误URLError产生的原因主要有：没有网络连接服务器连接失败找不到指定的服务器HTTPErrorHTTPError是URLError的子类，我们发出一个请求时，服务器上都会对应一个response应答对象，其中它包含一个数字&quot;响应状态码&quot;。如果urlopen或opener.open不能处理的，会产生一个HTTPError，对应相应的状态码，HTTP状态码表示HTTP协议所返回的响应的状态。21、requests包http://docs.python-requests.org/zh_CN/latest/index.html21、1最基础的get请求（headers参数和parmas参数）response=requests.get(&quot;http://www.baidu.com/&quot;)#response=requests.request(&quot;get&quot;,&quot;http://www.baidu.com/&quot;)例子：importrequestskw={'wd':'美食'}headers={&quot;User-Agent&quot;:&quot;Mozilla/5.0(WindowsNT10.0;Win64;x64)AppleWebKit/537.36(KHTML,likeGecko)Chrome/54.0.2840.99Safari/537.36&quot;}#params接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()response=requests.get(&quot;http://www.baidu.com/s?&quot;,params=kw,headers=headers)#查看响应内容，response.text返回的是Unicode格式的数据printresponse.text#查看响应内容，response.content返回的字节流数据printrespones.content#查看完整url地址printresponse.url#查看响应头部字符编码printresponse.encoding#查看响应码printresponse.status_code21.2post请求response=requests.post(&quot;http://www.baidu.com/&quot;,data=data)printresponse.text#如果是json文件可以直接显示printresponse.json()22、request代理服务器#根据协议类型，选择不同的代理proxies={&quot;http&quot;:&quot;http://148.399.56.79:9527&quot;}response=requests.get(&quot;http://www.baidu.com&quot;,proxies=proxies)#私密代理，代表用户名与密码proxy={&quot;http&quot;:&quot;xx:123456@148.399.56.79:9527&quot;}response=requests.get(&quot;http://www.baidu.com&quot;,proxies=proxy)23、web客户端验证auth=('test','123456')response=requests.get('http://192.168.34.7',auth=auth)24、获取cookieresponse=requests.get(&quot;http://www.baidu.com/&quot;)#返回CookieJar对象:cookiejar=response.cookies#将CookieJar转为字典：cookiedict=requests.utils.dict_from_cookiejar(cookiejar)25、session在requests里，session对象是一个非常常用的对象，这个对象代表一次用户会话：从客户端浏览器连接服务器开始，到客户端浏览器与服务器断开。会话能让我们在跨请求时候保持某些参数，比如在同一个Session实例发出的所有请求之间保持cookie。data={&quot;email&quot;:&quot;xx&quot;,&quot;password&quot;:&quot;xx&quot;}#发送附带用户名和密码的请求，并获取登录后的Cookie值，保存在ssion里ssion.post(&quot;http://www.renren.com/PLogin.do&quot;,data=data)#ssion包含用户登录后的Cookie值，可以直接访问那些登录后才可以访问的页面response=ssion.get(&quot;http://www.renren.com/123/profile&quot;)26、数字验证证书的问题跳过12306的证书验证，把verify设置为Falser=requests.get(&quot;https://www.12306.cn/mormhweb/&quot;,verify=False)27、页面提取指定的内容非结构化数据：先有数据，再有结构，结构化数据：先有结构、再有数据非结构化的数据处理文本、电话号码、邮箱地址正则表达式HTML文件正则表达式XPathCSS选择器结构化的数据处理JSON文件JSONPath转化成Python类型进行操作（json类）XML文件转化成Python类型（xmltodict）XPathCSS选择器正则表达式28、正则使用compile()函数将正则表达式的字符串形式编译为一个Pattern对象通过Pattern对象提供的一系列方法对文本进行匹配查找，获得匹配结果，一个Match对象。最后使用Match对象提供的属性和方法获得信息，根据需要进行其他的操作Pattern对象的一些常用方法主要有：match方法：从起始位置开始查找，一次匹配match方法match方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。它的一般使用形式如下：match(string[,pos[,endpos]])search方法：从任何位置开始查找，一次匹配search方法search方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果，它的一般使用形式如下：search(string[,pos[,endpos]])findall方法：全部匹配，返回列表indall方法的使用形式如下：findall(string[,pos[,endpos]])其中，string是待匹配的字符串，pos和endpos是可选参数，指定字符串的起始和终点位置，默认值分别是0和len(字符串长度)。findall以列表形式返回全部能匹配的子串，如果没有匹配，则返回一个空列表。finditer方法：全部匹配，返回迭代器finditer方法finditer方法的行为跟findall的行为类似，也是搜索整个字符串，获得所有匹配的结果。但它返回一个顺序访问每一个匹配结果（Match对象）的迭代器split方法：分割字符串，返回列表split方法split方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下：split(string[,maxsplit])其中，maxsplit用于指定最大分割次数，不指定将全部分割。sub方法：替换sub(repl,string[,count])repl可以是字符串也可以是一个函数：repl是字符串，则会使用repl去替换字符串每一个匹配的子串，并返回替换后的字符串，另外，repl还可以使用id的形式来引用分组，但不能使用编号0；repl是函数，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。count用于指定最多替换次数，不指定时全部替换。29、匹配中文importretitle=u'你好，hello，世界'pattern=re.compile(ur'[\\u4e00-\\u9fa5]+')result=pattern.findall(title)printresult30、贪婪匹配的问题注意：贪婪模式与非贪婪模式贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配(*)；非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配(?)；Python里数量词默认是贪婪的。31、xmlXML指可扩展标记语言（EXtensibleMarkupLanguage）XML是一种标记语言，很类似HTMLXML的设计宗旨是传输数据，而非显示数据XML的标签需要我们自行定义。XML被设计为具有自我描述性。XML是W3C的推荐标准数据格式描述设计目标XMLExtensibleMarkupLanguage（可扩展标记语言）被设计为传输和存储数据，其焦点是数据的内容。HTMLHyperTextMarkupLanguage（超文本标记语言）显示数据以及如何更好显示数据。HTMLDOMDocumentObjectModelforHTML(文档对象模型)通过HTMLDOM，可以访问所有的HTML元素，连同它们所包含的文本和属性。可以对其中的内容进行修改和删除，同时也可以创建新的元素。XML的节点关系1.父（Parent）每个元素以及属性都有一个父。2.子（Children）元素节点可有零个、一个或多个子。3.同胞（Sibling）拥有相同的父的节点4.先辈（Ancestor）某节点的父、父的父，等等。5.后代（Descendant）某个节点的子，子的子，等等。32、xpath32、1XPath开发工具开源的XPath表达式编辑工具:XMLQuire(XML格式文件可用)Chrome插件XPathHelperFirefox插件XPathChecker32、2选取节点表达式描述nodename选取此节点的所有子节点。/从根节点选取。//从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。.选取当前节点。..选取当前节点的父节点。@选取属性。32、3使用fromlxmlimportetreehtml=etree.HTML(text)#按字符串序列化HTML文档result=etree.tostring(html)33、css选择器（配合bs4）lxml只会局部遍历，而BeautifulSoup是基于HTMLDOM的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。frombs4importBeautifulSoupsoup=BeautifulSoup(html)34、bs转化的四类BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:TagHTML中的一个个标签NavigableStringBeautifulSoupComment35、多线程见案例多线程：importrequestsimporttimefromQueueimportQueuefromlxmlimportetreeimportthreadingclassDouban(object):def__init__(self):self.headers={&quot;User-Agent&quot;:&quot;Mozilla/5.0(WindowsNT10.0;WOW64;Trident/7.0;rv:11.0)likeGecko&quot;}self.base_url=&quot;https://movie.douban.com/top250?start=&quot;self.url_list=[self.base_url+str(page)forpageinrange(0,225+1,25)]#创建保存数据的队列self.data_queue=Queue()self.count=0defsend_request(self,url):print&quot;[INFO]:正在抓取&quot;+urlhtml=requests.get(url,headers=self.headers).content#每次请求间隔1秒time.sleep(1)self.parse_page(html)defparse_page(self,html):html_obj=etree.HTML(html)node_list=html_obj.xpath(&quot;//div[@class='info']&quot;)fornodeinnode_list:#电影标题title=node.xpath(&quot;./div[@class='hd']/a/span[1]/text()&quot;)[0]#电影评分score=node.xpath(&quot;.//span[@class='rating_num']/text()&quot;)[0]self.count+=1self.data_queue.put(score+&quot;\\t&quot;+title)defstart_work(self):#单线程：&quot;&quot;&quot;forurlinself.url_list:self.send_request(url)&quot;&quot;&quot;thread_list=[]forurlinself.url_list:#创建一个线程对象thread=threading.Thread(target=self.send_request,args=[url])#启动线程，执行任务thread.start()#将当前线程对象存到列表thread_list.append(thread)#让主线程等待，所有子线程执行结束，再执行后面的代码forthreadinthread_list:thread.join()whilenotself.data_queue.empty():printself.data_queue.get()printself.countif__name__==&quot;__main__&quot;:douban=Douban()start=time.time()douban.start_work()print&quot;[INFO]:Useingtime%fsecend&quot;%(time.time()-start)#[INFO]:Useingtime1.483035secend36、解决js和jqSelenium+chromdriver36、1鼠标事件#导入ActionChains类fromselenium.webdriverimportActionChains#鼠标移动到ac位置ac=driver.find_element_by_xpath('element')ActionChains(driver).move_to_element(ac).perform()#在ac位置单击ac=driver.find_element_by_xpath(&quot;elementA&quot;)ActionChains(driver).move_to_element(ac).click(ac).perform()#在ac位置双击ac=driver.find_element_by_xpath(&quot;elementB&quot;)ActionChains(driver).move_to_element(ac).double_click(ac).perform()#在ac位置右击ac=driver.find_element_by_xpath(&quot;elementC&quot;)ActionChains(driver).move_to_element(ac).context_click(ac).perform()#在ac位置左键单击hold住ac=driver.find_element_by_xpath('elementF')ActionChains(driver).move_to_element(ac).click_and_hold(ac).perform()#将ac1拖拽到ac2位置ac1=driver.find_element_by_xpath('elementD')ac2=driver.find_element_by_xpath('elementE')ActionChains(driver).drag_and_drop(ac1,ac2).perform()36、2填充表单#导入Select类fromselenium.webdriver.support.uiimportSelect#找到name的选项卡select=Select(driver.find_element_by_name('status'))#select.select_by_index(1)select.select_by_value(&quot;0&quot;)select.select_by_visible_text(u&quot;北京&quot;)以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。注意：index索引从0开始value是option标签的一个属性值，并不是显示在下拉框中的值visible_text是在option标签文本的值，是显示在下拉框的值全部取消选择怎么办呢？很简单:select.deselect_all()36、3弹窗处理alert=driver.switch_to_alert()36、4页面切换一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下：driver.switch_to.window(&quot;thisiswindowname&quot;)也可以使用window_handles方法来获取每个窗口的操作对象。例如：forhandleindriver.window_handles:driver.switch_to_window(handle)36、5页面前进与后退driver.forward()#前进driver.back()#后退36、6获取cookie获取页面每个Cookies值，用法如下forcookieindriver.get_cookies():print&quot;%s=%s;&quot;%(cookie['name'],cookie['value'])除Cookies，用法如下#Bynamedriver.delete_cookie(&quot;BAIDUID&quot;)#alldriver.delete_all_cookies()36、7页面等待36、7、1显示等待显式等待显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。fromseleniumimportwebdriverfromselenium.webdriver.common.byimportBy#WebDriverWait库，负责循环等待fromselenium.webdriver.support.uiimportWebDriverWait#expected_conditions类，负责条件出发fromselenium.webdriver.supportimportexpected_conditionsasECdriver=webdriver.PhantomJS()driver.get(&quot;http://www.xxxxx.com/loading&quot;)try:#每隔10秒查找页面元素id=&quot;myDynamicElement&quot;，直到出现则返回element=WebDriverWait(driver,10).until(EC.presence_of_element_located((By.ID,&quot;myDynamicElement&quot;)))finally:driver.quit()如果不写参数，程序默认会0.5s调用一次来查看元素是否已经生成，如果本来元素就是存在的，那么会立即返回。下面是一些内置的等待条件，你可以直接调用这些条件，而不用自己写某些等待条件了。title_istitle_containspresence_of_element_locatedvisibility_of_element_locatedvisibility_ofpresence_of_all_elements_locatedtext_to_be_present_in_elementtext_to_be_present_in_element_valueframe_to_be_available_and_switch_to_itinvisibility_of_element_locatedelement_to_be_clickable–itisDisplayedandEnabled.staleness_ofelement_to_be_selectedelement_located_to_be_selectedelement_selection_state_to_beelement_located_selection_state_to_bealert_is_present36、7、2隐式等待fromseleniumimportwebdriverdriver=webdriver.PhantomJS()driver.implicitly_wait(10)#secondsdriver.get(&quot;http://www.xxxxx.com/loading&quot;)myDynamicElement=driver.find_element_by_id(&quot;myDynamicElement&quot;)37、Scrapy框架ScrapyEngine(引擎):负责Spider、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等。Scheduler(调度器):它负责接受引擎发送过来的Request请求，并按照一定的方式进行整理排列，入队，当引擎需要时，交还给引擎。Downloader（下载器）：负责下载ScrapyEngine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给ScrapyEngine(引擎)，由引擎交给Spider来处理，Spider（爬虫）：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，ItemPipeline(管道)：它负责处理Spider中获取到的Item，并进行进行后期处理（详细分析、过滤、存储等）的地方.DownloaderMiddlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件。SpiderMiddlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spider中间通信的功能组件（比如进入Spider的Responses;和从Spider出去的Requests）38、安装sudopipinstallscrapy39、使用39、1创建项目scrapystartprojectmySpiderscrapy.cfg：项目的配置文件mySpider/：项目的Python模块，将会从这里引用代码mySpider/items.py：项目的目标文件mySpider/pipelines.py：项目的管道文件mySpider/settings.py：项目的设置文件mySpider/spiders/：存储爬虫代码目录39、2scrapyshell&quot;http://www.baidu.com&quot;39、3Selectors选择器ScrapySelectors内置XPath和CSSSelector表达式机制Selector有四个基本的方法，最常用的还是xpath:xpath():传入xpath表达式，返回该表达式所对应的所有节点的selectorlist列表extract():序列化该节点为Unicode字符串并返回listcss():传入CSS表达式，返回该表达式所对应的所有节点的selectorlist列表，语法同BeautifulSoup4re():根据传入的正则表达式对数据进行提取，返回Unicode字符串list列表40、Scrapy和scrapy-redis的区别Scrapy是一个通用的爬虫框架，但是不支持分布式，Scrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)。pipinstallscrapy-redisScrapy-redis提供了下面四种组件（components）：(四种组件意味着这四个模块都要做相应的修改)SchedulerDuplicationFilterItemPipelineBaseSpider41、最后总结一下scrapy-redis的总体思路：这套组件通过重写scheduler和spider类，实现了调度、spider启动和redis的交互。实现新的dupefilter和queue类，达到了判重和调度容器和redis的交互，因为每个主机上的爬虫进程都访问同一个redis数据库，所以调度和判重都统一进行统一管理，达到了分布式爬虫的目的。当spider被初始化时，同时会初始化一个对应的scheduler对象，这个调度器对象通过读取settings，配置好自己的调度容器queue和判重工具dupefilter。每当一个spider产出一个request的时候，scrapy引擎会把这个reuqest递交给这个spider对应的scheduler对象进行调度，scheduler对象通过访问redis对request进行判重，如果不重复就把他添加进redis中的调度器队列里。当调度条件满足时，scheduler对象就从redis的调度器队列中取出一个request发送给spider，让他爬取。当spider爬取的所有暂时可用url之后，scheduler发现这个spider对应的redis的调度器队列空了，于是触发信号spider_idle，spider收到这个信号之后，直接连接redis读取strart_url池，拿去新的一批url入口，然后再次重复上边的工作。42、https://github.com/rolando/scrapy-redis43、connection.py负责根据setting中配置实例化redis连接。被dupefilter和scheduler调用，总之涉及到redis存取的都要使用到这个模块。44、dupefilter.py负责执行requst的去重，实现的很有技巧性，使用redis的set数据结构。但是注意scheduler并不使用其中用于在这个模块中实现的dupefilter键做request的调度，而是使用queue.py模块中实现的queue。当request不重复时，将其存入到queue中，调度时将其弹出。45、crapy-Redis分布式策略：假设有四台电脑：Windows10、MacOSX、Ubuntu16.04、CentOS7.2，任意一台电脑都可以作为Master端或Slaver端，比如：Master端(核心服务器)：使用Windows10，搭建一个Redis数据库，不负责爬取，只负责url指纹判重、Request的分配，以及数据的存储Slaver端(爬虫程序执行端)：使用MacOSX、Ubuntu16.04、CentOS7.2，负责执行爬虫程序，运行过程中提交新的Request给Master","link":"https://18279493170.github.io/VZL9By2eH/"},{"title":"ajax   fetch    axios区别","content":"AjaxAsynchronousJavascriptAndXML（异步的JavaScript和XML）它并不是一种单一的技术，而是有机利用一系列交互式网页应用相关的技术所形成的结合体AJAX是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。优点：页面无刷新，用户体验好。异步通信，更加快的响应能力。减少冗余请求，减轻了服务器负担基于标准化的并被广泛支持的技术，不需要下载插件或者小程序JavaScript的AjaxAjax的全称是AsynchronousJavaScriptandXML，意思就是用JavaScript执行异步网络请求，而不需要重载（刷新）整个页面。Ajax使用XMLHttpRequest对象取得新数据，然后再通过DOM将新数据插入到页面中。另外，虽然名字中包含XML的成分，但Ajax通信与数据格式无关;这种技术就是无须刷新页面即可从服务器取得数据，但不一定是XML数据。对于IE7+和其他浏览器，可以直接使用XMLHttpRequest对象，对于IE6及以前的浏览器，使用ActiveXObject对象。//使用varxhr;if(window.XMLHttpRequest){xhr=newXMLHttpRequest();}else{xhr=newActiveXObject('Microsoft.XMLHTTP');}//启动xhr.open(method,url,boolean);xhr.send();1，xhr.open参数含义：method：请求方式，post、get等url:请求链接，只能向同源的url发送请求boolean：是否异步请求，true：异步，false:同步，默认为true2，调用open()方法并不会真正发送请求，而只是启动一个请求以备发送。3，send()方法接收一个参数，即要作为请求主体发送的数据(post方法会使用，get方法直接传null)。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。调用send()之后，请求就会被分派到服务器。","link":"https://18279493170.github.io/LPvWAvr2G/"},{"title":"简历","content":"个人信息姓名：徐志良工作经验：4年手机：18279493170邮箱：1178308665@qq.com专业：计算机网络技术求职意向期望职位：中级前端开发工程师工作性质：全职目前状况：离职状态，立即上岗期望薪资：面议工作经历2018/6--2022/4------雄采友迎科技有限公司------初级前端开发工程师专业技能熟悉html5，css3，JavaScript，ajax等技术熟悉vue全家桶及其项目开发技术熟悉微信小程序及uniapp混合式开发技术熟悉flex布局，熟悉web端和移动端页面兼容熟悉sass，less等预编译语言提高代码开发效率及规范性熟悉webpack，npm等工具，熟练使用git进行项目代码管理熟悉各种移动端布局和技术，对各终端的页面适配有深入的理解和项目经验熟悉JavaScript，ES5/ES6，HTTP协议熟悉elementUI，colorUI，uVeiwUI等UI框架了解Python和爬虫开发了解bootstrap框架了解Echarts及其数据可视化开发项目经验翠桠app项目描述项目职责与UI设计对接app的前端页面开发与后端进行相关接口测试与对接进行混合app的后台管理系统开发与产品沟通，迭代改进及维护产品技术描述采管app项目描述采管app是专门为大型超市开发的集上架，审核，财务，采购和供货商等多部门角色开发的超市物流闭环app。其主要流程：1.超市上架员工统计需求货物清单并将采购单提交给审核主管2.审核人员经审核清单无误或进行编辑后提交给采购部3.采购部经与供货商协商比价确认货物后将供货清单提交给财务部4.财务部核对数据无误后直接向供货商账户打款5.供货商款项到账后向采购部供货6.采购部确认货物无误后确认供货单7.超市大堂员工上架货物后拍照确认项目职责与UI设计对接app的前端页面开发与后端进行相关接口测试与对接进行混合app的后台管理系统开发与产品沟通，迭代改进及维护产品技术描述使用基于Vue.js开发的Uniapp框架+UviewUI进行APP的开发使用Vue全家桶+element+Echarts进行后台管理系统的页面搭建对uniapp编译后进行Android与iOS端的兼容团猿骑手端项目描述项目职责技术描述团猿商家端项目描述项目职责技术描述团猿后台管理系统项目描述项目职责技术描述团猿小程序项目描述项目职责技术描述技术博客CSDN个人自我评价热爱编程，有良好的逻辑思维能力及良好的代码风格自学能力和理解能力强,新知识新软件都能通过自学掌握。具有较强的抗压能力，良好的沟通能力和团队协作能力。熟练掌握JavaScript编程语言，熟悉Python，能够阅读简单英文文档。","link":"https://18279493170.github.io/jian-li/"},{"title":"android兼容","content":"打开页面默认弹出软键盘，同时兼容iOS和Androidinput不需要添加autofocus属性。//示例1open_soft_keyboard({input:&quot;#username&quot;});//示例2open_soft_keyboard({input:'input[value=&quot;&quot;]'});/***默认打开软键盘*@paramoptions{*input:'#nickname'//容器节点*}*/functionopen_soft_keyboard(options){if(plus.os.name=='iOS'){setTimeout(function(){varwv_current=plus.webview.currentWebview().nativeInstanceObject();wv_current.plusCallMethod({&quot;setKeyboardDisplayRequiresUserAction&quot;:false});document.querySelector(options['input']).focus();},330);}else{//因为安卓autofocus只有4.0版本以上才支持，所以这里使用native.js来强制弹出setTimeout(function(){//在执行的时候需要让当前webview获取焦点varwv_current=plus.android.currentWebview();plus.android.importClass(wv_current);wv_current.requestFocus();varContext=plus.android.importClass(&quot;android.content.Context&quot;);varInputMethodManager=plus.android.importClass(&quot;android.view.inputmethod.InputMethodManager&quot;);varmain=plus.android.runtimeMainActivity();varimm=main.getSystemService(Context.INPUT_METHOD_SERVICE);imm.toggleSoftInput(0,InputMethodManager.SHOW_FORCED);document.querySelector(options['input']).focus();},330);}}Native.js获取已配对蓝牙设备列表functionbluetooth_list(){varmain=plus.android.runtimeMainActivity();varBluetoothAdapter=plus.android.importClass(&quot;android.bluetooth.BluetoothAdapter&quot;);varBAdapter=BluetoothAdapter.getDefaultAdapter();varContext=plus.android.importClass(&quot;android.content.Context&quot;);varlists=BAdapter.getBondedDevices();plus.android.importClass(lists);varlen=lists.size();console.log(len);variterator=lists.iterator();plus.android.importClass(iterator);while(iterator.hasNext()){vard=iterator.next();plus.android.importClass(d);console.log(d.getName());}}","link":"https://18279493170.github.io/VCtYX22yb/"},{"title":"git问题集","content":"收录项目中所有遇到的git问题，以防二次入坑😂Yourbranchisaheadof'origin/master'by1commit原因在于你的本地分支高于远程仓库一次提交，解决方式：--同步更新gitpushoriginmasterwarning:LFwillbereplacedbyCRLFinmain.luaThefilewillhaveitsoriginallineendingsinyourworkingdirectory.原因在于：CR代表回车(\\r)LF代表换行(\\n)，在Dos\\Windows平台下使用CRLF结束一行，即\\r\\n；在Max\\Linux平台下是用LF结束一行，即\\n如果Mac和Windows平台下代码的更新以及提交，就会出现问题，其解决方式：--检出时将LF转换为CRLF,提交时将CRLF转换为LF（windows推荐）$gitconfig--globalcore.autocrlftrue--提交时转换为LF，检出时不转换（Unix推荐）$gitconfig--globalcore.autocrlfinput--提交检出均不转换(没有跨平台那一说)$gitconfig--globalcore.autocrlffalseerror:RPCfailed;curl56OpenSSLSSL_read:SSL_ERROR_SYSCALL,errno10054fatal:TheremoteendhungupunexpecteWritingobjectdlys:62原因在于：上传文件有大小限制，解决方式：gitconfighttp.sslVerify&quot;false&quot;Yourbranchand'origin/master'havediverged,andhave1and1differentcommitseach,respectively.原因在于：存在两种或多种提交，导致本地与远程不同步，比如远程进行了修改提交，本地在未同步更新的情况下也进行了提交首先输入命令：gitrebaseorigin/master再执行命令：gitpull--rebase最后执行命令：gitpushoriginmastererror:pathspec'branch_fistfight_0802'didnotmatchanyfile(s)knowntogit.问题描述：使用其他设备从GitHub中导出远程分支项目，无法成功。其原因在于本地中根本没有其分支。解决命令如下：gitfetch--获取所有分支的更新gitbranch-a--查看本地和远程分支列表，remotes开头的均为远程分支--导出其远程分支，并通过-b设定本地分支跟踪远程分支gitcheckoutremotes/branch_name-bbranch_nameYourbranchisbasedon'origin/****',buttheupstreamisgone问题描述：从远程分支拉下代码，在本地创建分支abranch。后又在aBranch的基础上创建分支bBranch，并删除aBranch关联的远程分支。使用gitstatus的时候就会出现该问题，是因为即使你的远程分支删除了，但是分支的关联依然存在。因为解决命令如下：--设置新的关联分支gitbranch--set-upstream-to=origin/bBrancherror:unabletodelete&quot;branch_Screen_0705&quot;:remoterefdoesnotexist问题描述：使用gitfetch后，然后使用gitbranch-av查看本地所有的分支目录，然后删除指定的远程分支(该分支在GitHub中已经不存在了)，就会出现该问题，其原因在于gitfetch保存到本地的缓存信息而已，因此可以使用命令：gitfetch--pruneorigin或者gitfetch--poriginGIT无法Clone仓库到本地错误信息：error:RPCfailed;HTTP302curl22TherequestedURLreturnederror:302fatal:theremoteendhungupunexpectedly问题的原因的：http.followRedirects不能自动跳造成的。解决办法：打开gitbash输入如下内容：gitconfig--globalhttp.https://xxx.xxx.git.followRedirects&quot;true&quot;其中，需要把:https://xxx.xxx.git改成你要clone的网址，比如：https://gitee.xxx.git合并其它仓库到自己的仓库并保留其提交历史合并Git仓库A的分支master到Git仓库B的名为MergeFrmA分支,并保留A的所有提交记录主要步骤如下：1.切换到要合并到的仓库（即仓库B）的MergeFrmA2.在仓库A的所在目录中打开gitbash，假设仓库A的地址为https://gitee.com/projectA.git，则在gitbash中输入如下内容:gitremoteaddmasterhttps://gitee.com/projectA.gitgitfetch--all或者：gitpullhttps://gitee.com/projectA.gitfetch仅是下载到本地做为一个独立分支，没有合并，需要手动合并一下再提交；pull则是直接与当前分支进行了合并；处理完后，可以使用gitgui或sourcetree或者命令行来提交该合并到仓库B的服务端；删除远端仓库的某次提交重置至指定版本，即本地仓库commit的ID--soft：保留当前工作区，以便重新提交。--hard：会撤销相应工作区的修改，谨慎使用。gitreset--hardcommitID然后可以再使用：gitlog，查看重置是否成功commitID可以是完整的ID，也可以是缩略的ID（中括号中的ID值为缩略值）强制推送，即远程仓库push的取消。参数force是必须的，否则报错：本地项目版本号低于远端仓库版本号gitpush--force这样就会把该提交之后的(也就是比日期更新的）给清除掉(注意：不可恢复式的清除），使该次提交成为仓库中最新的一次提交；fatal:refusingtomergeunrelatedhistoriesvgitmergemaster--allow-unrelated-historiesgitlab修改远程分支名称远程分支重命名(已经推送远程-假设本地分支和远程对应分支名称相同)重命名远程分支对应的本地分支gitbranch-moldNamenewName删除远程分支gitpush--deleteoriginoldName上传新命名的本地分支gitpushoriginnewName把修改后的本地分支与远程分支关联gitbranch--set-upstream-toorigin/newName或删除无端分支的时候出现如下错误，则说明当前被删除的分支为gitclone时的默认分支，不允许删除，所以需要去git对应的托管平台上，把项目的默认clone分支配置为别的，比如配置为master，然后再删除就可以了。","link":"https://18279493170.github.io/R5715OeCw/"},{"title":"git 总结","content":"简介Git是一个开源的分布式版本控制系统。版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。分布式客户端把代码仓库完整地镜像下来。任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。集中式如CVS，Subversion等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。安装Debian/Ubuntu环境$apt-getinstalllibcurl4-gnutls-devlibexpat1-devgettext\\libz-devlibssl-dev$apt-getinstallgit-core$git--versiongitversion1.8.1.2Centos/RedHat环境$yuminstallcurl-develexpat-develgettext-devel\\openssl-develzlib-devel$yum-yinstallgit-core$git--versiongitversion1.7.1Windows/Mac环境Git官方下载地址下载exe安装包。按照安装向导安装即可。建议安装GitBash这个git的命令行工具。git下载配置Git自带一个gitconfig的工具来帮助设置控制Git外观和行为的配置变量。这些变量存储在三个不同的位置：/etc/gitconfig文件:包含系统上每一个用户及他们仓库的通用配置。如果使用带有--system选项的gitconfig时，它会从此文件读写配置变量。~/.gitconfig或~/.config/git/config文件：只针对当前用户。可以传递--global选项让Git读写此文件。当前使用仓库的Git目录中的config文件（就是.git/config）：针对该仓库。每一个级别覆盖上一级别的配置，所以.git/config的配置变量会覆盖/etc/gitconfig中的配置变量。在Windows系统中，Git会查找[公式]USER）的.gitconfig文件。Git同样也会寻找/etc/gitconfig文件，但只限于MSys的根目录下，即安装Git时所选的目标位置。基本概念版本库当你克隆一个项目到本地或创建一个git项目，项目目录下会有一个隐藏的.git子目录。这个目录是git用来跟踪管理版本库的，千万不要手动修改。哈希值Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。这个功能建构在Git底层，是构成Git哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git就能发现。Git用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由40个十六进制字符（0-9和a-f）组成字符串，基于Git中文件的内容或目录结构计算出来。SHA-1哈希看起来是这样：24b9da6552252987aa493b52f8696cd6d3b00373Git中使用这种哈希值的情况很多，你将经常看到这种哈希值。实际上，Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。文件状态三种状态:已修改（modified）-已修改表示修改了文件，但还没保存到数据库中。已暂存（staged）-已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。已提交（committed）-已提交表示数据已经安全的保存在本地数据库中。工作区域与文件状态对应，不同状态的文件在Git中处于不同的工作区域工作区（working）-当你gitclone一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。暂存区（staging）-暂存区是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作`‘索引’'，不过一般说法还是叫暂存区。本地仓库（local）-提交更新，找到暂存区域的文件，将快照永久性存储到Git本地仓库。远程仓库（remote）-以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。分支（Branch）为了将修改记录的整个流程分开存储，让分开的分支不受其它分支的影响，所以在同一个数据库里可以同时进行多个不同的修改主分支（Master）是Git为我们自动创建的第一个分支，也叫主分支，其它分支开发完成后都要合并到master标签（Tag）用于标记特定的点或提交的历史，通常会用来标记发布版本的名称或版本号（如：publish/0.0.1），虽然标签看起来有点像分支，但打上标签的提交是固定的，不能随意的改动HEAD可以理解为指针，指向当前仓库所处的分支。一般在有Git管理的目录下打开Git终端都能在当前路径的尾巴上，看到所处的分支名。命令git命令大全配置全局配置#用户信息$gitconfig--globaluser.name&quot;your_name&quot;$gitconfig--globaluser.email&quot;your_email&quot;#文本编辑器$gitconfig--globalcore.editor&quot;nvim&quot;#分页器$gitconfig--globalcore.pager&quot;more&quot;#别名$gitconfig--globalalias.gs&quot;gitstatus&quot;#纠错$gitconfig--globalhelp.autocorrect1个人配置#不加--global参数的话，则为个人配置$gitconfig--list$gitconfiguser.name$gitconfiguser.name&quot;your_name&quot;#如果在项目中设置，则保存在.git/config文件里面$cat.git/config[user]name=&quot;your_name&quot;......创建仓库克隆一个已创建的仓库：#通过SSH$gitclonessh://user@domain.com/repo.git#通过HTTP$gitclonehttp://domain.com/user/repo.git创建一个新的本地仓库：$gitinit添加修改到暂存区把指定文件添加到暂存区$gitaddxxx把当前所有修改添加到暂存区$gitadd.把所有修改添加到暂存区$gitadd-A提交修改到本地仓库提交本地的所有修改$gitcommit-a提交之前已标记的变化$gitcommit附加消息提交$gitcommit-m'commitmessage'储藏有时，我们需要在同一个项目的不同分支上工作。当需要切换分支时，偏偏本地的工作还没有完成，此时，提交修改显得不严谨，但是不提交代码又无法切换分支。这时，你可以使用gitstash将本地的修改内容作为草稿储藏起来。#1.将修改作为当前分支的草稿保存$gitstash#2.查看草稿列表$gitstashliststash@{0}:WIPonmaster:6fae349:memo:Writingdocs.#3.1删除草稿$gitstashdropstash@{0}#3.2读取草稿$gitstashapplystash@{0}撤销修改撤销本地修改#移除缓存区的所有文件（i.e.撤销上次gitadd）$gitresetHEAD#将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改$gitreset&lt;commit&gt;#将HEAD重置到上一次提交的版本，并保留未提交的本地修改$gitreset--keep&lt;commit&gt;#放弃工作目录下的所有修改$gitreset--hardHEAD#将HEAD重置到指定的版本，并抛弃该版本之后的所有修改$gitreset--hard&lt;commit-hash&gt;#用远端分支强制覆盖本地分支$gitreset--hard&lt;remote/branch&gt;e.g.,upstream/master,origin/my-feature#放弃某个文件的所有本地修改$gitcheckoutHEAD&lt;file&gt;删除添加.gitignore文件前错误提交的文件$gitrm-r--cached.$gitadd.$gitcommit-m&quot;removexyzfile&quot;撤销远程修改（创建一个新的提交，并回滚到指定版本）$gitrevert&lt;commit-hash&gt;彻底删除指定版本#执行下面命令后，commit-hash提交后的记录都会被彻底删除，使用需谨慎$gitreset--hard&lt;commit-hash&gt;$gitpush-f更新推送更新#下载远端版本，但不合并到HEAD中$gitfetch&lt;remote&gt;#将远端版本合并到本地版本中$gitpulloriginmaster#以rebase方式将远端分支与本地合并$gitpull--rebase&lt;remote&gt;&lt;branch&gt;推送#将本地版本推送到远程端$gitpushremote&lt;remote&gt;&lt;branch&gt;#删除远程端分支$gitpush&lt;remote&gt;:&lt;branch&gt;(sinceGitv1.5.0)$gitpush&lt;remote&gt;--delete&lt;branch&gt;(sinceGitv1.7.0)#发布标签$gitpush--tags查看信息显示工作路径下已修改的文件$gitstatus显示与上次提交版本文件的不同$gitdiff显示提交历史#从最新提交开始，显示所有的提交记录（显示hash，作者信息，提交的标题和时间）$gitlog#显示某个用户的所有提交$gitlog--author=&quot;username&quot;#显示某个文件的所有修改$gitlog-p&lt;file&gt;显示搜索内容#从当前目录的所有文件中查找文本内容$gitgrep&quot;Hello&quot;#在某一版本中搜索文本$gitgrep&quot;Hello&quot;v2.5分支增删查分支#列出所有的分支$gitbranch#列出所有的远端分支$gitbranch-r#基于当前分支创建新分支$gitbranch&lt;new-branch&gt;#基于远程分支创建新的可追溯的分支$gitbranch--track&lt;new-branch&gt;&lt;remote-branch&gt;#删除本地分支$gitbranch-d&lt;branch&gt;#强制删除本地分支，将会丢失未合并的修改$gitbranch-D&lt;branch&gt;切换分支#切换分支$gitcheckout&lt;branch&gt;#创建并切换到新分支$gitcheckout-b&lt;branch&gt;标签gittag#列出所有本地标签gittag&lt;tagname&gt;#基于最新提交创建标签gittag-a&quot;v1.0&quot;-m&quot;一些说明&quot;#-a指定标签名称，-m指定标签说明gittag-d&lt;tagname&gt;#删除标签合并重置merge与rebase虽然是git常用功能，但是强烈建议不要使用git命令来完成这项工作。因为如果出现代码冲突，在没有代码比对工具的情况下，实在太艰难了。你可以考虑使用各种GitGUI工具。gitmerge&lt;branch&gt;#合并指定分支到当前分支gitmerge--abort#取消当前合并，重建合并前状态gitmergedev-Xtheirs#以合并dev分支到当前分支，有冲突则以dev分支为准gitrebase&lt;branch&gt;#衍合指定分支到当前分支远程操作gitremote-v#查看远程版本库信息gitremoteshow&lt;remote&gt;#查看指定远程版本库信息gitremoteadd&lt;remote&gt;&lt;url&gt;#添加远程版本库gitremoteremove&lt;remote&gt;#删除指定的远程版本库gitfetch&lt;remote&gt;#从远程库获取代码gitpull&lt;remote&gt;&lt;branch&gt;#下载代码及快速合并gitpush&lt;remote&gt;&lt;branch&gt;#上传代码及快速合并gitpush&lt;remote&gt;:&lt;branch/tag-name&gt;#删除远程分支或标签gitpush--tags#上传所有标签分支开发Git是目前最流行的源代码管理工具。为规范开发，保持代码提交记录以及git分支结构清晰，方便后续维护，现规范git的相关操作。分支命名master分支master为主分支，也是用于部署生产环境的分支，确保master分支稳定性，master分支一般由develop以及hotfix分支合并，任何时间都不能直接修改代码develop分支develop为开发分支，始终保持最新完成以及bug修复后的代码，一般开发的新功能时，feature分支都是基于develop分支下创建的。feature分支开发新功能时，以develop为基础创建feature分支。分支命名:feature/开头的为特性分支，命名规则:feature/user_module、feature/cart_modulerelease分支release为预上线分支，发布提测阶段，会release分支代码为基准提测。当有一组feature开发完成，首先会合并到develop分支，进入提测时会创建release分支。如果测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。hotfix分支分支命名:hotfix/开头的为修复分支，它的命名规则与feature分支类似。线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支常见任务增加新功能(dev)$:gitcheckout-bfeature/xxx#从dev建立特性分支(feature/xxx)$:blabla#开发(feature/xxx)$:gitaddxxx(feature/xxx)$:gitcommit-m'commitcomment'(dev)$:gitmergefeature/xxx--no-ff#把特性分支合并到dev修复紧急bug(master)$:gitcheckout-bhotfix/xxx#从master建立hotfix分支(hotfix/xxx)$:blabla#开发(hotfix/xxx)$:gitaddxxx(hotfix/xxx)$:gitcommit-m'commitcomment'(master)$:gitmergehotfix/xxx--no-ff#把hotfix分支合并到master，并上线到生产环境(dev)$:gitmergehotfix/xxx--no-ff#把hotfix分支合并到dev，同步代码测试环境代码(release)$:gitmergedev--no-ff#把dev分支合并到release，然后在测试环境拉取并测试生产环境上线(master)$:gitmergerelease--no-ff#把release测试好的代码合并到master，运维人员操作(master)$:gittag-av0.1-m'部署包版本名'#给版本命名，打Tag常用命令#工作区-&gt;暂存区$gitadd&lt;file/dir&gt;#暂存区-&gt;本地仓库$gitcommit-m&quot;someinfo&quot;#本地仓库-&gt;远程仓库$gitpushoriginmaster#本地master分支推送到远程origin仓库#工作区&lt;-暂存区$gitcheckout--&lt;file&gt;#暂存区文件内容覆盖工作区文件内容#暂存区&lt;-本地仓库$gitresetHEAD&lt;file&gt;#本地仓库文件内容覆盖暂存区文件内容#本地仓库&lt;-远程仓库$gitclone&lt;git_url&gt;#克隆远程仓库$gitfetchupstreammaster#拉取远程代码到本地但不应用在当前分支$gitpullupstreammaster#拉取远程代码到本地但应用在当前分支$gitpull--rebaseupstreammaster#如果平时使用rebase合并代码则加上#工作区&lt;-本地仓库$gitreset&lt;commit&gt;#本地仓库覆盖到工作区(保存回退文件内容修改)$gitreset--mixed&lt;commit&gt;#本地仓库覆盖到工作区(保存回退文件内容修改)$gitreset--soft&lt;commit&gt;#本地仓库覆盖到工作区(保留修改并加到暂存区)$gitreset--hard&lt;commit&gt;#本地仓库覆盖到工作区(不保留修改直接删除掉)提交规范明确每一次提交的内容，比如增加新功能，修改bug，维护文档，调整单元测试等，规范的Git提交历史，还可以直接生成项目发版的CHANGELOG（semantic-release）格式&lt;type&gt;(&lt;scope&gt;):&lt;subject&gt;&lt;BLANKLINE&gt;&lt;body&gt;&lt;BLANKLINE&gt;&lt;footer&gt;header是必需的，body和footer可以省略。不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。type用于说明commit的类别，只允许使用下面7个标识。feat：新功能（feature）fix：修补bugdocs：文档（documentation）style：格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动如果type为feat和fix，则该commit将肯定出现在Changelog之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入Changelog，建议是不要。scopescope用于说明commit影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。例如在Angular，可以是$location,$browser,$compile,$rootScope,ngHref,ngClick,ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。subject是commit目的的简短描述，不超过50个字符。注意以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（.）BodyBody部分是对本次commit的详细描述，可以分成多行。Moredetailedexplanatorytext,ifnecessary.Wrapittoabout72charactersorso.Furtherparagraphscomeafterblanklines.-Bulletpointsareokay,too-Useahangingindent注意使用第一人称现在时，比如使用change而不是changed或changes。永远别忘了第2行是空行应该说明代码变动的动机，以及与以前行为的对比。Footer不兼容变动如果当前代码与上一个版本不兼容，则Footer部分以BREAKINGCHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。BREAKINGCHANGE:isolatescopebindingsdefinitionhaschanged.Tomigratethecodefollowtheexamplebelow:Before:scope:{myAttr:'attribute',}After:scope:{myAttr:'@',}Theremoved`inject`wasn'tgeneralyusefulfordirectivessothereshouldbenocodeusingit.关闭Issue如果当前commit针对某个issue，那么可以在Footer部分关闭这个issue。Closes#234Revert如果当前commit用于撤销以前的commit，则必须以revert:开头，后面跟着被撤销Commit的Header。revert:feat(pencil):add'graphiteWidth'optionThisrevertscommit667ecc1654a317a13331b17617d973392f415f02.//Body部分的格式是固定的，必须写成Thisrevertscommit&lt;hash&gt;.，其中的hash是被撤销commit的SHA标识符。如果当前commit与被撤销的commit，在同一个发布（release）里面，那么它们都不会出现在Changelog里面。如果两者在不同的发布，那么当前commit，会出现在Changelog的Reverts小标题下面。","link":"https://18279493170.github.io/x9xkOwNC7/"},{"title":"MarkDown语法","content":"MarkDown基本语法标题（Heading）#a#H1##H2###H3粗体（Bold）**a****boldtext**斜体（Italic）*a**italicizedtext*引用块（Blockquote）&gt;&gt;blockquote有序列表（OrderedList）1.1.Firstitem2.Seconditem3.ThirditemFirstitemSeconditemThirditem无序列表（UnorderedList）*/-/+*Firstitem-Seconditem+ThirditemFirstitemSeconditemThirditem代码（Code）code`code`分隔线（HorizontalRule）---链接（Link）[title](https://www.example.com)百度图片（Image）![alttext](image.jpg)扩展语法表格要添加表，请使用三个或多个连字符（---）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。|Syntax|Description||-----------|-----------||Header|Title||Paragraph|Text|对齐:您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。|Syntax|Description|TestText||:---|:----:|---:||Header|Title|Here'sthis||Paragraph|Text|Andmore|代码块Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建代码块。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(```）或三个波浪号（~~~）。```{&quot;firstName&quot;:&quot;John&quot;,&quot;lastName&quot;:&quot;Smith&quot;,&quot;age&quot;:25}```语法高亮许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言。~~~json{&quot;firstName&quot;:&quot;John&quot;,&quot;lastName&quot;:&quot;Smith&quot;,&quot;age&quot;:25}~~~脚注在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（[^1]:Myfootnote.）Here'sasimplefootnote,[^1]andhere'salongerone.[^bignote][^1]:Thisisthefirstfootnote.[^bignote]:Here'sonewithmultipleparagraphsandcode.标题编号###MyGreatHeading{#custom-id}&lt;h3id=&quot;custom-id&quot;&gt;MyGreatHeading&lt;/h3&gt;列表一些Markdown处理器允许您创建术语及其对应定义的定义列表。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。FirstTerm:Thisisthedefinitionofthefirstterm.SecondTerm:Thisisonedefinitionofthesecondterm.:Thisisanotherdefinitionofthesecondterm.删除线在单词前后使用两个波浪号~~~~世界是平坦的。~~我们现在知道世界是圆的。世界是平坦的。我们现在知道世界是圆的。任务列表要创建任务列表，请在任务列表项之前添加破折号-和方括号[]，并在[]前面加上空格。要选择一个复选框，请在方括号[x]之间添加x。-[x]Writethepressrelease-[]Updatethewebsite-[]ContactthemediaWritethepressreleaseUpdatethewebsiteContactthemedia使用Emoji表情键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。表情符号简码列表去露营了！:tent:很快回来。真好笑！:joy:去露营了！⛺很快回来。真好笑！😂","link":"https://18279493170.github.io/NLSUGkv5o/"},{"title":"js之基础数据类型","content":"null,undefined和布尔值null和undefined概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。vara=undefined;//或者vara=null;上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。if(!undefined){console.log('undefinedisfalse');}//undefinedisfalseif(!null){console.log('nullisfalse');}//nullisfalseundefined==null//true从上面代码可见，两者的行为是何等相似！谷歌公司开发的JavaScript语言的替代品Dart语言，就明确规定只有null，没有undefined！既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。1995年JavaScript诞生时，最初像Java一样，只设置了null表示&quot;无&quot;。根据C语言的传统，null可以自动转为0。Number(null)//05+null//5上面代码中，null转为数字时，自动变成0。但是，JavaScript的设计者BrendanEich，觉得这样做还不够。首先，第一版的JavaScript里面，null就像在Java里一样，被当成一个对象，BrendanEich觉得表示“无”的值最好不是对象。其次，那时的JavaScript不包括错误处理机制，BrendanEich觉得，如果null自动转为0，很不容易发现错误。因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示&quot;此处无定义&quot;的原始值，转为数值时为NaN。Number(undefined)//NaN5+undefined//NaN用法和含义对于null和undefined，大致可以像下面这样理解。null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。undefined表示“未定义”，下面是返回undefined的典型场景。//变量声明了，但没有赋值vari;i//undefined//调用函数时，应该提供的参数没有提供，该参数等于undefinedfunctionf(x){returnx;}f()//undefined//对象没有赋值的属性varo=newObject();o.p//undefined//函数没有返回值时，默认返回undefinedfunctionf(){}f()//undefined布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。下列运算符会返回布尔值：前置逻辑运算符：!(Not)相等运算符：===，!==，==，!=比较运算符：&gt;，&gt;=，&lt;，&lt;=如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。undefinednullfalse0NaN&quot;&quot;或''（空字符串）布尔值往往用于程序流程的控制，请看一个例子。if(''){console.log('true');}//没有任何输出上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以JavaScript自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。if([]){console.log('true');}//trueif({}){console.log('true');}//true更多关于数据类型转换的介绍，参见《数据类型转换》一章。参考链接AxelRauschmayer,CategorizingvaluesinJavaScript数值概述整数和浮点数JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。1===1.0//true这就是说，JavaScript语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时JavaScript会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的“位运算”部分。由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。0.1+0.2===0.3//false0.3/0.1//2.9999999999999996(0.3-0.2)===(0.2-0.1)//false数值精度根据国际标准IEEE754，JavaScript浮点数的64个二进制位，从最左边开始，是这样组成的。第1位：符号位，0表示正数，1表示负数第2位到第12位（共11位）：指数部分第13位到第64位（共52位）：小数部分（即有效数字）符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE754规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript提供的有效数字最长为53个二进制位。(-1)^符号位*1.xx...xx*2^指数部分上面公式是正常情况下（指数部分在0到2047之间），一个数在JavaScript内部实际的表示形式。精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。Math.pow(2,53)//9007199254740992Math.pow(2,53)+1//9007199254740992Math.pow(2,53)+2//9007199254740994Math.pow(2,53)+3//9007199254740996Math.pow(2,53)+4//9007199254740996上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript对15位的十进制数都可以精确处理。Math.pow(2,53)//9007199254740992//多出的三个有效数字，将无法保存9007199254740992111//9007199254740992000上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则JavaScript能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即JavaScript无法表示这么大的数，这时就会返回Infinity。Math.pow(2,1024)//Infinity如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即JavaScript无法表示这么小的数，这时会直接返回0。Math.pow(2,-1075)//0下面是一个实际的例子。varx=0.5;for(vari=0;i&lt;25;i++){x=x*x;}x//0上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript就直接将其转为0。JavaScript提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。Number.MAX_VALUE//1.7976931348623157e+308Number.MIN_VALUE//5e-324数值的表示法JavaScript的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。数值也可以采用科学计数法表示，下面是几个科学计数法的例子。123e3//123000123e-3//0.123-3.1E+12.1e-23科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。以下两种情况，JavaScript会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。（1）小数点前的数字多于21位。1234567890123456789012//1.2345678901234568e+21123456789012345678901//123456789012345680000（2）小数点后的零多于5个。//小数点后紧跟5个以上的零，//就自动转为科学计数法0.0000003//3e-7//否则，就保持原来的字面形式0.000003//0.000003数值的进制使用字面量（literal）直接表示一个数值时，JavaScript对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。十进制：没有前导0的数值。八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。十六进制：有前缀0x或0X的数值。二进制：有前缀0b或0B的数值。默认情况下，JavaScript内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。0xff//2550o377//2550b11//3如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。0xzz//报错0o88//报错0b22//报错上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。0888//8880777//511前导0表示八进制，处理时很容易造成混乱。ES5的严格模式和ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。特殊数值JavaScript提供了几个特殊的数值。正零和负零前面说过，JavaScript的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。JavaScript内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。-0===+0//true0===-0//true0===+0//true几乎所有场合，正零和负零都会被当作正常的0。+0//0-0//0(-0).toString()//'0'(+0).toString()//'0'唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。(1/+0)===(1/-0)//false上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。NaN（1）含义NaN是JavaScript的特殊值，表示“非数字”（NotaNumber），主要出现在将字符串解析成数字出错的场合。5-'x'//NaN上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。另外，一些数学函数的运算结果会出现NaN。Math.acos(2)//NaNMath.log(-1)//NaNMath.sqrt(-1)//NaN0除以0也会得到NaN。0/0//NaN需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。typeofNaN//'number'（2）运算规则NaN不等于任何值，包括它本身。NaN===NaN//false数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。[NaN].indexOf(NaN)//-1NaN在布尔运算时被当作false。Boolean(NaN)//falseNaN与任何数（包括它自己）的运算，得到的都是NaN。NaN+32//NaNNaN-32//NaNNaN*32//NaNNaN/32//NaNInfinity（1）含义Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。//场景一Math.pow(2,1024)//Infinity//场景二0/0//NaN1/0//Infinity上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。Infinity===-Infinity//false1/-0//-Infinity-1/-0//Infinity上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，所以单纯的数学运算几乎没有可能抛出错误。Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。Infinity&gt;1000//true-Infinity&lt;-1000//trueInfinity与NaN比较，总是返回false。Infinity&gt;NaN//false-Infinity&gt;NaN//falseInfinity&lt;NaN//false-Infinity&lt;NaN//false（2）运算规则Infinity的四则运算，符合无穷的数学计算规则。5*Infinity//Infinity5-Infinity//-InfinityInfinity/5//Infinity5/Infinity//00乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。0*Infinity//NaN0/Infinity//0Infinity/0//InfinityInfinity加上或乘以Infinity，返回的还是Infinity。Infinity+Infinity//InfinityInfinity*Infinity//InfinityInfinity减去或除以Infinity，得到NaN。Infinity-Infinity//NaNInfinity/Infinity//NaNInfinity与null计算时，null会转成0，等同于与0的计算。null*Infinity//NaNnull/Infinity//0Infinity/null//InfinityInfinity与undefined计算，返回的都是NaN。undefined+Infinity//NaNundefined-Infinity//NaNundefined*Infinity//NaNundefined/Infinity//NaNInfinity/undefined//NaN与数值相关的全局方法parseInt()（1）基本用法parseInt方法用于将字符串转为整数。parseInt('123')//123如果字符串头部有空格，空格会被自动去除。parseInt('81')//81如果parseInt的参数不是字符串，则会先转为字符串再转换。parseInt(1.23)//1//等同于parseInt('1.23')//1字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。parseInt('8a')//8parseInt('12**')//12parseInt('12.34')//12parseInt('15e2')//15parseInt('15px')//15上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。parseInt('abc')//NaNparseInt('.3')//NaNparseInt('')//NaNparseInt('+')//NaNparseInt('+1')//1所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。parseInt('0x10')//16如果字符串以0开头，将其按照10进制解析。parseInt('011')//11对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。parseInt(1000000000000000000000.5)//1//等同于parseInt('1e+21')//1parseInt(0.0000008)//8//等同于parseInt('8e-7')//8（2）进制转换parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。parseInt('1000')//1000//等同于parseInt('1000',10)//1000下面是转换指定进制的数的例子。parseInt('1000',2)//8parseInt('1000',6)//216parseInt('1000',8)//512上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。parseInt('10',37)//NaNparseInt('10',1)//NaNparseInt('10',0)//10parseInt('10',null)//10parseInt('10',undefined)//10如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。parseInt('1546',2)//1parseInt('546',2)//NaN上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。parseInt(0x11,36)//43parseInt(0x11,2)//1//等同于parseInt(String(0x11),36)parseInt(String(0x11),2)//等同于parseInt('17',36)parseInt('17',2)上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。这种处理方式，对于八进制的前缀0，尤其需要注意。parseInt(011,2)//NaN//等同于parseInt(String(011),2)//等同于parseInt(String(9),2)上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt('011',2)，011则是会被当作二进制处理，返回3。JavaScript不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。parseFloat()parseFloat方法用于将一个字符串转为浮点数。parseFloat('3.14')//3.14如果字符串符合科学计数法，则会进行相应的转换。parseFloat('314e-2')//3.14parseFloat('0.0314E+2')//3.14如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。parseFloat('3.14morenon-digitcharacters')//3.14parseFloat方法会自动过滤字符串前导的空格。parseFloat('\\t\\v\\r12.34\\n')//12.34如果参数不是字符串，则会先转为字符串再转换。parseFloat([1.23])//1.23//等同于parseFloat(String([1.23]))//1.23如果字符串的第一个字符不能转化为浮点数，则返回NaN。parseFloat([])//NaNparseFloat('FF2')//NaNparseFloat('')//NaN上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。这些特点使得parseFloat的转换结果不同于Number函数。parseFloat(true)//NaNNumber(true)//1parseFloat(null)//NaNNumber(null)//0parseFloat('')//NaNNumber('')//0parseFloat('123.45#')//123.45Number('123.45#')//NaNisNaN()isNaN方法可以用来判断一个值是否为NaN。isNaN(NaN)//trueisNaN(123)//false但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。isNaN('Hello')//true//相当于isNaN(Number('Hello'))//true出于同样的原因，对于对象和数组，isNaN也返回true。isNaN({})//true//等同于isNaN(Number({}))//trueisNaN(['xzy'])//true//等同于isNaN(Number(['xzy']))//true但是，对于空数组和只有一个数值成员的数组，isNaN返回false。isNaN([])//falseisNaN([123])//falseisNaN(['123'])//false上面代码之所以返回false，原因是这些数组能被Number函数转成数值，请参见《数据类型转换》一章。因此，使用isNaN之前，最好判断一下数据类型。functionmyIsNaN(value){returntypeofvalue==='number'&amp;&amp;isNaN(value);}判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。functionmyIsNaN(value){returnvalue!==value;}isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。isFinite(Infinity)//falseisFinite(-Infinity)//falseisFinite(NaN)//falseisFinite(undefined)//falseisFinite(null)//trueisFinite(-1)//true除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。参考链接Dr.AxelRauschmayer,HownumbersareencodedinJavaScriptHumphry,JavaScript中Number的一些表示上/下限字符串概述定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。'abc'&quot;abc&quot;单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。'key=&quot;value&quot;'&quot;It'salongjourney&quot;上面两个都是合法的字符串。如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。'Didshesay\\'Hello\\'?'//&quot;Didshesay'Hello'?&quot;&quot;Didshesay\\&quot;Hello\\&quot;?&quot;//&quot;Didshesay&quot;Hello&quot;?&quot;由于HTML语言的属性值使用双引号，所以很多项目约定JavaScript语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。字符串默认只能写在一行内，分成多行将会报错。'abc'//SyntaxError:UnexpectedtokenILLEGAL上面代码将一个字符串分成三行，JavaScript就会报错。如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。varlongString='Long\\long\\long\\string';longString//&quot;Longlonglongstring&quot;上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。varlongString='Long'+'long'+'long'+'string';如果想输出多行字符串，有一种利用多行注释的变通方法。(function(){/*line1line2line3*/}).toString().split('\\n').slice(1,-1).join('\\n')//&quot;line1//line2//line3&quot;上面的例子中，输出的字符串就是多行。转义反斜杠（\\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。需要用反斜杠转义的特殊字符，主要有下面这些。\\0：null（\\u0000）\\b：后退键（\\u0008）\\f：换页符（\\u000C）\\n：换行符（\\u000A）\\r：回车键（\\u000D）\\t：制表符（\\u0009）\\v：垂直制表符（\\u000B）\\'：单引号（\\u0027）\\&quot;：双引号（\\u0022）\\\\：反斜杠（\\u005C）上面这些字符前面加上反斜杠，都表示特殊含义。console.log('1\\n2')//1//2上面代码中，\\n表示换行，输出的时候就分成了两行。反斜杠还有三种特殊用法。（1）\\HHH反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的Unicode码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。（2）\\xHH\\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的Unicode码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。（3）\\uXXXX\\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的Unicode码点，比如\\u00A9表示版权符号。下面是这三种字符特殊写法的例子。'\\251'//&quot;©&quot;'\\xA9'//&quot;©&quot;'\\u00A9'//&quot;©&quot;'\\172'==='z'//true'\\x7A'==='z'//true'\\u007A'==='z'//true如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。'\\a'//&quot;a&quot;上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。&quot;Prev\\\\Next&quot;//&quot;Prev\\Next&quot;字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。vars='hello';s[0]//&quot;h&quot;s[1]//&quot;e&quot;s[4]//&quot;o&quot;//直接对字符串使用方括号运算符'hello'[1]//&quot;e&quot;如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。'abc'[3]//undefined'abc'[-1]//undefined'abc'['x']//undefined但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。vars='hello';deletes[0];s//&quot;hello&quot;s[1]='a';s//&quot;hello&quot;s[5]='!';s//&quot;hello&quot;上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。length属性length属性返回字符串的长度，该属性也是无法改变的。vars='hello';s.length//5s.length=3;s.length//5s.length=7;s.length//5上面代码表示字符串的length属性无法改变，但是不会报错。字符集JavaScript使用Unicode字符集。JavaScript引擎内部，所有字符都用Unicode表示。JavaScript不仅以Unicode储存字符，还允许直接在程序中使用Unicode码点表示字符，即将字符写成\\uxxxx的形式，其中xxxx代表该字符的Unicode码点。比如，\\u00A9代表版权符号。vars='\\u00A9';s//&quot;©&quot;解析代码的时候，JavaScript会自动识别一个字符是字面形式表示，还是Unicode形式表示。输出给用户的时候，所有字符都会转成字面形式。varf\\u006F\\u006F='abc';foo//&quot;abc&quot;上面代码中，第一行的变量名foo是Unicode形式表示，第二行是字面形式表示。JavaScript会自动识别。我们还需要知道，每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。但是，UTF-16有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成UTF-16就是0xD8340xDF06。JavaScript对UTF-16的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为JavaScript第一版发布的时候，Unicode的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode纳入的字符越来越多，出现了四字节的编码。但是，JavaScript的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是JavaScript无法识别，会认为这是两个字符。'𝌆'.length//2上面代码中，JavaScript认为𝌆的长度为2，而不是1。总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript返回的字符串长度可能是不正确的。Base64转码有时，文本里面包含一些不可打印的符号，比如ASCII码0到31的符号都无法打印出来，这时可以使用Base64编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用Base64编码。所谓Base64就是一种编码方法，可以将任意值转成0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。JavaScript原生提供两个Base64相关的方法。btoa()：任意值转为Base64编码atob()：Base64编码转为原来的值varstring='HelloWorld!';btoa(string)//&quot;SGVsbG8gV29ybGQh&quot;atob('SGVsbG8gV29ybGQh')//&quot;HelloWorld!&quot;注意，这两个方法不适合非ASCII码的字符，会报错。btoa('你好')//报错要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。functionb64Encode(str){returnbtoa(encodeURIComponent(str));}functionb64Decode(str){returndecodeURIComponent(atob(str));}b64Encode('你好')//&quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE')//&quot;你好&quot;参考链接MathiasBynens,JavaScript’sinternalcharacterencoding:UCS-2orUTF-16?MathiasBynens,JavaScripthasaUnicodeproblemMozillaDeveloperNetwork,Window.btoa","link":"https://18279493170.github.io/va4kewM-i/"},{"title":"js之数据类型简介","content":"数据类型概述简介JavaScript语言的每一个值，都属于某一种数据类型。JavaScript的数据类型，共有六种。（ES6又新增了第七种Symbol类型的值，本教程不涉及。）数值（number）：整数和小数（比如1和3.14）。字符串（string）：文本（比如HelloWorld）。布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）。undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。null：表示空值，即此处的值为空。对象（object）：各种值组成的集合。通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitivetype）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complextype）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。对象是最复杂的数据类型，又可以分成三个子类型。狭义的对象（object）数组（array）函数（function）狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为JavaScript的“函数式编程”奠定了基础。typeof运算符JavaScript有三种方法，可以确定一个值到底是什么类型。typeof运算符instanceof运算符Object.prototype.toString方法instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。typeof运算符可以返回一个值的数据类型。数值、字符串、布尔值分别返回number、string、boolean。typeof123//&quot;number&quot;typeof'123'//&quot;string&quot;typeoffalse//&quot;boolean&quot;函数返回function。functionf(){}typeoff//&quot;function&quot;undefined返回undefined。typeofundefined//&quot;undefined&quot;利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。v//ReferenceError:visnotdefinedtypeofv//&quot;undefined&quot;上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。实际编程中，这个特点通常用在判断语句。//错误的写法if(v){//...}//ReferenceError:visnotdefined//正确的写法if(typeofv===&quot;undefined&quot;){//...}对象返回object。typeofwindow//&quot;object&quot;typeof{}//&quot;object&quot;typeof[]//&quot;object&quot;上面代码中，空数组（[]）的类型也是object，这表示在JavaScript内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。varo={};vara=[];oinstanceofArray//falseainstanceofArray//truenull返回object。typeofnull//&quot;object&quot;null的类型是object，这是由于历史原因造成的。1995年的JavaScript语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeofnull返回object就没法改变了。参考链接AxelRauschmayer,ImprovingtheJavaScripttypeofoperator","link":"https://18279493170.github.io/GBI29V_En/"},{"title":"js入门之基本语法","content":"JavaScript的基本语法语句JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。vara=1+3;这条语句先用var命令，声明了变量a，然后将1+3的运算结果赋值给变量a。1+3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。vara=1+3;varb='abc';分号前面可以没有任何内容，JavaScript引擎将其视为空语句。;;;上面的代码就表示3个空语句。表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。1+3;'abc';上面两行语句只是单纯地产生一个值，并没有任何实际的意义。变量概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。vara=1;上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。注意，JavaScript的变量名区分大小写，A和a是两个不同的变量。变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。vara;a=1;如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。vara;a//undefined如果变量赋值的时候，忘了写var命令，这条语句也是有效的。vara=1;//基本等同a=1;但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。如果一个变量没有声明就直接使用，JavaScript会报错，告诉你变量未定义。x//ReferenceError:xisnotdefined上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。可以在同一条var命令中声明多个变量。vara,b;JavaScript是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。vara=1;a='hello';上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。如果使用var重新声明一个已经存在的变量，是无效的。varx=1;varx;x//1上面代码中，变量x声明了两次，第二次声明是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。varx=1;varx=2;//等同于varx=1;varx;x=2;变量提升JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。console.log(a);vara=1;上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。vara;console.log(a);a=1;最后的结果是显示undefined，表示变量a已声明，但还未赋值。标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript语言的标识符对大小写敏感，所以a和A是两个不同的标识符。标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。简单说，标识符命名规则如下。第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9。下面这些都是合法的标识符。arg0_tmp$elemπ下面这些则是不合法的标识符。1a//第一个字符不能是数字23//同上***//标识符不能包含星号a+b//标识符不能包含加号-d//标识符不能包含减号或连词线中文是合法的标识符，可以用作变量名。var临时变量=1;JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。注释源码中被JavaScript引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/*和*/之间。//这是单行注释/*这是多行注释*/此外，由于历史上JavaScript可以兼容HTML代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。x=1;&lt;!--x=2;--&gt;x=3;上面代码中，只有x=1会执行，其他的部分都被注释掉了。需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。functioncountdown(n){while(n--&gt;0)console.log(n);}countdown(3)//2//1//0上面代码中，n--&gt;0实际上会当作n--&gt;0，因此输出2、1、0。区块JavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。对于var命令来说，JavaScript的区块不构成单独的作用域（scope）。{vara=1;}a//1上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在JavaScript语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。条件语句JavaScript提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。if结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是JavaScript的两个特殊值，true表示“真”，false表示“伪”。if(布尔值)语句;//或者if(布尔值)语句;上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。if(m===3)m=m+1;上面代码表示，只有在m等于3时，才会将其值加上1。这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。if(m===3){m+=1;}建议总是在if语句中使用大括号，因为这样方便插入语句。注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。varx=1;vary=2;if(x=y){console.log(x);}//&quot;2&quot;上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。if(x=2){//不报错if(2=x){//报错至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），请参考《运算符》章节。if...else结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。if(m===3){//满足条件时，执行的语句}else{//不满足条件时，执行的语句}上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。对同一个变量进行多次判断时，多个if...else语句可以连写在一起。if(m===0){//...}elseif(m===1){//...}elseif(m===2){//...}else{//...}else代码块总是与离自己最近的那个if语句配对。varm=1;varn=2;if(m!==1)if(n===2)console.log('hello');elseconsole.log('world');上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。if(m!==1){if(n===2){console.log('hello');}else{console.log('world');}}如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。if(m!==1){if(n===2){console.log('hello');}}else{console.log('world');}//worldswitch结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。switch(fruit){case&quot;banana&quot;://...break;case&quot;apple&quot;://...break;default://...}上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。varx=1;switch(x){case1:console.log('x等于1');case2:console.log('x等于2');default:console.log('x等于其他值');}//x等于1//x等于2//x等于其他值上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。switch(x){case1:console.log('x等于1');break;case2:console.log('x等于2');break;default:console.log('x等于其他值');}switch语句部分和case语句部分，都可以使用表达式。switch(1+3){case2+2:f();break;default:neverHappens();}上面代码的default部分，是永远不会执行到的。需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。varx=1;switch(x){casetrue:console.log('x发生类型转换');break;default:console.log('x没有发生类型转换');}//x没有发生类型转换上面代码中，由于变量x没有发生类型转换，所以不会执行casetrue的情况。这表明，switch语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。三元运算符?:JavaScript还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。(条件)?表达式1:表达式2上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。vareven=(n%2===0)?true:false;上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。vareven;if(n%2===0){even=true;}else{even=false;}这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。varmyVar;console.log(myVar?'myVarhasavalue':'myVardoesnothaveavalue')//myVardoesnothaveavalue上面代码利用三元运算符，输出相应的提示。varmsg='数字'+n+'是'+(n%2===0?'偶数':'奇数');上面代码利用三元运算符，在字符串之中插入不同的值。循环语句循环语句用于重复执行某个操作，它有多种形式。while循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。while(条件)语句;//或者while(条件)语句;while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。while(条件){语句;}下面是while语句的一个例子。vari=0;while(i&lt;100){console.log('i当前为：'+i);i=i+1;}上面的代码将循环100次，直到i等于100为止。下面的例子是一个无限循环，因为循环条件总是为真。while(true){console.log('Hello,world');}for循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。for(初始化表达式;条件;递增表达式)语句//或者for(初始化表达式;条件;递增表达式){语句}for语句后面的括号里面，有三个表达式。初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。下面是一个例子。varx=3;for(vari=0;i&lt;x;i++){console.log(i);}//0//1//2上面代码中，初始化表达式是vari=0，即初始化一个变量i；测试表达式是i&lt;x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。varx=3;vari=0;while(i&lt;x){console.log(i);i++;}for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。for(;;){console.log('HelloWorld');}上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。do...while循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。do语句while(条件);//或者do{语句}while(条件);不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。下面是一个例子。varx=3;vari=0;do{console.log(i);i++;}while(i&lt;x);break语句和continue语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。break语句用于跳出代码块或循环。vari=0;while(i&lt;100){console.log('i当前为：'+i);i++;if(i===10)break;}上面代码只会执行10次循环，一旦i等于10，就会跳出循环。for循环也可以使用break语句跳出循环。for(vari=0;i&lt;5;i++){console.log(i);if(i===3)break;}//0//1//2//3上面代码执行到i等于3，就会跳出循环。continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。vari=0;while(i&lt;100){i++;if(i%2===0)continue;console.log('i当前为：'+i);}上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。标签（label）JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。label:语句标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。标签通常与break语句和continue语句配合使用，跳出特定的循环。top:for(vari=0;i&lt;3;i++){for(varj=0;j&lt;3;j++){if(i===1&amp;&amp;j===1)breaktop;console.log('i='+i+',j='+j);}}//i=0,j=0//i=0,j=1//i=0,j=2//i=1,j=0上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。标签也可以用于跳出代码块。foo:{console.log(1);breakfoo;console.log('本行不会输出');}console.log(2);//1//2上面代码执行到breakfoo，就会跳出区块。continue语句也可以与标签配合使用。top:for(vari=0;i&lt;3;i++){for(varj=0;j&lt;3;j++){if(i===1&amp;&amp;j===1)continuetop;console.log('i='+i+',j='+j);}}//i=0,j=0//i=0,j=1//i=0,j=2//i=1,j=0//i=2,j=0//i=2,j=1//i=2,j=2上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。参考链接AxelRauschmayer,BasicJavaScriptfortheimpatientprogrammer","link":"https://18279493170.github.io/LsJCy29So/"},{"title":"js入门之导论与历史","content":"导论什么是JavaScript语言？JavaScript是一种轻量级的脚本语言。所谓“脚本语言”（scriptlanguage），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。JavaScript也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript本身不提供任何与I/O（输入/输出）相关的API，都要靠宿主环境（host）提供，所以JavaScript只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层API。目前，已经嵌入JavaScript的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是Node项目。从语法角度看，JavaScript语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过JavaScript控制这些功能。但是，JavaScript并不是纯粹的“面向对象语言”，还支持其他编程范式（比如函数式编程）。这导致几乎任何一个问题，JavaScript都有多种解决方法。阅读本书的过程中，你会诧异于JavaScript语法的灵活性。JavaScript的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的API（即只能在该环境使用的接口），以便JavaScript调用。以浏览器为例，它提供的额外API可以分成三大类。浏览器控制类：操作浏览器DOM类：操作网页的各种元素Web类：实现互联网的各种功能如果宿主环境是服务器，则会提供各种操作系统的API，比如文件操作API、网络通信API等等。这些你都可以在Node环境中找到。本书主要介绍JavaScript核心语法和浏览器网页开发的基本知识，不涉及Node。全书可以分成以下四大部分。基本语法标准库浏览器APIDOMJavaScript语言有多个版本。本书的内容主要基于ECMAScript5.1版本，这是学习JavaScript语法的基础。ES6和更新的语法请参考我写的《ECMAScript6入门》。为什么学习JavaScript？JavaScript语言有一些显著特点，使得它非常值得学习。它既适合作为学习编程的入门语言，也适合当作日常开发的工作语言。它是目前最有希望、前途最光明的计算机语言之一。操控浏览器的能力JavaScript的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。目前，全世界几乎所有网页都使用JavaScript。如果不用，网站的易用性和使用效率将大打折扣，无法成为操作便利、对用户友好的网站。对于一个互联网开发者来说，如果你想提供漂亮的网页、令用户满意的上网体验、各种基于浏览器的便捷功能、前后端之间紧密高效的联系，JavaScript是必不可少的工具。广泛的使用领域近年来，JavaScript的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。（1）浏览器的平台化随着HTML5的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript因此得以调用许多系统功能，比如操作本地文件、操作图片、调用摄像头和麦克风等等。这使得JavaScript可以完成许多以前无法想象的事情。（2）NodeNode项目使得JavaScript可以用于开发服务器端的大型项目，网站的前后端都用JavaScript开发已经成为了现实。有些嵌入式平台（RaspberryPi）能够安装Node，于是JavaScript就能为这些平台开发应用程序。（3）数据库操作JavaScript甚至也可以用来操作数据库。NoSQL数据库这个概念，本身就是在JSON（JavaScriptObjectNotation）格式的基础上诞生的，大部分NoSQL数据库允许JavaScript直接操作。基于SQL语言的开源数据库PostgreSQL支持JavaScript作为操作语言，可以部分取代SQL查询语言。（4）移动平台开发JavaScript也正在成为手机应用的开发语言。一般来说，安卓平台使用Java语言开发，iOS平台使用Objective-C或Swift语言开发。许多人正在努力，让JavaScript成为各个平台的通用开发语言。PhoneGap项目就是将JavaScript和HTML5打包在一个容器之中，使得它能同时在iOS和安卓上运行。Facebook公司的ReactNative项目则是将JavaScript写的组件，编译成原生组件，从而使它们具备优秀的性能。Mozilla基金会的手机操作系统FirefoxOS，更是直接将JavaScript作为操作系统的平台语言，但是很可惜这个项目没有成功。（5）内嵌脚本语言越来越多的应用程序，将JavaScript作为内嵌的脚本语言，比如Adobe公司的著名PDF阅读器Acrobat、Linux桌面环境GNOME3。（6）跨平台的桌面应用程序ChromiumOS、Windows8等操作系统直接支持JavaScript编写应用程序。Mozilla的OpenWebApps项目、Google的ChromeApp项目、GitHub的Electron项目、以及TideSDK项目，都可以用来编写运行于Windows、MacOS和Android等多个桌面平台的程序，不依赖浏览器。（7）小结可以预期，JavaScript最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序。早在2013年9月的统计之中，JavaScript就是当年GitHub上使用量排名第一的语言。著名程序员JeffAtwood甚至提出了一条“Atwood定律”：“所有可以用JavaScript编写的程序，最终都会出现JavaScript的版本。”(AnyapplicationthatcanbewritteninJavaScriptwilleventuallybewritteninJavaScript.)易学性相比学习其他语言，学习JavaScript有一些有利条件。（1）学习环境无处不在只要有浏览器，就能运行JavaScript程序；只要有文本编辑器，就能编写JavaScript程序。这意味着，几乎所有电脑都原生提供JavaScript学习环境，不用另行安装复杂的IDE（集成开发环境）和编译器。（2）简单性相比其他脚本语言（比如Python或Ruby），JavaScript的语法相对简单一些，本身的语法特性并不是特别多。而且，那些语法中的复杂部分，也不是必需要学会。你完全可以只用简单命令，完成大部分的操作。（3）与主流语言的相似性JavaScript的语法很类似C/C++和Java，如果学过这些语言（事实上大多数学校都教），JavaScript的入门会非常容易。必须说明的是，虽然核心语法不难，但是JavaScript的复杂性体现在另外两个方面。首先，它涉及大量的外部API。JavaScript要发挥作用，必须与其他组件配合，这些外部组件五花八门，数量极其庞大，几乎涉及网络应用的各个方面，掌握它们绝非易事。其次，JavaScript语言有一些设计缺陷。某些地方相当不合理，另一些地方则会出现怪异的运行结果。学习JavaScript，很大一部分时间是用来搞清楚哪些地方有陷阱。DouglasCrockford写过一本有名的书，名字就叫《JavaScript:TheGoodParts》，言下之意就是这门语言不好的地方很多，必须写一本书才能讲清楚。另外一些程序员则感到，为了更合理地编写JavaScript程序，就不能用JavaScript来写，而必须发明新的语言，比如CoffeeScript、TypeScript、Dart这些新语言的发明目的，多多少少都有这个因素。尽管如此，目前看来，JavaScript的地位还是无法动摇。加之，语言标准的快速进化，使得JavaScript功能日益增强，而语法缺陷和怪异之处得到了弥补。所以，JavaScript还是值得学习，况且它的入门真的不难。强大的性能JavaScript的性能优势体现在以下方面。（1）灵活的语法，表达力强。JavaScript既支持类似C语言清晰的过程式编程，也支持灵活的函数式编程，可以用来写并发处理（concurrent）。这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用异步编程。JavaScript的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义。JavaScript的标准还在快速进化中，并不断合理化，添加更适用的语法特性。（2）支持编译运行。JavaScript语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript引擎正在快速发展，性能将越来越好。此外，还有一种WebAssembly格式，它是JavaScript引擎的中间码格式，全部都是二进制代码。由于跳过了编译步骤，可以达到接近原生二进制代码的运行速度。各种语言（主要是C和C++）通过编译成WebAssembly，就可以在浏览器里面运行。（3）事件驱动和非阻塞式设计。JavaScript程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。开放性JavaScript是一种开放的语言。它的标准ECMA-262是ISO国际标准，写得非常详尽明确；该标准的主要实现（比如V8和SpiderMonkey引擎）都是开放的，而且质量很高。这保证了这门语言不属于任何公司或个人，不存在版权和专利的问题。语言标准由TC39委员会负责制定，该委员会的运作是透明的，所有讨论都是开放的，会议记录都会对外公布。不同公司的JavaScript运行环境，兼容性很好，程序不做调整或只做很小的调整，就能在所有浏览器上运行。社区支持和就业机会全世界程序员都在使用JavaScript，它有着极大的社区、广泛的文献和图书、丰富的代码资源。绝大部分你需要用到的功能，都有多个开源函数库可供选用。作为项目负责人，你不难招聘到数量众多的JavaScript程序员；作为开发者，你也不难找到一份JavaScript的工作。实验环境本教程包含大量的示例代码，只要电脑安装了浏览器，就可以用来实验了。读者可以一边读一边运行示例，加深理解。推荐安装Chrome浏览器，它的“开发者工具”（DeveloperTools）里面的“控制台”（console），就是运行JavaScript代码的理想环境。进入Chrome浏览器的“控制台”，有两种方法。直接进入：按下Option+Command+J（Mac）或者Ctrl+Shift+J（Windows/Linux）开发者工具进入：开发者工具的快捷键是F12，或者Option+Command+I（Mac）以及Ctrl+Shift+I（Windows/Linux），然后选择Console面板进入控制台以后，就可以在提示符后输入代码，然后按Enter键，代码就会执行。如果按Shift+Enter键，就是代码换行，不会触发执行。建议阅读本教程时，将代码复制到控制台进行实验。作为尝试，你可以将下面的程序复制到“控制台”，按下回车后，就可以看到运行结果。functiongreetMe(yourName){console.log('Hello'+yourName);}greetMe('World')//HelloWorldJavaScript语言的历史诞生JavaScript因为互联网而生，紧跟着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。1990年底，欧洲核能研究组织（CERN）科学家TimBerners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（WorldWideWeb），从此可以在网上浏览网页文件。最早的网页只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页都是在字符窗口中显示，这当然非常不方便。1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。1994年10月，NCSA的一个主要程序员MarcAndreessen联合风险投资家JimClark，成立了Mosaic通信公司（MosaicCommunications），不久后改名为Netscape。这家公司的方向，就是在Mosaic的基础上，开发面向普通用户的新一代的浏览器NetscapeNavigator。1994年12月，Navigator发布了1.0版，市场份额一举超过90%。Netscape公司很快发现，Navigator浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。那一年，正逢Sun公司的Java语言问世，市场推广活动非常成功。Netscape公司决定与Sun公司合作，浏览器支持嵌入Java小程序（后来称为Javaapplet）。但是，浏览器脚本语言是否就选用Java，则存在争论。后来，还是决定不使用Java，因为网页小程序不需要Java这么“重”的语法。但是，同时也决定脚本语言的语法要接近Java，并且可以支持Java程序。这些设想直接排除了使用现存语言，比如Perl、Python和TCL。1995年，Netscape公司雇佣了程序员BrendanEich开发这种网页脚本语言。BrendanEich有很强的函数式编程背景，希望以Scheme语言（函数式语言鼻祖LISP语言的一种方言）为蓝本，实现这种新语言。1995年5月，BrendanEich只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。基本语法：借鉴C语言和Java语言。数据结构：借鉴Java语言，包括将值分成原始值和对象两大类。函数的用法：借鉴Scheme语言和Awk语言，将函数当作第一等公民，并引入闭包。原型继承模型：借鉴Self语言（Smalltalk的一种变种）。正则表达式：借鉴Perl语言。字符串和数组处理：借鉴Python语言。为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来JavaScript的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript的编程风格是函数式编程和面向对象编程的一种混合体。Netscape公司的这种浏览器脚本语言，最初名字叫做Mocha，1995年9月改为LiveScript。12月，Netscape公司与Sun公司（Java语言的发明者和所有者）达成协议，后者允许将这种语言叫做JavaScript。这样一来，Netscape公司可以借助Java语言的声势，而Sun公司则将自己的影响力扩展到了浏览器。之所以起这个名字，并不是因为JavaScript本身与Java语言有多么深的关系（事实上，两者关系并不深，详见下节），而是因为Netscape公司已经决定，使用Java语言开发网络应用程序，JavaScript可以像胶水一样，将各个部分连接起来。当然，后来的历史是Java语言的浏览器插件失败了，JavaScript反而发扬光大。1995年12月4日，Netscape公司与Sun公司联合发布了JavaScript语言，对外宣传JavaScript是Java的补充，属于轻量级的Java，专门用来操作网页。1996年3月，Navigator2.0浏览器正式内置了JavaScript脚本语言。JavaScript与Java的关系这里专门说一下JavaScript和Java的关系。它们是两种不一样的语言，但是彼此存在联系。JavaScript的基本语法和对象体系，是模仿Java而设计的。但是，JavaScript没有采用Java的静态类型。正是因为JavaScript与Java有很大的相似性，所以这门语言才从一开始的LiveScript改名为JavaScript。基本上，JavaScript这个名字的原意是“很像Java的脚本语言”。JavaScript语言的函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与Java语法最大的两点区别。JavaScript语法要比Java自由得多。另外，Java语言需要编译，而JavaScript语言则是运行时由解释器直接执行。总之，JavaScript的原始设计目标是一种小型的、简单的动态语言，与Java有足够的相似性，使得使用者（尤其是Java程序员）可以快速上手。JavaScript与ECMAScript的关系1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape的注册商标，微软不能用），首先内置于IE3.0。Netscape公司面临丧失浏览器脚本语言的主导权的局面。1996年11月，Netscape公司决定将JavaScript提交给国际标准化组织ECMA（EuropeanComputerManufacturersAssociation），希望JavaScript能够成为国际标准，以此抵抗微软。ECMA的39号技术委员会（TechnicalCommittee39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript1.0版。之所以不叫JavaScript，一方面是由于商标的关系，Java是Sun公司的商标，根据一份授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript已经被Netscape公司注册为商标，另一方面也是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。ECMAScript只用来标准化JavaScript这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如DOM的标准就是由W3C组织（WorldWideWebConsortium）制定的。ECMA-262标准后来也被另一个国际标准化组织ISO（InternationalOrganizationforStandardization）批准，标准号是ISO-16262。JavaScript的版本1997年7月，ECMAScript1.0发布。1998年6月，ECMAScript2.0版发布。1999年12月，ECMAScript3.0版发布，成为JavaScript的通行标准，得到了广泛支持。2007年10月，ECMAScript4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者BrendanEich为首的Mozilla公司，则坚持当前的草案。2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript4.0的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为ECMAScript3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript3.1就改名为ECMAScript5。2009年12月，ECMAScript5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39的总体考虑是，ECMAScript5与ECMAScript3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。当时，JavaScript.next指的是ECMAScript6。第六版发布以后，将指ECMAScript7。TC39预计，ECMAScript5会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。2011年6月，ECMAScript5.1版发布，并且成为ISO国际标准（ISO/IEC16262:2011）。到了2012年底，所有主要浏览器都支持ECMAScript5.1版的全部功能。2013年3月，ECMAScript6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript7。2013年12月，ECMAScript6草案发布。然后是12个月的讨论期，听取各方反馈。2015年6月，ECMAScript6正式发布，并且更名为“ECMAScript2015”。这是因为TC39委员会计划，以后每年发布一个ECMAScript的版本，下一个版本在2016年发布，称为“ECMAScript2016”，2017年发布“ECMAScript2017”，以此类推。周边大事记JavaScript伴随着互联网的发展一起发展。互联网周边技术的快速发展，刺激和推动了JavaScript语言的发展。下面，回顾一下JavaScript的周边应用发展。1996年，样式表标准CSS第一版发布。1997年，DHTML（DynamicHTML，动态HTML）发布，允许动态改变网页内容。这标志着DOM模式（DocumentObjectModel，文档对象模型）正式应用。1998年，Netscape公司开源了浏览器，这导致了Mozilla项目的诞生。几个月后，美国在线（AOL）宣布并购Netscape。1999年，IE5部署了XMLHttpRequest接口，允许JavaScript发出HTTP请求，为后来大行其道的Ajax应用创造了条件。2000年，KDE项目重写了浏览器引擎KHTML，为后来的WebKit和Blink引擎打下基础。这一年的10月23日，KDE2.0发布，第一次将KHTML浏览器包括其中。2001年，微软公司时隔5年之后，发布了IE浏览器的下一个版本InternetExplorer6。这是当时最先进的浏览器，它后来统治了浏览器市场多年。2001年，DouglasCrockford提出了JSON格式，用于取代XML格式，进行服务器和网页之间的数据交换。JavaScript可以原生支持这种格式，不需要额外部署代码。2002年，Mozilla项目发布了它的浏览器的第一版，后来起名为Firefox。2003年，苹果公司发布了Safari浏览器的第一版。2004年，Google公司发布了Gmail，促成了互联网应用程序（WebApplication）这个概念的诞生。由于Gmail是在4月1日发布的，很多人起初以为这只是一个玩笑。2004年，Dojo框架诞生，为不同浏览器提供了同一接口，并为主要功能提供了便利的调用方法。这标志着JavaScript编程框架的时代开始来临。2004年，WHATWG组织成立，致力于加速HTML语言的标准化进程。2005年，苹果公司在KHTML引擎基础上，建立了WebKit引擎。2005年，Ajax方法（AsynchronousJavaScriptandXML）正式诞生，JesseJamesGarrett发明了这个词汇。它开始流行的标志是，2月份发布的GoogleMaps项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了Web2.0时代的来临。2005年，Apache基金会发布了CouchDB数据库。这是一个基于JSON格式的数据库，可以用JavaScript函数定义视图和索引。它在本质上有别于传统的关系型数据库，标识着NoSQL类型的数据库诞生。2006年，jQuery函数库诞生，作者为JohnResig。jQuery为操作网页DOM结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让JavaScript语言的应用难度大大降低，推动了这种语言的流行。2006年，微软公司发布IE7，标志重新开始启动浏览器的开发。2006年，Google推出GoogleWebToolkit项目（缩写为GWT），提供Java编译成JavaScript的功能，开创了将其他语言转为JavaScript的先河。2007年，Webkit引擎在iPhone手机中得到部署。它最初基于KDE项目，2003年苹果公司首先采用，2005年开源。这标志着JavaScript语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。2007年，DouglasCrockford发表了名为《JavaScript:Thegoodparts》的演讲，次年由O'Reilly出版社出版。这标志着软件行业开始严肃对待JavaScript语言，对它的语法开始重新认识。2008年，V8编译器诞生。这是Google公司为Chrome浏览器而开发的，它的特点是让JavaScript的运行变得非常快。它提高了JavaScript的性能，推动了语法的改进和标准化，改变外界对JavaScript的不佳印象。同时，V8是开源的，任何人想要一种快速的嵌入式脚本语言，都可以采用V8，这拓展了JavaScript的应用领域。2009年，Node.js项目诞生，创始人为RyanDahl，它标志着JavaScript可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。2009年，JeremyAshkenas发布了CoffeeScript的最初版本。CoffeeScript可以被转换为JavaScript运行，但是语法要比JavaScript简洁。这开启了其他语言转为JavaScript的风潮。2009年，PhoneGap项目诞生，它将HTML5和JavaScript引入移动设备的应用程序开发，主要针对iOS和Android平台，使得JavaScript可以用于跨平台的应用程序开发。2009，Google发布ChromeOS，号称是以浏览器为基础发展成的操作系统，允许直接使用JavaScript编写应用程序。类似的项目还有Mozilla的FirefoxOS。2010年，三个重要的项目诞生，分别是NPM、BackboneJS和RequireJS，标志着JavaScript进入模块化开发的时代。2011年，微软公司发布Windows8操作系统，将JavaScript作为应用程序的开发语言之一，直接提供系统支持。2011年，Google发布了Dart语言，目的是为了结束JavaScript语言在浏览器中的垄断，提供更合理、更强大的语法和功能。Chromium浏览器有内置的Dart虚拟机，可以运行Dart程序，但Dart程序也可以被编译成JavaScript程序运行。2011年，微软工程师ScottHanselman提出，JavaScript将是互联网的汇编语言。因为它无所不在，而且正在变得越来越快。其他语言的程序可以被转成JavaScript语言，然后在浏览器中运行。2012年，单页面应用程序框架（single-pageappframework）开始崛起，AngularJS项目和Ember项目都发布了1.0版本。2012年，微软发布TypeScript语言。该语言被设计成JavaScript的超集，这意味着所有JavaScript程序，都可以不经修改地在TypeScript中运行。同时，TypeScript添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成JavaScript运行。2012年，Mozilla基金会提出asm.js规格。asm.js是JavaScript的一个子集，所有符合asm.js的程序都可以在浏览器中运行，它的特殊之处在于语法有严格限定，可以被快速编译成性能良好的机器码。这样做的目的，是为了给其他语言提供一个编译规范，使其可以被编译成高效的JavaScript代码。同时，Mozilla基金会还发起了Emscripten项目，目标就是提供一个跨语言的编译器，能够将LLVM的位代码（bitcode）转为JavaScript代码，在浏览器中运行。因为大部分LLVM位代码都是从C/C++语言生成的，这意味着C/C++将可以在浏览器中运行。此外，Mozilla旗下还有LLJS（将JavaScript转为C代码）项目和RiverTrail（一个用于多核心处理器的ECMAScript扩展）项目。目前，可以被编译成JavaScript的语言列表，共有将近40种语言。2013年，Mozilla基金会发布手机操作系统FirefoxOS，该操作系统的整个用户界面都使用JavaScript。2013年，ECMA正式推出JSON的国际标准，这意味着JSON格式已经变得与XML格式一样重要和正式了。2013年5月，Facebook发布UI框架库React，引入了新的JSX语法，使得UI层可以用组件开发，同时引入了网页应用是状态机的概念。2014年，微软推出JavaScript的Windows库WinJS，标志微软公司全面支持JavaScript与Windows操作系统的融合。2014年11月，由于对Joyent公司垄断Node项目、以及该项目进展缓慢的不满，一部分核心开发者离开了Node.js，创造了io.js项目，这是一个更开放、更新更频繁的Node.js版本，很短时间内就发布到了2.0版。三个月后，Joyent公司宣布放弃对Node项目的控制，将其转交给新成立的开放性质的Node基金会。随后，io.js项目宣布回归Node，两个版本将合并。2015年3月，Facebook公司发布了ReactNative项目，将React框架移植到了手机端，可以用来开发手机App。它会将JavaScript代码转为iOS平台的Objective-C代码，或者Android平台的Java代码，从而为JavaScript语言开发高性能的原生App打开了一条道路。2015年4月，Angular框架宣布，2.0版将基于微软公司的TypeScript语言开发，这等于为JavaScript语言引入了强类型。2015年5月，Node模块管理器NPM超越CPAN，标志着JavaScript成为世界上软件模块最多的语言。2015年5月，Google公司的Polymer框架发布1.0版。该项目的目标是生产环境可以使用WebComponent组件，如果能够达到目标，Web开发将进入一个全新的以组件为开发基础的阶段。2015年6月，ECMA标准化组织正式批准了ECMAScript6语言标准，定名为《ECMAScript2015标准》。JavaScript语言正式进入了下一个阶段，成为一种企业级的、开发大规模应用的语言。这个标准从提出到批准，历时10年，而JavaScript语言从诞生至今也已经20年了。2015年6月，Mozilla在asm.js的基础上发布WebAssembly项目。这是一种JavaScript引擎的中间码格式，全部都是二进制，类似于Java的字节码，有利于移动设备加载JavaScript脚本，执行速度提高了20+倍。这意味着将来的软件，会发布JavaScript二进制包。2016年6月，《ECMAScript2016标准》发布。与前一年发布的版本相比，它只增加了两个较小的特性。2017年6月，《ECMAScript2017标准》发布，正式引入了async函数，使得异步操作的写法出现了根本的变化。2017年11月，所有主流浏览器全部支持WebAssembly，这意味着任何语言都可以编译成JavaScript，在浏览器运行。参考链接AxelRauschmayer,ThePast,Present,andFutureofJavaScriptJohnDalziel,Theraceforspeedpart4:ThefutureforJavaScriptAxelRauschmayer,BasicJavaScriptfortheimpatientprogrammerbalena.io,Happy18thBirthdayJavaScript!Alookatanunlikelypastandbrightfuture","link":"https://18279493170.github.io/KH_e8ZPsG/"},{"title":"css之调整元素,滤镜与盒子模型","content":"resize（调整元素大小）该属性允许用户通过拖动的方式来自由缩放元素的尺寸resize:none|both|horizontal|vertical;none：用户无法调整元素的尺寸；both：用户可调整元素的高度和宽度；horizontal：用户可调整元素的宽度；vertical：用户可调整元素的高度。单独设置resize属性是无效的，resize属性需要与overflow属性结合使用才有效，并且overflow属性的值需要设置为auto、hidden或scroll；并不是所有的元素都可以设置resize属性，比如img和table属性就没办法使用resize属性。&lt;style&gt;div{border:1pxsolid;width:300px;resize:both;overflow:auto;}&lt;/style&gt;filter（滤镜）通过CSS中的滤镜可以实现模糊效果、透明效果、色彩反差调整、色彩反相等等，还能对网页中的元素或者视频进行处理。CSS中实现滤镜效果需要通过filter属性并配合一些函数来实现：none默认值，表示没有效果blur(px)为图像设置高斯模糊，默认值为0，单位为像素，值较大越模糊brightness(%)调整图像的亮度，默认值为100％，代表原始图像；0％表示没有亮度，图像将完全变黑；当值超过100％时图像将变得更亮contrast(%)调整图像的对比度，默认值为100％，代表原始图像；0％将使图像完全变黑；当值超过100％时图像将获得更高的对比度drop-shadow(h-shadowv-shadowblurspreadcolor)为图像添加阴影效果，参数说明如下：h-shadow：必填值，指定水平方向阴影的像素值，若值为负，则阴影会出现在图像的左侧；v-shadow：必填值，指定垂直方向阴影的像素值，若值为负，则阴影会出现在图像的上方；blur：可选值，为阴影添加模糊效果，默认值为0，单位为像素，值越大创建的模糊就越多（阴影会变得更大更亮），不允许使用负值；spread：可选值，默认值为0，单位为像素。若值为正，则阴影将会扩展并增大；若值为负，则阴影会缩小；color：可选值，为阴影添加颜色，如未指定，则由浏览器来绝对，通常为黑色。注意：Chrome、Safari和Opera等浏览器不支持第4个参数，如果添加，则不会有任何效果grayscale(%)将图像转换为灰度图像，默认值为0%，表示原始图像；100％表示将图像完全变成灰度图像（即黑白图像），不允许为负值hue-rotate(deg)给图像应用色相旋转，该值用来定义色环的度数，默认值为0deg，代表原始图像，最大值为360deginvert(%)反转图像，默认值为0%，表示原始图像；100%则表示完全反转，不允许使用负值opacity(%)设置图像的不透明度，默认值为100%，表示原始图像；0%表示完全透明，不允许使用负值saturate(%)设置图像的饱和度，默认值为100%，表示原始图像；0%表示图像完全不饱和，不允许使用负值sepia(%)将图像转换为棕褐色，默认值为0%，表示原始图像；100%表示图像完全变成棕褐色，不允许使用负值url()url()函数用来指定一个XML文件，文件中设置了一个SVG滤镜，并且可以包含一个锚点来指定具体的滤镜元素initial将属性设置为其默认值inherit从父元素继承此属性的值提示：这些CSS函数的参数值基本上都在0~1（0%~100%）之间，但也有几个例外，比如blur()函数的参数值以像素为单位，而hue-rotate()函数的参数值则是以“deg”为单位。&lt;style&gt;div{width:200px;height:200px;float:left;position:relative;}divspan{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;text-shadow:1px1px2pxblack;}img{width:100%;}divimg.blur{filter:blur(4px);}divimg.brightness{filter:brightness(250%);}divimg.contrast{filter:contrast(180%);}divimg.grayscale{filter:grayscale(100%);}divimg.huerotate{filter:hue-rotate(180deg);}divimg.invert{filter:invert(100%);}divimg.opacity{filter:opacity(50%);}divimg.saturate{filter:saturate(7);}divimg.sepia{filter:sepia(100%);}divimg.shadow{filter:drop-shadow(8px8px10pxgreen);}&lt;/style&gt;为同一个元素使用多个滤镜效果，只需要将每个滤镜函数使用空格分隔&lt;style&gt;div{width:300px;height:300px;position:relative;}divspan{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;text-shadow:1px1px2pxblack;}img{width:100%;filter:sepia(90%)saturate(400%)brightness(150%);}&lt;/style&gt;注意：在组合使用多个滤镜效果时，要特别注意使用的顺序，否则会产生意料之外的效果，例如在使用grayscale()之后再使用sepia()将产生一个完整的灰度图片。不仅仅是图像，任何HTML元素都可以使用滤镜效果，例如文本、视频等都可以使用滤镜来美化&lt;style&gt;div{filter:blur(2px)contrast(50%)brightness(80%);}&lt;/style&gt;提示：IE浏览器不支持filter属性box-sizing：改变盒子模型默认情况下，网页中元素的实际宽度或高度取决于元素内容区的宽度或高度、内边距以及边框属性的大小，因此我们在为元素布局时还需要考虑元素的内边距和边框属性所占的页面空间正是由于上述原因，当您为页面元素设置宽度和高度时，元素的实际大小往往比您设置的要大。为此CSS3中添加了box-sizing属性来改变默认的盒子模型，通过box-sizing属性可以将元素的内边距和外边距在元素内容区内绘制，以使元素呈现的宽度和高度与设置的宽度和高度相同。box-sizing属性的可选值:content-box默认值，元素的实际宽度或高度等于元素内容区的宽度或高度、内边距和边框的和border-box在元素的内容区内绘制内边距或边框，内边距或边框不会影响元素的实际宽度或高度inherit从父元素继承box-sizing属性的值。&lt;style&gt;div{width:300px;height:50px;margin-top:5px;border:10pxsolidred;padding:5px;}.two{box-sizing:content-box;}.three{box-sizing:border-box;}&lt;/style&gt;提示：当为元素定义box-sizing:border-box;属性时，元素内容区的实际宽度和高度是width和height属性中减去各边的边框和内边距的宽度。","link":"https://18279493170.github.io/bSfRvRqxv/"},{"title":"css之多列布局，弹性布局与响应式布局","content":"column（多列布局）当需要在页面中展示大量文本时，如果每段的文本都很长，阅读起来就会非常麻烦，有可能读错行或读串行。为了提高阅读的舒适性，CSS3中引入了多列布局模块，用于以简单有效的方式创建多列布局。所谓多列布局指的就是您可以将文本内容分成多块，然后让这些块并列显示，类似于报纸、杂志那样的排版形式CSS3中提供了一系列实现多列布局的属性属性说明column-count指定元素应该分为几列column-fill指定如何填充每个列column-gap指定列与列之间的间隙column-rule所有column-rule-*属性的简写形式column-rule-color指定列与列之间边框的颜色column-rule-style指定列与列之间边框的样式column-rule-width指定列与列之间边框的宽度column-span指定元素应该横跨多少列column-width指定列的宽度columnscolumn-width与column-count属性的简写属性column-countcolumn-count属性用来设置将元素分为几列number使用具体数值将元素划分为指定的列数auto默认值，由其他属性决定具体的列数，比如column-widthcolumn-count:4;column-fillcolumn-fill属性用来设置如何填充每个列balance默认值，根据其他列属性值使列的高度尽可能平衡auto按顺序对每个列进行填充，列的高度会各有不同column-gapcolumn-gap属性用来设置列与列之间的间隙length将列与列之间的间隔设置为指定的宽度normal将列与列之间的间隔设置为与font-size属性相同的大小，即1emdiv{column-count:3;column-gap:10px;}column-rulecolumn-rule属性是一个简写属性，它与border属性非常相似，用来设置列与列之间边框的宽度、样式和颜色。column-rule属性的语法格式如下：column-rule:column-rule-widthcolumn-rule-stylecolumn-rule-color;其中column-rule-width表示边框的宽度；column-rule-style表示边框的样式，下表中列举了一些样式的可选值；column-rule-color表示边框的颜色。值描述none不定义边框样式hidden隐藏边框样式dotted定义点状边框dashed定义虚线边框solid定义实线边框double定义双实线边框groove定义3Dgrooved边框，边框效果取决于宽度和颜色值ridge定义3Dridged边框，边框效果取决于宽度和颜色值inset定义3Dinset边框，边框效果取决于宽度和颜色值outset定义3Doutset边框，边框效果取决于宽度和颜色值div{column-count:3;column-gap:10px;column-rule:5pxsolid#090;}也可以直接使用column-rule-width、column-rule-style、column-rule-color三个属性来分别设置列与列之间边框的样式div{column-count:3;column-gap:10px;column-rule-width:5px;column-rule-style:solid;column-rule-color:#090;}column-spancolumn-span属性用来设置元素应该跨越多少列none默认值，表示元素不跨越列all表示元素横跨所有列olumn-span:none;column-widthcolumn-width属性用来设置每个列的宽度auto由浏览器决定列的宽度length为每个列指定具体的宽度div{column-gap:10px;column-rule:5pxsolid#090;column-width:200px;}columnscolumns属性是一个简写属性，用来同时设置列的宽度和列的数量，语法格式如下：columns:column-widthcolumn-count;其中column-width表示每个列的宽度，column-count则表示列的数量。div{columns:100px4;column-rule:5pxsolid#090;}flex布局（弹性布局/弹性盒子）Flex是FlexibleBox的缩写，意为“弹性布局”或者“弹性盒子”，是CSS3中的一种新的布局模式，可以简便、完整、响应式地实现各种页面布局，当页面需要适应不同的屏幕大小以及设备类型时非常适用。目前，几乎所有的浏览器都支持Flex布局。基本概念采用Flex布局的元素，称为Flex容器（flexcontainer），简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目（flexitem），简称“项目”。容器默认存在两根轴，分别为水平的主轴（mainaxis）和垂直的交叉轴（crossaxis）。主轴的开始位置叫做mainstart，结束位置叫做mainend；交叉轴的开始位置叫做crossstart，结束位置叫做crossend。项目默认沿主轴排列。单个项目占据的主轴空间叫做mainsize，占据的交叉轴空间叫做crosssize。如下图所示：提示：您可以通过将元素的display属性设置为flex（生成块级flex容器）或inline-flex（生成类似inline-block的行内块级flex容器）。当一个元素设置了Flex布局以后，其子元素的float、clear和vertical-align等属性将失效。CSS中提供了以下属性来实现Flex布局：属性描述display指定HTML元素的盒子类型flex-direction指定弹性盒子中子元素的排列方式flex-wrap设置当弹性盒子的子元素超出父容器时是否换行flex-flowflex-direction和flex-wrap两个属性的简写justify-content设置弹性盒子中元素在主轴（横轴）方向上的对齐方式align-items设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式align-content修改flex-wrap属性的行为，类似align-items，但不是设置子元素对齐，而是设置行对齐order设置弹性盒子中子元素的排列顺序align-self在弹性盒子的子元素上使用，用来覆盖容器的align-items属性flex设置弹性盒子中子元素如何分配空间flex-grow设置弹性盒子的扩展比率flex-shrink设置弹性盒子的收缩比率flex-basis设置弹性盒子伸缩基准值按照作用范围的不同，这些属性可以分为两类，分别为容器属性（flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content）和项目属性（order、align-self、flex、flex-grow、flex-shrink、flex-basis）容器属性flex-directionflex-direction属性用来决定主轴的方向（即项目的排列方向）值描述row默认值，主轴沿水平方向从左到右row-reverse主轴沿水平方向从右到左column主轴沿垂直方向从上到下column-reverse主轴沿垂直方向从下到上initial将此属性设置为属性的默认值inherit从父元素继承此属性的值display:flex;flex-direction:row;flex-wrapflex-wrap属性用来设置当弹性盒子的子元素（项目）超出父容器时是否换行，属性的可选值如下：值描述nowrap默认值，表示项目不会换行wrap表示项目会在需要时换行wrap-reverse表示项目会在需要时换行，但会以相反的顺序initial将此属性设置为属性的默认值inherit从父元素继承属性的值display:flex;flex-direction:row;flex-wrap:nowrap;flex-flowflex-flow属性是flex-direction和flex-wrap两个属性的简写，语法格式如下：flex-flow:flex-directionflex-wrap;.flex_flow{display:flex;flex-flow:row-reversewrap;}justify-contentjustify-content属性用于设置弹性盒子中元素在主轴（横轴）方向上的对齐方式，属性的可选值如下：值描述flex-start默认值，左对齐flex-end右对齐center居中space-between两端对齐，项目之间的间隔是相等的space-around每个项目两侧的间隔相等initial将此属性设置为属性的默认值inherit从父元素继承属性的值.flex{display:flex;flex-flow:rowwrap;margin-top:10px;}.flexdiv{width:60px;height:60px;margin-bottom:5px;border:1pxsolidblack;}.flex-start{justify-content:flex-start;}.flex-end{justify-content:flex-end;}.center{justify-content:center;}.space-between{justify-content:space-between;}.space-around{justify-content:space-around;}align-itemsalign-items属性用来设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式，属性的可选值如下：值描述stretch默认值，项目将被拉伸以适合容器center项目位于容器的中央flex-start项目位于容器的顶部flex-end项目位于容器的底部baseline项目与容器的基线对齐initial将此属性设置为属性的默认值inherit从父元素继承属性的值align-contentalign-content属性与justify-content属性类似，可以在弹性盒子的侧轴还有多余空间时调整容器内项目的对齐方式，属性的可选值如下：值描述stretch默认值，将项目拉伸以占据剩余空间center项目在容器内居中排布flex-start项目在容器的顶部排列flex-end项目在容器的底部排列space-between多行项目均匀分布在容器中，其中第一行分布在容器的顶部，最后一行分布在容器的底部space-around多行项目均匀分布在容器中，并且每行的间距（包括离容器边缘的间距）都相等initial将此属性设置为属性的默认值inherit从父元素继承该属性的值项目属性orderorder属性用来设置项目在容器中出现的顺序，您可以通过具体的数值来定义项目在容器中的位置，属性的语法格式如下：order:number;其中number就是项目在容器中的位置，默认值为0。.flex{display:flex;flex-flow:rowwrap;margin-top:10px;}.flexdiv{width:60px;height:60px;margin-bottom:5px;border:1pxsolidblack;}.flexdiv:nth-child(1){order:5;}.flexdiv:nth-child(2){order:3;}.flexdiv:nth-child(3){order:1;}.flexdiv:nth-child(4){order:2;}.flexdiv:nth-child(5){order:4;}align-selfalign-self属性允许您为某个项目设置不同于其它项目的对齐方式，该属性可以覆盖align-items属性的值。align-self属性的可选值如下：值描述auto默认值，表示元素将继承其父容器的align-items属性值，如果没有父容器，则为“stretch”stretch项目将被拉伸以适合容器center项目位于容器的中央flex-start项目位于容器的顶部flex-end项目位于容器的底部baseline项目与容器的基线对齐initial将此属性设置为属性的默认值inherit从父元素继承属性的值.flex{display:flex;flex-flow:rowwrap;align-items:flex-end;border:1pxsolid#CCC;height:150px;}.flexdiv{width:60px;height:60px;border:1pxsolidblack;}.flexdiv:nth-child(4){align-self:flex-start;}flexflex属性是flex-grow、flex-shrink和flex-basis三个属性的简写，语法格式如下：flex:flex-growflex-shrinkflex-basis;参数说明如下：flex-grow：（必填参数）一个数字，用来设置项目相对于其他项目的增长量，默认值为0；flex-shrink：（选填参数）一个数字，用来设置项目相对于其他项目的收缩量，默认值为1；flex-basis：（选填参数）项目的长度，合法值为auto（默认值，表示自动）、inherit（表示从父元素继承该属性的值）或者以具体的值加&quot;%&quot;、&quot;px&quot;、&quot;em&quot;等单位的形式。另外，flex属性还有两个快捷值，分别为auto（11auto）和none（00auto）。.flex{display:flex;flex-flow:rowwrap;align-items:flex-end;border:1pxsolid#CCC;}.flexdiv{width:60px;height:60px;border:1pxsolidblack;}.flexdiv:nth-child(2){flex:0;}.flexdiv:nth-child(4){flex:11auto;}也可以使用flex-grow、flex-shrink、flex-basis几个属性来分别设置项目的增长量、收缩量以及项目长度.flexdiv:nth-child(4){flex-grow:1;flex-shrink:1;flex-basis:auto;/*等同于flex:11auto;*/}响应式布局（自适应布局）CSS响应式布局也称自适应布局，是EthanMarcotte在2010年5月份提出的一个概念，简单来讲就是一个网站能够兼容多个不同的终端（设备），而不是为每个终端做一个特定的版本。这个概念是为解决移动端浏览网页而诞生的。响应式布局能够为使用不同终端的用户提供很好的用户体验，而且随着大屏智能手机的普及，用“大势所趋”来形容也不为过。要实现响应式布局，常用的方式有以下几种：使用CSS中的媒体查询（最简单）；使用JavaScript（使用成本比较高）；使用第三方开源框架（例如bootstrap，可以很好的支持各种浏览器）。设置meta标签首先，我们需要设置meta标签来告诉浏览器，让视口（网页的可视区域）的宽度等于设备的宽度，并禁止用户对页面的缩放，如下所示：&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt;在设置视口时需要注意，视口就是网页可见区域的尺寸，设置视口时只设置宽度就行，不用在乎高度，具体高度由网页内容自动撑开。上面meta标签中内容的含义如下：viewport：即视口，表示网页的可视区域；width：控制viewport的大小，可以指定一个具体的值，例如600，也可以是由关键字组成的特殊值，例如device-width就表示设备的宽度；initial-scale：表示初始缩放比例，也就是页面第一次加载时的缩放比例；maximum-scale：表示允许用户缩放的最大比例，范围从0到10.0；minimum-scale：表示允许用户缩放到最小比例，范围从0到10.0；user-scalable：表示用户是否可以手动缩放，“yes”表示允许缩放，“no”表示禁止缩放。媒体查询CSS媒体查询可以根据指定的条件，针对不同的媒体类型（screenprint）定义不同的CSS样式，让使用不同设备的用户都能得到最佳的体验。关于媒体查询有以下三种实现方式：直接在CSS文件中使用@media(max-width:320px){/*0~320*/body{background:pink;}}@media(min-width:321px)and(max-width:375px){/*321~768*/body{background:red;}}@media(min-width:376px)and(max-width:425px){/*376~425*/body{background:yellow;}}@media(min-width:426px)and(max-width:768px){/*426~768*/body{background:blue;}}@media(min-width:769px){/*769~+∞*/body{background:green;}}使用@import导入@import'index01.css'screenand(max-width:1024px)and(min-width:720px)@import'index02.css'screenand(max-width:720px)在link标签中使用&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;index01.css&quot;media=&quot;screenand(max-width:1024px)and(min-width:720px)&quot;/&gt;&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;index02.css&quot;media=&quot;screenand(max-width:720px)&quot;/&gt;示例&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;metacharset=&quot;UTF-8&quot;&gt;&lt;title&gt;响应式布局&lt;/title&gt;&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no&quot;/&gt;&lt;style&gt;*{margin:0px;padding:0px;font-family:&quot;微软雅黑&quot;;}#head,#foot,#main{height:100px;width:1200px;/*width:85%;*/background-color:goldenrod;text-align:center;font-size:48px;line-height:100px;margin:0auto;}#headdiv{display:none;font-size:20px;height:30px;width:100px;background-color:green;float:right;line-height:30px;margin-top:35px;}#headul{width:80%;}#headulli{width:20%;float:left;text-align:center;list-style:none;font-size:20px;}#main{height:auto;margin:10pxauto;overflow:hidden;}.left,.center,.right{height:600px;line-height:600px;float:left;width:20%;background-color:red}.center{width:60%;border-left:10pxsolid#FFF;border-right:10pxsolid#FFF;box-sizing:border-box;}@mediaonlyscreenand(max-width:1200px){#head,#foot,#main{width:100%;}}@mediaonlyscreenand(max-width:980px){.right{display:none;}.left{width:30%;}.center{width:70%;border-right:hidden;}}@mediaonlyscreenand(max-width:640px){.left,.center,.right{width:100%;display:block;height:200px;line-height:200px;}.center{border:hidden;border-top:10pxsolid#FFFFFF;border-bottom:10pxsolid#FFFFFF;height:600px;line-height:600px;}#headul{display:none;}#headdiv{display:block;}}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;headerid=&quot;head&quot;&gt;&lt;ul&gt;&lt;li&gt;header1&lt;/li&gt;&lt;li&gt;header2&lt;/li&gt;&lt;li&gt;header2&lt;/li&gt;&lt;li&gt;header2&lt;/li&gt;&lt;li&gt;header2&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;icon&lt;/div&gt;&lt;/header&gt;&lt;sectionid=&quot;main&quot;&gt;&lt;divclass=&quot;left&quot;&gt;left&lt;/div&gt;&lt;divclass=&quot;center&quot;&gt;center&lt;/div&gt;&lt;divclass=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/section&gt;&lt;footerid=&quot;foot&quot;&gt;footer&lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;当浏览器窗口小于1200像素大于980像素时当浏览器窗口大于640像素小于980像素时当浏览器窗口小于640像素时","link":"https://18279493170.github.io/I5zWDp8bI/"},{"title":"css之2D，32D转换，动画与过度","content":"2D转换CSS中的2D转换允许我们在二维空间中执行一些基本的变换操作，例如移动、旋转、缩放或扭曲等，变换后的元素与绝对定位的元素类似，不会影响周围的元素，但可以和周围的元素重叠，不同的是，转换后的元素在页面中任然会占用为转换之前的空间。借助CSS中的transform属性以及下列转换函数就可以实现2D转换：matrix()：以一个包含六个值（a,b,c,d,e,f）的变换矩阵的形式指定一个2D变换，相当于直接应用一个[a,b,c,d,e,f]的变换矩阵；translate()：将对象沿X轴和Y轴平移，该函数需要提供1~2个参数，第一个参数对应X轴，第二个参数对应Y轴，如果未提供第二个参数，则默认值为0；translatex()：将对象沿X轴（水平方向）的平移；translatey()：将对象沿Y轴（垂直方向）的平移；rotate()：旋转指定对象，在函数的参数中可以指定旋转的角度；scale()：将对象进行缩放，该函数需要提供1~2个参数，第一个参数对应X轴，第二个参数对应Y轴，如果未提供第二个参数，则默认取第一个参数的值；scalex()：将对象进行缩放（改变元素的宽度）；scaley()：将对象进行缩放（改变元素的高度）；skew()：将对象沿X轴和Y轴方向进行倾斜扭曲，该函数需要提供1~2个参数，第一个参数对应X轴，第二个参数对应Y轴。如果未提供第二个参数，则默认值为0；skewx()：将对象沿X轴的（水平方向）扭曲；skewy()：将对象沿Y轴的（垂直方向）扭曲。translate()translate()函数用来根据指定的参数将元素沿水平（X轴）或垂直（Y轴）方向移动，函数的语法格式如下：translate(tx,ty)其中tx对应元素在水平（X轴）方向的移动距离，ty对应元素在垂直（Y轴）方向的移动距离，参数ty可以忽略（默认为0），两个参数均可以为负值。transform:translate(100px,10px);如果只是将元素水平移动或者只是将元素垂直移动，也可以使用translateX()（将元素水平移动）或translateY()（将元素垂直移动），translateX()和translateY()函数均只需要提供一个参数即可，例如：translateX(100px);/*等同于translate(100px,0px);/translateY(10px);/等同于translate(0px,10px);*/rotate()rotate()函数用来按照给定的角度来旋转元素，函数的语法格式如下：rotate(a)其中参数a表示元素要旋转的角度，若a为正值则表示顺时针旋转，若a为负值则表示逆时针旋转。transform:rotate(45deg);scale()scale()函数用来缩放（放大或缩小）指定的元素，函数的语法格式如下：scale(sx,sy)其中sx表示水平方向的缩放比例，sy表示垂直方向的缩放比例。另外，参数sy可以省略，它的默认值等于sx。transform:scale(0.7);提示：当scale()中，给定的参数值在-1~1范围之外时，元素将被放大；当在参数值在-1~1范围之内时，元素将被缩小。与translate()函数类似，如果是仅在水平方向或者仅在垂直方向上缩放元素大小，也可以使用scaleX()（在水平方向缩放元素）和scaleY()（在垂直方向缩放元素）函数。scaleX()和scaleY()函数仅需要提供一个参数即可，例如：scaleX(0.5);/*等同于scale(0.5,1);/scaleY(0.5);/等同于scale(1,0.5);*/skew()skew()函数用来将元素沿水平方向（X轴）和垂直方向（Y轴）倾斜扭曲，函数的语法格式如下：skew(ax,ay)其中，参数ax表示元素水平方向的扭曲角度，参数ay表示元素垂直方向的扭曲角度。另外，参数ay可以省略，若省略参数ay，则其默认值为0。transform:skew(-15deg,20deg);另外，如果是仅在水平方向或者仅在垂直方向上对元素进行扭曲，也可以使用skewX()（在水平方向缩放元素）和skewY()（在垂直方向缩放元素）函数来完成。skewX()和skewY()函数仅需要提供一个参数即可，例如：skewX(15deg);/*等同于skew(15deg,0deg);/skewY(15deg);/等同于skew(0deg,15deg);*/matrix()matrix()函数可以看作是skew()、scale()、rotate()和translate()几个函数的缩写形式，通过matrix()函数可以同时定义所有2D转换操作，函数的语法格式如下：matrix(a,b,c,d,tx,ty)matrix()函数中的6个参数分别对应scaleX()、skewY()、skewX()、scaleY()、translateX()、translateY()几个函数，您可以使用matrix()来实现各种2D转换操作，例如：translate(tx,ty)=matrix(1,0,0,1,tx,ty);：其中tx和ty是水平和垂直平移值；rotate(a)=matrix(cos(a),sin(a),-sin(a),cos(a),0,0);：其中，a是度数的值。您可以交换sin(a)和-sin(a)值来进行反向旋转；scale(sx,sy)=matrix(sx,0,0,sy,0,0);：其中sx和sy是水平和垂直缩放比例值；skew(ax,ay)=matrix(1,tan(ay),tan(ay),1,0,0);：其中ax和ay是以deg为单位的水平和垂直值。transform:matrix(0.866,0.5,-0.5,0.866,0,0);3D转换在CSS中，除了可以对页面中的元素进行2D转换外，您也可以对象元素进行3D转换（将页面看作是一个三维空间来对页面中的元素进行移动、旋转、缩放和倾斜等操作）。与2D转换相同，3D转换同样不会影响周围的元素，而且可以与其它元素重叠。但是，变换后的元素任然会占用其默认位置（未变换前）的空间。3D转换同样需要使用transform属性以及一些函数来实现，例如：matrix3d()：以一个4x4矩阵的形式指定一个3D转换；translate3d()：指定对象的3D位移，第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略；translateZ()：指定对象在Z轴的平移；rotate3d()：指定对象的3D旋转角度，其中前3个参数分别表示旋转的方向X、Y、Z，第4个参数表示旋转的角度，参数不允许省略；rotateX()：指定对象在X轴上的旋转角度；rotateY()：指定对象在Y轴上的旋转角度；rotateZ()：指定对象在Z轴上的旋转角度；scale3d()：指定对象的3D缩放，第1个参数对应X轴，第2个参数对应Y轴，第3个参数对应Z轴，参数不允许省略；scaleZ()：指定对象的Z轴缩放；perspective()：指定透视距离。translate3d()translate3d()函数用于移动元素在3D空间中的位置，这种变换的特点是通过三维矢量坐标来定义元素在每个方向上（X轴、Y轴、Z轴）的偏移量。函数的语法格式如下：translate3d(tx,ty,tz)参数说明如下：tx：表示元素在水平方向（X轴）移动的距离；ty：表示元素的垂直方向（Z轴）移动的距离；tz：表示元素在Z轴移动的距离，该参数不能使用百分比值。transform:translate3d(25px,25px,50px);3D转换使用的是三维坐标系，但是沿Z轴方向的移动并不能很明显的显现出来，因为我们往往会将网页看作是一个二维的平面，并没有深度。您可以使用perspective和perspective-origin属性来为元素添加深度感，即Z轴越高的元素显示的越大，反之则越小。translateZ()函数translateZ()用来沿三维坐标系的Z轴来移动元素，函数的语法格式如下：translateZ(tz);其中参数tz用来设置元素在Z轴上移动的距离。提示：translateZ(tz);相当于translate3d(0,0,tz);的简写形式。transform:translateZ(30px);rotate3d()rotate3d()函数用来设置元素沿X轴、Y轴或Z轴方向旋转的角度，该函数只会使元素按照固定的轴旋转，不会使元素变形。rotate3d()函数的语法格式如下：rotate3d(x,y,z,a)参数说明如下：x：设置旋转轴的X轴坐标；y：设置旋转轴的Y轴坐标；z：设置旋转轴的Z轴坐标；a：设置元素旋转的角度，正角度表示顺时针旋转，负角度表示逆时针旋转。transform:rotate3d(0,1,2,40deg);除了rotate3d()函数外，CSS中还提供了rotateX()（沿X轴旋转元素）、rotateY()（沿Y轴旋转元素）和rotateZ()（沿Z轴旋转元素）三个函数来按照不同的坐标轴旋转元素。rotateX()、rotateY()、rotateZ()函数的语法格式如下：rotateX(a)/*等同于rotate3D(1,0,0,a);/rotateY(a)/等同于rotate3D(0,1,0,a);/rotateZ(a)/等同于rotate3D(0,0,1,a);*/scale3d()scale3d()函数可以改变元素的大小（缩放），函数的语法格式如下：scale3d(sx,sy,sz)参数说明如下：sx：表示元素在X轴方向的缩放比例；sy：表示元素在Y轴方向的缩放比例；sz：表示元素在Z轴方向的缩放比例。提示：当scale3d()函数的参数数值超出[-1，1]范围时，将在对应的方向上放大元素；当参数值在[-1，1]范围内时，将在当前方向上缩小元素；当参数值等于1时，则不会改变元素的大小。除了scale3d()函数外，CSS中还提供了scaleX()（沿X轴缩放元素）、scaleY()（沿Y轴缩放元素）和scaleZ()（沿Z轴缩放元素）三个函数来按照不同的坐标轴缩放元素。scaleX()、scaleY()、scaleZ()函数的语法格式如下：scaleX(sx)/*等同于scale(sx,1);和scale3d(sx,1,1);/scaleY(sy)/等同于scale(1,sy);和scale3d(1,sy,1);/scaleZ(sz)/等同于scale3d(1,1,sz);*/matrix3d()matrix3d()函数与前面我们学习的matrix()函数非常相似，不过matrix3d()函数可以使用一个4×4的矩阵来描述一个三维（3D）转换。通过matrix3d()函数可以一次执行所有的3D转换操作，函数的语法格式如下：matrix3d(a1,b1,c1,d1,a2,b2,c2,d2,a3,b3,c3,d3,a4,b4,c4,d4)参数说明如下：a1、b1、c1、d1、a2、b2、c2、d2、a3、b3、c3、d3、d4：用来描述各种3D转换；a4、b4、c4：表示元素变换的量。transform:matrix3d(0.359127,-0.469472,0.806613,0,0.190951,0.882948,0.428884,0,-0.913545,0,0.406737,0,0,0,0,1);transition（过渡效果)通常当CSS的属性值更改后，浏览器会立即更新相应的样式，例如当鼠标悬停在元素上时，通过:hover选择器定义的样式会立即应用在元素上。在CSS3中加入了一项过渡功能，通过该功能您可以将元素从一种样式在指定时间内平滑的过渡到另一种样式，类似于简单的动画，但无需借助flash或JavaScript。CSS中提供了5个有关过渡的属性，如下所示：transition-property：设置元素中参与过渡的属性；transition-duration：设置元素过渡的持续时间；transition-timing-function：设置元素过渡的动画类型；transition-delay：设置过渡效果延迟的时间，默认为0；transition：简写属性，用于同时设置上面的四个过渡属性。要成功实现过渡效果，必须定义以下两项内容：元素中参数与过渡效果的属性；过渡效果持续的时间。提示：过渡效果通常会在鼠标悬停在元素上时发生，如果未设置过渡持续的时间，则过渡效果不会生效，因为过渡时间的默认值为0。transition-propertytransition-property属性用来设置元素中参与过渡的属性名称，语法格式如下：transition-property:none|all|property;参数说明如下：none：表示没有属性参与过渡效果；all：表示所有属性都参与过渡效果；property：定义应用过渡效果的CSS属性名称列表，多个属性名称之间使用逗号,进行分隔。transition-property:width,background;transition-durationtransition-duration属性用来设置过渡需要花费的时间（单位为秒或者毫秒），语法格式如下：transition-duration:time;其中，time为完成过渡效果需要花费的时间（单位为秒或毫秒），默认值为0，意味着不会有效果。如果有多个参与过渡的属性，也可以依次为这些属性设置过渡需要的时间，多个属性之间使用逗号进行分隔，例如transition-duration:1s,2s,3s;。除此之外，也可以使用一个时间来为所有参与过渡的属性设置过渡所需的时间。transition-property:width,background;transition-duration:.25s,1s;transition-timing-functiontransition-timing-function属性用来设置过渡动画的类型，属性的可选值如下：linear以始终相同的速度完成整个过渡过程，等同于cubic-bezier(0,0,1,1)ease以慢速开始，然后变快，然后慢速结束的顺序来完成过渡过程，等同于cubic-bezier(0.25,0.1,0.25,1)ease-in以慢速开始过渡的过程，等同于cubic-bezier(0.42,0,1,1)ease-out以慢速结束过渡的过程，等同于cubic-bezier(0,0,0.58,1)ease-in-out以慢速开始，并以慢速结束的过渡效果，等同于cubic-bezier(0.42,0,0.58,1)cubic-bezier(n,n,n,n)使用cubic-bezier()函数来定义自己的值，每个参数的取值范围在0到1之间transition-property:width,background;transition-duration:.25s,1s;transition-timing-function:ease;transition-delaytransition-delay属性用来设置过渡效果何时开始，属性的语法格式如下：transition-delay:time;其中，参数time用来设置在过渡效果开始之前需要等待的时间，单位为秒或毫秒。transition-property:width,background;transition-duration:.25s,1s;transition-delay:3s;transitiontransition属性是上面四个属性的简写形式，通过该属性可以同时设置上面的四个属性，属性的语法格式如下：transition:transition-propertytransition-durationtransition-timing-functiontransition-delay;transition属性中，transition-property和transition-duration为必填参数，transition-timing-function和transition-delay为选填参数，如非必要可以省略不写。另外，通过transition属性也可以设置多组过渡效果，每组之间使用逗号进行分隔transition:width.25slinear1.9s,background1s2s,transform2s;transition-property:width,background,transform;transition-duration:.25s,1s,2s;transition-timing-function:linear,ease,ease;transition-delay:1.9s,2s,0s;","link":"https://18279493170.github.io/de0x4i9pU/"},{"title":"css之透明度，@规则与媒体查询","content":"透明度（opacity）rgba()、hsla()可以设置颜色的透明度，但是它们只能在定义颜色的同时设置透明度，无法对图像或者其它元素设置透明度。CSS中提供了一个opacity属性用来设置元素的透明度，它不仅对颜色有效，对图像或者页面中其它的元素也有效opacity:number;其中number为一个0~1之间的浮点数（小数），用来表示元素的透明度，值越小则越透明（0表示完全透明，1表示完全不透明）。另外，在使用opacity属性时，还需要注意以下几点：当一个元素定义了opacity属性，并且其值小于1时，那么它的子元素也会拥有同样的透明度；当一个元素定义了opacity属性，并且其值小于1时，将会重新定义该元素默认的z-index属性，如果其它的元素为非定位元素，那么该元素的堆叠级别将会高于其它元素；如果定义的opacity属性值超过了指定的范围，那么则截取与之最相近的值，例如1.5将截取为1。opacity:0.4;IE8或者更早版本的IE浏览器不支持opacity属性，若想要在这些浏览器中实现透明效果可以使用filter属性filter:alpha(opacity=number);其中number的取值范围为0~100，值越小则越透明。filter:alpha(opacity=50);为了让所有浏览器都可以实现透明效果，您可以同时定义opacity和filter两个属性p{opacity:0.5;filter:alpha(opacity=50);}@规则在CSS中包含两种语法规则：普通规则：由选择器、属性和值构成；@规则：以@开头后面跟随一个关键字的形式构成，也被称为“AT规则”，根据使用方法的不同又可以分为“常规规则”与“嵌套规则”两种。常规规则@[KEYWORD](RULE);@charset@charset用来设置CSS文件使用的字符编码@charset&quot;&lt;charset&gt;&quot;;其中&lt;charset&gt;为具体的字符编码，默认值为“utf-8”。注意：如果设置@charset的话，那么它必须出现在CSS文件的最前面，@charset之前不能出现任何字符；字符编码需要使用双引号&quot;&quot;包裹起来；@规则名称（@charset）与具体的字符编码之间需要使用一个空格分隔；规则后面的分号不能省略；如果设置多个@charset，那么只有第一个声明有效；不能在HTML元素或者&lt;style&gt;标签中使用@charset；如果以不同的方式定义了多种字符编码规则，它们的优先级顺序如下：HTML文件开头的字符编码声明；HTTP请求头中的字符编码声明；CSS文件中使用@charset定义的字符编码声明；&lt;link&gt;标签中charset属性设置的字符编码声明（HTML5中已废弃）。/*设置CSS的编码格式为UnicodeUTF-8*/@charset&quot;UTF-8&quot;;@charset&quot;utf-8&quot;;/*大小写不敏感*//*错误演示*/@charset'iso-8859-15';/*无效的,使用了错误的引号*/@charset'UTF-8';/*无效的,使用了错误的引号*/@charset&quot;UTF-8&quot;;/*无效的,@charset与字符编码之间多用了一个空格*/@charset&quot;UTF-8&quot;;/*无效的,@规则之前多了一个空格*/@charsetUTF-8;/*无效的,字符编码需要使用双引号包裹*/@import@import用来向当前CSS样式文件中导入其它样式文件。通过@import可以引入其他样式表文件中除@charset以外的所有内容，另外@import也必须放在样式文件的最前面@import&lt;url&gt;&lt;media_query_list&gt;其中，&lt;url&gt;为使用绝对或相对路径指定的要导入的外部样式表文件路径，也可以使用url()函数来指定文件路径；&lt;media_query_list&gt;为可选参数，用来指定媒体查询的条件，多个条件之间使用逗号,分隔。在实际项目中不建议过多的使用@import，因为它会造成很多额外的请求，阻塞其它文件的加载。注意:@import必须在样式表文件的开头最先声明，并且声明的末尾必须使用分号结尾，如果省略了结尾的分号，可能会导致外部样式表无法正确导入；在IE浏览器使用@import最多只能引入35条样式表。@importurl(&quot;global.css&quot;);@importurl(global.css);@import&quot;global.css&quot;;@importurl(&quot;fineprint.css&quot;)print;@importurl(&quot;bluish.css&quot;)projection,tv;@import'custom.css';@importurl(&quot;chrome://communicator/skin/&quot;);@import&quot;common.css&quot;screen,projection;@importurl('landscape.css')screenand(orientation:landscape);以上几种定义方式都是有效的，当使用url()来设置样式表文件的路径时，包裹路径的引号可有可无；当直接使用具体路径来设置样式表文件的路径时，包裹路径的引号则必须保留。@namespace@namespace用来定义CSS样式表中XML命名空间的@规则，可以为当前样式文件内的所有选择器都设置指定的命名空间。@namespace通常用来处理包含多个命名空间的文档，比如HTML5里内联的SVG、MathML或者混合多个词汇表的XML。@namespace必须定义在所有@charset和@import的之后，并且在样式表中要位于其他任何样式声明之前。@namespace可以用来定义默认命名空间，当指定默认命名空间后，所有的通用选择器和类选择器（但不包括属性选择器）都只会应用在这个命名空间的元素中。@namespace也可以用于定义命名空间前缀，当一个通用、类、属性选择器前面有命名空间前缀修饰时，这个选择器将只匹配那些命名空间与元素名或属性匹配的元素。/*默认命名空间*/@namespaceurl(XML-namespace-URL);@namespace&quot;XML-namespace-URL&quot;;/*命名空间前缀*/@namespaceprefixurl(XML-namespace-URL);@namespaceprefix&quot;XML-namespace-URL&quot;;嵌套规则所谓“嵌套规则”指的就是在@规则后面需要跟随一个花括号{}，其中包含了一些其它的规则声明@[KEYWORD]{/*嵌套语句*/}@media@media用来根据一个或多个媒体查询的结果来应用样式表的某一部分（花括号中的样式信息），使用@media您可以指定一组媒体查询和一个CSS样式块，当且仅当媒体查询与正在使用的设备匹配时，指定的CSS样式才会应用于文档。媒体查询是用于判断设备信息的一组条件，如设备的宽高值，宽高比，颜色，分辨率等，当条件匹配时，才会执行其内嵌套的样式信息。@media可以放置在样式表中的任意位置，也可以放置于其它@规则中@mediaalland(min-width:1280px){/*宽度大于1280*/}@media(-webkit-min-device-pixel-ratio:1.5),(min-resolution:2dppx){/*Retina屏幕*/}@mediaprint{/*打印*/}@media\\0screen\\,screen\\9{/*IE7,IE8*/}@mediascreen\\9{/*IE7*/}@page@page用于在打印文档时修改某些CSS属性，需要注意的是，使用@page您只能修改部分CSS属性，例如外间距属性margin，打印相关的orphans、widows属性，以及page-break-*等属性，其他的CSS属性会被忽略。/*表示打印时第一页的上、左外边距均为50%*/@page:first{margin-left:50%;margin-top:50%;}@supports@supports用于检查浏览器是否支持某个CSS特性，也被称为“特性查询”@supports(rule)[operator(rule)]*{sRules};rule为某个具体的CSS样式，必须使用括号包裹；operator的可选值为or、and、not，通过operator参数可以指定多条CSS样式。@supports既可以在样式文件的顶部定义，也可以在其它嵌套规则内部定义。但是@supports目前还在实验阶段，在使用时要先确定浏览器是否支持。/*当浏览器支持display:grid属性时要使用的CSS样式*/@supports(display:grid){div{display:grid;}}/*当浏览器不支持display:grid属性时要使用的CSS样式*/@supportsnot(display:grid){div{float:right;}}/*同时检查多个条件*/@supports(display:flex)and(-webkit-appearance:checkbox){.module{display:flex;}}@font-face@font-face用于从远程服务器或者用户本地加载指定的字体@font-face{font-family:&lt;identifier&gt;;src:&lt;url&gt;[format(&lt;string&gt;)][,&lt;url&gt;[format(&lt;string&gt;)]]*;&lt;font&gt;;}参数说明如下：&lt;identifier&gt;：字体名称；&lt;url&gt;：使用url()（远程字体）或者local()（本地字体）来指定字体的存放路径，可以是相对路径也可以是绝对路径；&lt;string&gt;：用来指定自定义字体的格式，例如以下几种类型truetype、opentype、embedded-opentype、svg等；&lt;font&gt;：定义字体相关样式。提示：@font-face可以放在css样式表的顶部，也可以放在其它嵌套规则中。如果同时使用local()函数和url()函数加载字体，则会优先加载local()函数中定义的本地字体，如果没有找到则会加载url()函数中定义的远程字体。/*定义@font-face规则*/@font-face{/*指定字体名称*/font-family:&quot;OpenSans&quot;;/*指定字体文件的路径*/src:url(&quot;/fonts/OpenSans-Regular-webfont.woff2&quot;)format(&quot;woff2&quot;),url(&quot;/fonts/OpenSans-Regular-webfont.woff&quot;)format(&quot;woff&quot;);}/*字体的应用*/p{font-family:&quot;OpenSans&quot;;}@keyframes@keyframes用来定义CSS3中animation动画关键帧（或waypoints）的样式，以此来控制动画序列中的中间步骤。定义该规则后，需要通过animation-name属性来使用。关键帧序列是由百分比来标识命名的，起始状态和结束状态分别为from和to代表0%和100%。@keyframes&lt;identifier&gt;{&lt;keyframes-blocks&gt;}其中&lt;identifier&gt;用来定义动画名称；&lt;keyframes-blocks&gt;用来定义动画在每个阶段的样式，即帧动画。/*声明*/@keyframesslidein{from{margin-left:100%;width:300%;}to{margin-left:0%;width:100%;}}@keyframesslideout{0%{top:0;}50%{top:30px;}100%{top:60px;}}/*应用*/p{animation-name:slidein;animation-duration:4s;}div{animation-name:slideout;animation-duration:4s;}@document@document用来根据文档的URL限制文档中样式的作用范围，通过该属性可以为指定用户定义专属的样式。目前@document还在实验阶段，具体标准会在CSS4中确定。@document中的可用函数如下所示：url()：匹配整个URL；url-prefix()：匹配文档的URL是否以参数指定的值开头；domain()：匹配文档的域名是否为参数中指定的域名或者为它的子域名；regexp()：匹配文档的URL是否和参数中指定的正则表达式匹配，该表达式必须匹配整个URL。提示：提供给url()、url-prefix()和domain()函数的参数可以不使用引号包裹，但提供给regexp()函数的参数必须使用引号包裹起来。@documenturl(http://www.weixueyuan.net/),url-prefix(http://www.weixueyuan.net/Style/),domain(weixueyuan.net),regexp(&quot;https:.*&quot;){/*该条CSS规则会应用在下面的网页:+URL为&quot;http://www.weixueyuan.net/&quot;的页面.+任何URL以&quot;http://www.weixueyuan.net/Style/&quot;开头的网页+域名&quot;weixueyuan.net&quot;下的所有网页+任何URL以&quot;https:&quot;开头的网页*//*定义样式*/body{color:purple;background:yellow;}}媒体查询（@media）媒体查询是CSS样式表最重要的功能之一，所谓媒体查询指的就是根据不同的媒体类型（设备类型）和条件来区分各种设备（例如：电脑、手机、平板电脑、盲文设备等），并为它们分别定义不同的CSS样式。媒体查询能让CSS可以更精确的作用于不同的设备或同一设备的不同条件，让所有用户都能得到很好的用户体验。媒体类型媒体类型用来表示设备的类别，CSS中提供了一些关键字来表示不同的媒体类型all表示所有的媒体设备aural表示语音和音频合成器（听觉设备）braille表示盲人用点字法触觉回馈设备embossed表示盲人用点字法打印机handheld表示小型手持设备，如手机、平板电脑print表示打印机projection表示投影设备screen表示电脑显示器tty表示使用固定密度字母栅格的媒体，比如打字机或终端设备tv表示电视机类型的设备媒体特性除了具体的类型外，还可以通过一些属性来描述设备的具体特征，例如宽度、高度、分辨率等aspect-ratio输出设备页面可见区域的宽高比color输出设备每个像素的比特值，常见的有8、16、32位。如果设备不支持输出彩色，则该值为0color-index输出设备的颜色查询表中的条目数量。如果没有使用颜色查询表，则该值等于0device-aspect-ratio输出设备的宽高比device-height输出设备屏幕的可见高度device-width输出设备屏幕的可见宽度grid查询输出设备使用的是网格屏幕还是点阵屏幕height页面可见区域的高度max-aspect-ratio输出设备屏幕可见区域宽度与高度的最大比率max-color输出设备每个像素比特值的最大值max-color-index输出设备的颜色查询表中的最大条目数max-device-aspect-ratio输出设备屏幕可见区域宽度与高度的最大比率max-device-height输出设备屏幕可见区域的最大高度max-device-width输出设备屏幕的最大可见宽度max-height页面可见区域的最大高度max-monochrome输出设备单色帧缓冲区中每个像素的最大位深度。如果设备并非黑白屏幕，则该值为0max-resolution设备的最大分辨率max-width页面可见区域的最大宽度min-aspect-ratio输出设备屏幕可见区域宽度与高度的最小比率min-color输出设备每个像素比特值的最小值min-color-index输出设备的颜色查询表中的最小条目数min-device-aspect-ratio输出设备的屏幕可见区域宽度与高度的最小比率min-device-width输出设备的屏幕的最小可见宽度min-device-height输出设备的屏幕的最小可见高度min-height页面可见区域的最小高度min-monochrome输出设备单色帧缓冲区中每个像素的最小位深度。如果设备并非黑白屏幕，则该值为0min-resolution设备的最小分辨率min-width页面可见区域的最小宽度monochrome输出设备单色帧缓冲区中每个像素的位深度。如果设备并非黑白屏幕，则该值为0orientation页面可见区域的旋转方向resolution设备的分辨率。如：96dpi、300dpi、118dpcmscan电视类设备的扫描工序width页面可见区域的宽度逻辑操作符逻辑操作符包含not、and和only三个，通过逻辑操作符可以构建复杂的媒体查询，您还可以通过逗号来分隔多个媒体查询，将它们组合为一个规则。and：用于将多个媒体查询组合成一条媒体查询，当每个查询规则都为真时则该条媒体查询为真，另外通过and操作符还可以将媒体特性与媒体类型结合在一起；not：用于否定媒体查询，当查询规则不为真时则返回true，否则返回false。如果使用not操作符，则还必须指定媒体类型；only：仅在整个查询匹配时才会生效，当不使用only时，旧版的浏览器会将screenand(max-width:500px)简单地解释为screen，忽略查询的其余部分，并将样式应用于所有屏幕。如果使用only运算符，则还必须指定媒体类型。定义媒体查询目前您可以通过以下两种方式来定义媒体查询：使用@media或@import规则在样式表中指定对应的设备类型；用media属性在&lt;style&gt;、&lt;link&gt;、&lt;source&gt;或其他HTML元素中指定特定的设备类型。@media使用@media您可以指定一组媒体查询和一个CSS样式块，当且仅当媒体查询与正在使用的设备匹配时，指定的CSS样式才会应用于文档/*在小于或等于992像素的屏幕上，将背景色设置为蓝色*/@mediascreenand(max-width:992px){body{background-color:blue;}}/*在600像素或更小的屏幕上，将背景色设置为橄榄色*/@mediascreenand(max-width:600px){body{background-color:olive;}}@import@import用来导入指定的外部样式文件并指定目标的媒体类型@importurl(&quot;css/screen.css&quot;)screen;/*引入外部样式，该样式仅会应用于电脑显示器*/@importurl(&quot;css/print.css&quot;)print;/*引入外部样式，该样式仅会应用于打印设备*/body{background:#f5f5f5;line-height:1.2;}注意：所有@import语句都必须出现在样式表的开头，而且在样式表中定义的样式会覆盖导入的外部样式表中冲突的样式。media属性在&lt;style&gt;、&lt;link&gt;、&lt;source&gt;等标签的media属性中来定义媒体查询/*当页面宽度大于等于900像素时应用该样式*/&lt;linkrel=&quot;stylesheet&quot;media=&quot;screenand(min-width:900px)&quot;href=&quot;widescreen.css&quot;&gt;/*当页面宽度小于等于600像素时应用该样式*/&lt;linkrel=&quot;stylesheet&quot;media=&quot;screenand(max-width:600px)&quot;href=&quot;smallscreen.css&quot;&gt;提示：在media属性中您还可以指定多种媒体类型，每种媒体类型之间使用逗号进行分隔，例如media=&quot;screen,print&quot;。","link":"https://18279493170.github.io/UpeMM9bjh/"},{"title":"css之圆角，渐变，阴影与边框图片","content":"圆角（border-radius）制作网页的过程中，有时我们可能需要实现圆角的效果，以前的做法是通过切图（将设计稿切成便于制作成页面的图片），使用多个背景图像来实现圆角。在CSS3出现之后就不需要这么麻烦了，CSS3中提供了一系列属性来设置元素的圆角效果border-top-left-radius：为元素左上角设置圆角效果；border-top-right-radius：为元素右上角设置圆角效果；border-bottom-right-radius：为元素右下角设置圆角效果；border-bottom-left-radius：为元素左下角设置圆角效果；border-radius：上面四个属性的简写形式，可以同时为元素的四个角设置圆角效果。值：length通过数值加单位的形式定义圆角的形状percentage以百分比的形式定义圆角的形状border-*-radius通过border-*-radius系列函数能够分别为元素的四个角设置圆角效果border-*-radius：[&lt;length&gt;|&lt;percentage&gt;]{1,2}语法的含义为，需要为border-*-radius属性提供1~2个参数，参数之间使用空格进行分隔。其中第一个参数表示圆角水平方向的半径或半轴，第二个参数表示圆角垂直方向的半径或半轴，如果省略第二个参数，那么该参数将直接沿用第一个参数的值。.one{border-top-left-radius:2em0.5em;border-top-right-radius:1em3em;border-bottom-right-radius:4em0.5em;border-bottom-left-radius:1em3em;background-color:#CCC;margin-bottom:10px;}.two{border-top-left-radius:2em;border-top-right-radius:2em;border-bottom-right-radius:2em;border-bottom-left-radius:2em;background-color:#888;}border-radiusborder-radius属性是border-top-left-radius、border-top-right-radius、border-bottom-right-radius、border-bottom-left-radius四个属性的简写形式，使用border-radius可以同时设置四个border-*-radius属性border-radius：[&lt;length&gt;|&lt;percentage&gt;]{1,4}[/[&lt;length&gt;|&lt;percentage&gt;]{1,4}]?border-radius属性可以接收两组参数，参数之间使用斜杠/进行分隔，每组参数都允许设置1~4个参数值，其中第一组参数代表圆角水平方向上的半径或半轴，第二组参数代表圆角垂直方向上的半径或半轴，如果省略第二组参数的值，那么该组参数将直接沿用第一组参数的值。第一组参数中，如果提供全部的四个参数，那么将按照上左top-left、上右top-right、下右bottom-right、下左bottom-left的顺序作用于元素的四个角；如果提供三个参数，那么第一个参数将作用于元素的左上角top-left，第二个参数将作用于元素的右上角top-right和左下角bottom-left，第三个参数将作用于元素的右下角bottom-right；如果提供两个参数，那么第一个参数将作用于元素的左上角top-left和右下角bottom-right，第二个参数将作用于元素的右上角top-right和左下角bottom-left；如果只提供一个参数，那么该参数将同时作用于元素的四个角。第二组参数同样遵循第一组参数的规律，只是作用的方向不同。.test.one{border-radius:10px;}.test.two{border-radius:10px20px;}.test.three{border-radius:10px20px30px;}.test.four{border-radius:10px20px30px40px;}.test2.one{border-radius:10px/5px;}.test2.two{border-radius:10px20px/5px10px;}.test2.three{border-radius:10px20px30px/5px10px15px;}.test2.four{border-radius:10px20px30px40px/5px10px15px20px;}渐变色（颜色渐变）CSS中的渐变指的是两种或多种颜色之间的平滑过渡，以前我们必须使用事先定义好的图像来实现渐变效果，在CSS3出现以后则简单了很多，CSS3为实现渐变效果提供了一种灵活的解决方案。通过CSS3您可以定义三种类型的渐变，分别为线性渐变（通过linear-gradient()函数创建）、径向渐变（通过radial-gradient()函数创建）和圆锥渐变（通过conic-gradient()函数创建）。另外，您还可以使用repeating-linear-gradient()、repeating-radial-gradient()和repeating-conic-gradient()函数来创建重复渐变。通过CSS创建的渐变不仅简单灵活，而且还省去了使用图像时所需的加载过程，节省了网页的加载时间。另外，通过CSS创建的渐变元素可以按任意比例放大或缩小，而且不会降低质量。线性渐变线性渐变指的是颜色沿一条直线进行渐变（例如右上到下，从左到右等），要创建线性渐变，您至少需要定义两个色标（色标指的是想要平滑过渡的颜色），若要创建更加复杂的渐变效果，则需要定义更多的色标。linear-gradient(direction,color-stop1,color-stop2,...);参数：direction可选值，定义渐变的方向（例如从左到右，从上到下），可以是具体角度（例如90deg），也可以通过to加left、right、top、bottom等关键字来表示渐变方向，例如：toleft：表示从右到左，相当于270deg；toright：表示从左到右，相当于90deg；totop：表示从下到上，相当于0deg；tobottom：默认值，表示从上到下，相当于180deg；torightbottom：表示从左上到右下；torighttop：表示从左下到右上；toleftbottom：表示从右上到左下；tolefttop：表示从右下到左上。color-stop1、color-stop2、...：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过数值加单位或者百分比的形式定义颜色的起止位置。.one{background:linear-gradient(torightbottom,red,blue70px);}.two{background:linear-gradient(190deg,#000,#FFF);}.three{background:linear-gradient(red,green,blue);}.four{background:linear-gradient(toright,red,orange,yellow,green,blue,indigo,violet);}径向渐变径向渐变与线性渐变类型，不同之处在于径向渐变是由中心向外延申的渐变，您可以指定中心点的位置，也可以设置渐变的形状。radial-gradient(shapesizeatposition,color-stop1,color-stop2,...);参数：at：一个关键字，需要放置在参数position的前面；position：指定渐变起点的坐标，您可以使用数值加单位、百分比或者关键字（例如left、bottom等）等形式指定渐变起点的坐标，如果提供2个参数，那么第一个参数用来表示横坐标，第二个参数用来表示纵坐标，如果只提供一个参数，那么第二个参数将被默认设置为50%，即center；shape：指定渐变的形状，可选值为circle（圆形）、ellipse（椭圆）；size：指定渐变形状的大小，除了可以使用具体的数值来指定circle、ellipse的半径外，还可以使用下面所示的关键字来指定渐变形状的大小：closest-side：指定径向渐变的半径长度为从圆心到离圆心最近的边；closest-corner：指定径向渐变的半径长度为从圆心到离圆心最近的角；farthest-side：默认值，指定径向渐变的半径长度为从圆心到离圆心最远的边；farthest-corner：指定径向渐变的半径长度为从圆心到离圆心最远的角。color-stop1、color-stop2、...：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过数值加单位或者百分比的形式定义颜色的起止位置。.one{background:radial-gradient(circleat50%,red,yellow,lime);}.two{background:radial-gradient(ellipse100px30pxat30%,red,yellow,lime);}.three{background:radial-gradient(circle100pxat50%,red10%,yellow50%,lime100px);}.four{background:radial-gradient(circleclosest-cornerat50px30px,red,yellow,lime);}圆锥渐变圆锥渐变类似于径向渐变，两者都有一个中心点作为色标的源点，不同的是圆锥渐变是围绕中心点旋转（而不是从中心点向往辐射）conic-gradient(fromangleatposition,start-color,...,last-color);语法：from：一个关键字，需要放置在参数angle之前；angle：定义圆锥渐变的起始角度，可以为空，默认值为0deg；at：一个关键字，需要放置在参数position之前；position：定义圆锥渐变锥心的坐标，您可以使用数值加单位、百分比或者关键字（例如left、bottom等）等形式指定锥心的坐标，如果提供2个参数，那么第一个参数用来表示横坐标，第二个参数用来表示纵坐标，如果只提供一个参数，那么第二个参数将被默认设置为50%，即center（居中）；start-color、...、last-color：表示定义的多个色标，在每个色标中除了可以定义颜色外，还可以通过百分比或者角度来定义颜色的起始位置。.one{background:conic-gradient(at50%,red,orange,yellow,green,blue,indigo,violet,red);}.two{background:conic-gradient(red0deg30deg,orange30deg50deg,yellow50deg200deg,green200deg300deg,blue300deg360deg);}.three{background:conic-gradient(from90deg,red0%55%,yellow55%90%,lime90%100%);}.four{background:conic-gradient(#fff0.25turn,#0000.25turn0.5turn,#fff0.5turn0.75turn,#0000.75turn);}重复渐变可以使用repeating-linear-gradient()、repeating-radial-gradient()和repeating-conic-gradient()等函数来分别创建线性渐变、径向渐变和圆锥渐变的重复渐变，所谓重复渐变就是指将渐变的过程重复多次，以铺满整个元素。提示：repeating-linear-gradient()、repeating-radial-gradient()和repeating-conic-gradient()函数的语法分别与linear-gradient()、radial-gradient()和conic-gradient()函数的语法相同。.one{background:repeating-linear-gradient(190deg,#0000px10px,#FFF10px20px);}.two{background:repeating-radial-gradient(circle100pxat50%,red0%10%,yellow10%30%,lime30%40%);}.three{background:repeating-conic-gradient(#69f036deg,#fd44ff36deg72deg);}.four{background:conic-gradient(#fff0.25turn,#0000.25turn0.5turn,#fff0.5turn0.75turn,#0000.75turn)topleft/25%25%repeat;}阴影效果在网页设计中常常要使用到阴影效果，通过阴影效果可以很好的突出一个元素，在CSS3出现之前，我们想要为文本或者元素添加阴影效果需要借助图像才能实现，很不方便。而CSS3出现之后，我们通过text-shadow和box-shadow两个属性就可以为文本或元素添加阴影效果，不需要借助任何图像。text-shadow使用CSS的text-shadow属性我们可以为文本设置阴影效果text-shadow:offset-xoffset-yblurcolor;offset-x：必填参数，设置阴影的水平偏移量，可以为负值；offset-y：必填参数，设置阴影的垂直偏移量，可以为负值；blur：可选参数，设置模糊的半径，值越大，模糊越大，阴影的边缘越模糊，不允许使用负值；color：可选参数，设置阴影的颜色，如果省略或未指定该值，则采用color属性的值。提示：使用text-shadow属性可以同时设定多组阴影效果，每组之间使用逗号分隔，定义的多组阴影效果会按照定义顺序依次罗列，第一个阴影在最上面，以此类推。另外，若要取消文本的阴影效果则可以将text-shadow属性的值设置为none。text-shadow:1px1px2pxblack,0025pxblue,005pxdarkblue;box-shadow使用CSS的box-shadow属性我们可以为HTML元素设置阴影效果box-shadow:h-shadowv-shadowblurspreadcolorinset;h-shadow：必填参数，设置阴影水平方向的偏移量，可以为负值；v-shadow：必填参数，设置阴影垂直方向的偏移量，可以为负值；blur：可选参数，设置模糊的半径，值越大，模糊越大，阴影的边缘越模糊，不允许使用负值；spread：可选参数，设置阴影的尺寸；color：可选参数，设置阴影的颜色；inset：可选参数，将默认的外部阴影(outset)改为内部阴影。提示：与text-shadow属性相似，box-shadow属性也可以同时设定多组阴影效果，每组之间使用逗号分隔，定义的多组阴影效果会按照定义顺序依次罗列，第一个阴影在最上面，以此类推。box-shadow:0px0px0px3px#bb0a0a,0px0px0px6px#2e56bf,0px0px0px9px#ea982e;border-image（边框图片）对于元素的边框除了可以使用一些默认样式外，还可以通过CSS3中的border-image属性使用图像来作为元素的边框，以创建出丰富多彩边框效果。border-image属性可以通过一些简单的规则，将一副图像划分为9个单独的部分，浏览器会自动使用相应的部分来替换边框的默认样式。border-image属性是五个border-image-*属性的简写border-image：border-image-source||border-image-slice[/border-image-width|/border-image-width?/border-image-outset]?||border-image-repeatborder-image-source：定义边框图像的路径；border-image-slice：定义边框图像从什么位置开始分割；border-image-width：定义边框图像的厚度（宽度）；border-image-outset：定义边框图像的外延尺寸（边框图像区域超出边框的量）；border-image-repeat：定义边框图像的平铺方式。border-image-sourceborder-image-source属性用来定义边框要使用的图像，通过该属性可以指定一个图像来替换边框的默认样式，当border-image-source属性的值为none或者指定的图像不可用时，则会显示边框默认的样式。另外，border-image-source属性除了可以使用图像来替换边框的默认样式外，您还可以使用渐变来定义边框样式border-image-source：none|&lt;image&gt;none为border-image-source属性的默认值，表示不使用图像来替换边框的默认样式；为使用url()函数指定的图像路径或者使用linear-gradient()函数定义的渐变色，用来替换默认的边框样式。div{width:200px;border:27pxsolid;padding:10px;border-image-source:url(./border.png);}border-image-sliceborder-image-slice属性用来分割通过border-image-source属性加载的图像border-image-slice：[&lt;number&gt;|&lt;percentage&gt;]{1,4}&amp;&amp;fill?&lt;number&gt;：数值，用具体数值指定图像分割的位置，数值代表图像的像素位置或向量坐标，不允许负值；&lt;percentage&gt;：百分比，相对于图像尺寸的百分比，图像的宽度影响水平方向，高度影响垂直方向；fill：保留边框图像的中间部分。border-image-slice属性可以指定上、下、左、右四个方位来分割图像，并将图像分成4个角、4条边和中间区域等9个部份，中间区域始终是透明的（即没图像填充），除非加上关键字fill，除fill关键字外，border-image-slice属性可以接受1~4个参数值：如果提供全部四个参数值，那么将按上、右、下、左的顺序对图像进行分割；如果提供三个参数，那么第一个参数用于上方，第二个参数用于左、右两侧，第三个参数用于下方；如果提供两个参数，那么第一个参数用于上方和下方，第二个参数用于左、右两个；如果只提供一个参数，那么上、右、下、左都将使用该值进行分割。div{width:200px;border:27pxsolid;padding:10px;border-image-source:url(./border.png);border-image-slice:27;}border-image-outsetborder-image-outset属性用来定义图像边框相对于边框边界向外偏移的距离（使图像边框延伸到盒子模型以外）border-image-outset：[&lt;length&gt;|&lt;number&gt;]{1,4}&lt;length&gt;：用具体的数值加单位的形式指定图像边框向外偏移的距离，不允许为负值；&lt;number&gt;：用浮点数指定图像边框向外偏移的距离，该值表示border-width的倍数，例如值为2，则表示偏移量为2*border-width，不允许为负值。border-image-outset属性同样可以接受1~4个参数值：如果提供全部四个参数值，那么将按上、右、下、左的顺序作用于四边；如果提供三个参数值，那么第一个参数将用于上边框，第二个参数将用于左、右两个边框，第三个参数将用于下边框；如果提供两个参数，那么第一个参数将用于上、下两个边框，第二个参数将用于左、右两个边框；如果只提供一个参数，那么该参数将同时作用于四边。div{width:200px;border:27pxsolid;padding:10px;margin:30px0px0px30px;border-image-source:url(./border.png);border-image-slice:27;border-image-outset:25px;background-color:#CCC;}border-image-repeatborder-image-repeat属性用来设置如何填充使用border-image-slice属性分割的图像边框，例如平铺、拉伸等等border-image-repeat：[stretch|repeat|round|space]{1,2}stretch：将被分割的图像使用拉伸的方式来填充满边框区域；repeat：将被分割的图像使用重复平铺的方式来填充满边框区域，当图像碰到边界时，超出的部分会被截断；round：与repeat关键字类似，不同之处在于，当背景图像不能以整数次平铺时，会根据情况缩放图像；space：与repeat关键字类似，不同之处在于，当背景图像不能以整数次平铺时，会用空白间隙填充在图像周围。div{width:200px;border:27pxsolid;padding:10px;border-image-source:url(./border.png);border-image-slice:27;border-image-repeat:roundrepeat;}border-imageborder-image属性是五个border-image-*属性的简写，通过border-image属性可以同时设置五个border-image-*属性。div{width:200px;border:27pxsolid;padding:10px;border-image:url(./border.png)27round;}","link":"https://18279493170.github.io/0IeaZW0Wx/"},{"title":"css之伪类伪类与伪元素","content":"伪类选择器伪类是W3C制定的一套选择器的特殊状态，通过伪类您可以设置元素的动态状态，例如悬停（hover）、点击（active）以及文档中不能通过其它选择器选择的元素（这些元素没有ID或class属性），例如第一个子元素（first-child）或者最后一个子元素（last-child）伪类的名称不区分大小写，但需要以冒号:开头。另外，伪类需要与CSS中的选择器结合使用selector:pseudo-class{property:value;}selector为选择器名称，pseudo-class为伪类的名称SS中提供了各种各样的伪类选择器例子例子描述:activea:active匹配被点击的链接:checkedinput:checked匹配处于选中状态的&lt;input&gt;元素:disabledinput:disabled匹配每个被禁用的&lt;input&gt;元素:emptyp:empty匹配任何没有子元素的&lt;p&gt;元素:enabledinput:enabled匹配每个已启用的&lt;input&gt;元素:first-childp:first-child匹配父元素中的第一个子元素&lt;p&gt;，&lt;p&gt;必须是父元素中的第一个子元素:first-of-typep:first-of-type匹配父元素中的第一个&lt;p&gt;元素:focusinput:focus匹配获得焦点的&lt;input&gt;元素:hovera:hover匹配鼠标悬停其上的元素:in-rangeinput:in-range匹配具有指定取值范围的&lt;input&gt;元素:invalidinput:invalid匹配所有具有无效值的&lt;input&gt;元素:lang(language)p:lang(it)匹配每个lang属性值以&quot;it&quot;开头的&lt;p&gt;元素:last-childp:last-child匹配父元素中的最后一个子元素&lt;p&gt;，&lt;p&gt;必须是父元素中的最后一个子元素:last-of-typep:last-of-type匹配父元素中的最后一个&lt;p&gt;元素:linka:link匹配所有未被访问的链接:not(selector):not(p)匹配每个非&lt;p&gt;元素的元素:nth-child(n)p:nth-child(2)匹配父元素中的第二个子元素&lt;p&gt;:nth-last-child(n)p:nth-last-child(2)匹配父元素的倒数第二个子元素&lt;p&gt;:nth-last-of-type(n)p:nth-last-of-type(2)匹配父元素的倒数第二个子元素&lt;p&gt;:nth-of-type(n)p:nth-of-type(2)匹配父元素的第二个子元素&lt;p&gt;:only-of-typep:only-of-type匹配父元素中唯一的&lt;p&gt;元素:only-childp:only-child匹配父元素中唯一的子元素&lt;p&gt;:optionalinput:optional匹配不带&quot;required&quot;属性的&lt;input&gt;元素:out-of-rangeinput:out-of-range匹配值在指定范围之外的&lt;input&gt;元素:read-onlyinput:read-only匹配指定了&quot;readonly&quot;属性的&lt;input&gt;元素:read-writeinput:read-write匹配不带&quot;readonly&quot;属性的&lt;input&gt;元素:requiredinput:required匹配指定了&quot;required&quot;属性的&lt;input&gt;元素:rootroot匹配元素的根元素，在HTML中，根元素永远是HTML:target#news:target匹配当前活动的#news元素（单击包含该锚名称的URL）:validinput:valid匹配所有具有有效值的&lt;input&gt;元素:visiteda:visited匹配所有已经访问过的链接first-child伪类first-child能够匹配指定父元素下的第一个子元素，例如ulli:first-child能够匹配&lt;ul&gt;元素下的第一个&lt;li&gt;元素ulli:first-child{/*匹配&lt;ul&gt;下的第一个&lt;li&gt;标签*/color:red;}last-child与first-child类似，伪类last-child能够匹配指定父元素下的最后一个子元素，例如ulli:last-child能够匹配&lt;ul&gt;元素下的最后一个&lt;li&gt;元素ulli:last-child{/*匹配&lt;ul&gt;下的第一个&lt;li&gt;标签*/color:red;}nth-​​child伪类nth-​​child是CSS3中新增的，它可以匹配指定元素下的第n个子元素，例如ulli:nth-child(2)能够匹配&lt;ul&gt;元素下的第二个&lt;li&gt;元素ulli:nth-child(2){/*匹配&lt;ul&gt;下的第二个&lt;li&gt;标签*/color:red;}伪元素伪元素是一个附加在选择器末尾的关键词，通过伪元素您不需要借助元素的ID或class属性就可以对被选择元素的特定部分定义样式。例如通过伪元素您可以设置段落中第一个字母的样式，或者在元素之前、之后插入一些内容等等。在CSS1和CSS2中，伪元素的使用与伪类相同，都是使一个冒号:与选择器相连。但在CSS3中，将伪元素单冒号的使用方法改为了使用双冒号::，以此来区分伪类和伪元素。因此，建议在使用伪元素时使用双冒号而不是单冒号。selector::pseudo-element{property:value;}selector为选择器，pseudo-element为伪元素的名称，property为CSS中的属性，value为属性对应的值。注意：一个选择器中只能使用一个伪元素，而且伪元素必须紧跟在选择器之后。按照最新的W3C规范，在定义伪元素时您应该使用双冒号::而不是单个冒号:，以便区分伪类和伪元素。但由于旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都同时支持使用单冒号和双冒号两种方式来定义伪元素。CSS中提供了一系列的伪元素::afterp::after在每个&lt;p&gt;元素之后插入内容::beforep::before在每个&lt;p&gt;元素之前插入内容::first-letterp::first-letter匹配每个&lt;p&gt;元素中内容的首字母::first-linep::first-line匹配每个&lt;p&gt;元素中内容的首行::selectionp::selection匹配用户选择的元素部分::placeholderinput::placeholder匹配每个表单输入框（例如&lt;input&gt;）的placeholder属性::after伪元素::after能够在指定元素的后面插入一些内容，在::after中需要使用content属性来定义要追加的内容，而且在::after中必须定义content属性才会生效（没有需要插入的内容时可以将content属性的值定义为空&quot;&quot;）。p.one::after{content:&quot;&quot;;display:inline-block;width:50px;height:10px;background:blue;}p.two::after{content:&quot;要插入的内容&quot;;color:red;font-size:6px;}p.three::after{content:url('./smiley.gif');position:relative;top:8px;}::before伪元素::before能够在指定元素的前面插入一些内容。与::after相似，::before中也需要使用content属性来定义要追加的内容，而且在::before中必须定义content属性才会生效（没有需要插入的内容时可以将content属性的值定义为空&quot;&quot;）。p.one::before{content:&quot;&quot;;display:inline-block;width:50px;height:10px;background:blue;}p.two::before{content:&quot;要插入的内容&quot;;color:red;font-size:6px;}p.three::before{content:url('./smiley.gif');position:relative;top:8px;}::first-letter伪元素::first-letter用来设置指定元素中内容第一个字符的样式，通常用来配合font-size和float属性制作首字下沉效果。需要注意的是，伪元素::first-letter仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。p::first-letter{font-size:2em;color:blue;}::first-line伪元素::first-line用来设置指定元素中内容第一行的样式，与::first-letter类似，伪元素::first-line也仅可以用于块级元素，行内元素想要使用该伪元素，则需要先将其转换为块级元素。p::first-line{font-size:1.5em;color:blue;font-weight:bold;}::selection伪元素::selection用来设置对象被选中时的样式，需要注意的是，伪元素::selection中只能定义元素被选中时的color、background、cursor、outline以及text-shadow（IE11尚不支持定义该属性）等属性。p::selection{color:red;background-color:#CCC;}::placeholder伪元素::placeholder用来设置表单元素（、元素）的占位文本（通过HTML的placeholder属性设置的文本）input.text::placeholder{color:red;background-color:#CCC;}","link":"https://18279493170.github.io/uzflK-WHl/"},{"title":"html之其他标签","content":"其他标签本章介绍一些最新引入标准的标签。&lt;dialog&gt;基本用法&lt;dialog&gt;标签表示一个可以关闭的对话框。&lt;dialog&gt;Helloworld&lt;/dialog&gt;上面就是一个最简单的对话框。默认情况下，对话框是隐藏的，不会在网页上显示。如果要让对话框显示，必须加上open属性。&lt;dialogopen&gt;Helloworld&lt;/dialog&gt;上面代码会在网页显示一个方框，内容是Helloworld。&lt;dialog&gt;元素里面，可以放入其他HTML元素。&lt;dialogopen&gt;&lt;formmethod=&quot;dialog&quot;&gt;&lt;inputtype=&quot;text&quot;&gt;&lt;buttontype=&quot;submit&quot;value=&quot;foo&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/dialog&gt;上面的对话框里面，有一个输入框和提交按钮。注意，上例中&lt;form&gt;的method属性设为dialog，这时点击提交按钮，对话框就会消失。但是，表单不会提交到服务器，浏览器会将表单元素的returnValue属性设为Submit按钮的value属性（上例是foo）。JavaScriptAPI&lt;dialog&gt;元素的JavaScriptAPI提供Dialog.showModal()和Dialog.close()两个方法，用于打开/关闭对话框。constmodal=document.querySelector('dialog');//对话框显示，相当于增加open属性modal.showModal();//对话框关闭，相当于移除open属性modal.close();开发者可以提供关闭按钮，让其调用Dialog.close()方法，关闭对话框。Dialog.close()方法可以接受一个字符串作为参数，用于传递信息。&lt;dialog&gt;接口的returnValue属性可以读取这个字符串，否则returnValue属性等于提交按钮的value属性。modal.close('Accepted');modal.returnValue//&quot;Accepted&quot;Dialog.showModal()方法唤起对话框时，会有一个透明层，阻止用户与对话框外部的内容互动。CSS提供了一个Dialog元素的::backdrop伪类，用于选中这个透明层，因此可以编写样式让透明层变得可见。dialog{padding:0;border:0;border-radius:0.6rem;box-shadow:001emblack;}dialog::backdrop{/*makethebackdropasemi-transparentblack*/background-color:rgba(0,0,0,0.4);}上面代码不仅为&lt;dialog&gt;指定了样式，还将对话框的透明层变成了灰色透明。&lt;dialog&gt;元素还有一个Dialog.show()方法，也能唤起对话框，但是没有透明层，用户可以与对话框外部的内容互动。事件&lt;dialog&gt;元素有两个事件，可以监听。close：对话框关闭时触发cancel：用户按下esc键关闭对话框时触发如果希望用户点击透明层，就关闭对话框，可以用下面的代码。modal.addEventListener('click',(event)=&gt;{if(event.target===modal){modal.close('cancelled');}});&lt;details&gt;，&lt;summary&gt;基本用法&lt;details&gt;标签用来折叠内容，浏览器会折叠显示该标签的内容。&lt;details&gt;这是一段解释文本。&lt;/details&gt;上面的代码在浏览器里面，会折叠起来，显示Details，前面有一个三角形，就像下面这样。▶Details用户点击这段文本，折叠的文本就会展开，显示详细内容。▼Details这是一段解释文本。再点击一下，展开的文本又会重新折叠起来。&lt;details&gt;标签的open属性，用于默认打开折叠。&lt;detailsopen&gt;这是一段解释文本。&lt;/details&gt;上面代码默认打开折叠。&lt;summary&gt;标签用来定制折叠内容的标题。&lt;details&gt;&lt;summary&gt;这是标题&lt;/summary&gt;这是一段解释文本。&lt;/details&gt;上面的代码显示结果如下。▶这是标题点击后，展示的效果如下。▼这是标题这是一段解释文本。通过CSS设置summary::-webkit-details-marker，可以改变标题前面的三角箭头。summary::-webkit-details-marker{background:url(https://example.com/foo.svg);color:transparent;}下面的样式是另一种替换箭头的方法。summary::-webkit-details-marker{display:none;}summary:before{content:&quot;\\2714&quot;;color:#696f7c;margin-right:5px;}JavaScriptAPIDetails元素的open属性返回&lt;details&gt;当前是打开还是关闭。constdetails=document.querySelector('details');if(detail.open===true){//展开状态}else{//折叠状态}Details元素有一个toggle事件，打开或关闭折叠时，都会触发这个事件。details.addEventListener('toggle',event=&gt;{if(details.open){/*展开状况*/}else{/*折叠状态*/}});参考链接MeettheNewDialogElement,KeithJ.GrantThedialogelement:Thewaytocreatetomorrow’smodalwindows,AbhishekJakharDetails/SummaryistheEasiestWayEvertoMakeanAccordion,ChrisCoyier","link":"https://18279493170.github.io/GyXm8p-lS/"},{"title":"css之元素可见性，元素显示类型与元素堆叠","content":"visibility（元素可见性）CSS中的visibility属性用来设置元素是否可见，您可以将该属性与JavaScript一起使用，来创建非常复杂的菜单或网页布局，比如在网页中做一些测试题时您可以使用visibility属性将题目的答案或解析隐藏起来，需要时再将其展示出来。visible默认值，表示元素是可见的hidden隐藏元素collapse主要用来隐藏表格的行和列，隐藏的行或列所占的空间可以被其他表格内容使用；如果在其他元素上使用，其效果等同于“hidden”inherit从父元素继承visibility属性的值提示：visibility属性虽然会隐藏元素，但会保留元素在页面中所占的空间。如果您希望元素隐藏的同时又不占用页面空间的话，请使用display属性。visibility:visible;注意：对于隐藏的元素，虽然我们在页面中看不到了，但是源代码中仍然包含这些隐藏的内容，因此您尽量不要使用它来隐藏敏感信息，例如用户信息、密码等等。display（元素显示类型）display属性是CSS中最重要的属性之一，主要用来控制元素的布局，通过display属性您可以设置元素是否显示以及如何显示。根据元素类型的不同，每个元素都有一个默认的display属性值，例如&lt;div&gt;默认的display属性值为block（块级元素），而&lt;span&gt;默认的display属性值为inline（行内元素），您也可以手动将元素的display属性转换为其它值。none隐藏元素block将元素设置为块级元素inline将元素设置为内联元素list-item将元素设置为列表项目inline-block将元素设置为行内块元素table将元素设置为块元素级的表格（类似&lt;table&gt;）inline-table将元素设置为内联元素级的表格（类似&lt;table&gt;）table-caption将元素设置为表格的标题（类似&lt;caption&gt;）table-cell将元素设置为表格的单元格（类似&lt;td&gt;和&lt;th&gt;）table-row将元素设置为表格的行（类似&lt;tr&gt;）table-row-group将元素设置为表格的内容部分（类似&lt;tbody&gt;）table-column将元素设置为表格的列（类似&lt;col&gt;）table-column-group将元素设置为表格中一个或多个列的分组（类似&lt;colgroup&gt;）table-header-group将元素设置为表格的头部（类似&lt;thead&gt;）table-footer-group将元素设置为表格的脚（类似&lt;tfoot&gt;）boxCSS3中新增的属性值，表示将对象设置为弹性伸缩盒（伸缩盒的最老版本）inline-boxCSS3中新增的属性值，表示将对象设置为内联元素级的弹性伸缩盒（伸缩盒的最老版本）flexboxCSS3中新增的属性值，表示将对象设置为弹性伸缩盒（伸缩盒的过渡版本）inline-flexboxCSS3中新增的属性值，表示将对象设置为内联元素级的弹性伸缩盒（伸缩盒的过渡版本）flexCSS3中新增的属性值，表示将对象设置为弹性伸缩盒（伸缩盒的最新版本）inline-flexCSS3中新增的属性值，表示将对象设置为内联元素级的弹性伸缩盒（伸缩盒的最新版本）run-in根据上下文来决定将元素设置为块级元素或内联元素inherit从父元素继承display属性的值伸缩盒子（弹性盒子）是CSS3中一种新的布局模式，引入伸缩盒子的目的是提供一种更加有效的方式来对页面中的元素进行排列、对齐和分配空间，当页面需要适应不同的屏幕大小以及设备类型时这种布局方式能够确保元素拥有恰当尺寸和位置。display:nonedisplay的属性值none可以用来隐藏元素，与visibility:hidden;功能相似，不同的是display:none;在隐藏元素的同时，它还会将元素所占的位置一并隐藏。display:none;通常会与JavaScript结合使用来隐藏或显示某个元素functionchange_box(obj){varbox=document.getElementById('box');if(box.style.display=='none'){box.style.display=&quot;&quot;;obj.innerHTML=&quot;隐藏&quot;;}else{box.style.display=&quot;none&quot;;obj.innerHTML=&quot;显示&quot;;}}display:blockdisplay属性的属性值block可以将元素强制转换为块级元素display:block;display:inlinedisplay属性的属性值inline可以将元素强制转换为行内元素，让元素拥有行内元素的特性，例如可以与其他行内元素共享一行等display:inline;display:inline-blockdisplay属性的属性值inline-block可以将元素强制转换为行内块元素，inline-block既具有block能够设置宽高的特性又具有inline不独占一行的特性isplay:inline-block;z-index：元素堆叠通常我们可能会认为HTML网页是个二维的平面，因为页面中的文本、图像或者其它元素都是按照一定顺序排列在页面上的，每个元素之间都有一定的间隙，不会重叠。然而，实际的网页其实是三维的，元素之间可能会发生堆叠（重叠），您可以通过CSS中的z-index属性来设置元素的堆叠顺序每个元素都有一个默认的z-index属性，将z-index属性与position属性相结合可以创建出类似PhotoShop中的图层效果。z-index属性可以设置元素的层叠级别（当元素出现重叠时，该元素在其它元素之上还是之下），拥有更高层叠级别的元素会处于层叠级别较低的元素的前面（或者说上面）通过z-index属性您可以创建更加复杂的网页布局auto默认值，堆叠顺序与父元素相等number使用具体数值（整数）设置元素的堆叠顺序inherit从父元素继承z-index属性的值对于未设置position属性的元素或者position属性的值为static时，后定义的元素会覆盖前面的元素；对于设置有position属性且属性值不为static的元素，这些元素会覆盖没有设置position属性或者position属性值为static的元素；对于position属性值不为static且定义了z-index属性的元素，z-index属性值大的元素会覆盖z-index属性值小的元素，即z-index属性值越大优先级越高，若z-index属性值相同，则后定义的元素会覆盖前面定义的元素；z-index属性仅在元素定义了position属性且属性值不为static时才有效。.box-x{width:150px;height:350px;border:1pxdashedred;background-color:rgba(255,153,153,0.7);float:left;}.box-y{width:300px;height:120px;border:1pxdashedgreen;background-color:rgba(179,255,153,0.7);}.one{position:absolute;top:5px;left:5px;z-index:4;}.two{position:relative;top:30px;left:80px;z-index:3;}.three{position:relative;top:-10px;left:120px;z-index:2;}.four{position:absolute;top:5px;right:5px;z-index:1;}.five{margin-left:100px;margin-top:-50px;background-color:rgba(255,255,153,0.7);z-index:5;}","link":"https://18279493170.github.io/iswsKEydE/"},{"title":"CSS之精灵图，计数器与定位","content":"精灵图（Sprite）当用户访问一个网站时，浏览器会向服务器发送一系列请求，比如说网页上的每张图像都需要经过一次请求才能最终展示给用户。然而，一个网页中往往包含大量的图像资源（例如在页面中展示的图片、网页的背景图像以及一些装饰性的图像等），这就会导致浏览器频繁的请求服务器，大大降低网页的加载速度。为了有效的减少请求服务器的次数，提高页面加载的速度，就出现了CSSSprites技术，也被称为精灵技术。简单来讲，精灵技术就是一种处理网页背景图像的方式，它需要将一个页面中涉及到的所有或一部分较小的背景图像合并到一张较大的图片中，然后再将这个图片应用到网页种。通常情况下，我们只是将背景图像中那些较小的、零碎的图像集中到一个大的图像中，这个较大的图像被称为精灵图（也被称为雪碧图），如下图所示就是淘宝网上应用的一个精灵图：精灵图的使用也非常简单，只需要借助background或者background-position属性来定位背景图像的位置即可&lt;style&gt;ulli{float:left;width:30px;height:30px;list-style:none;margin:5px;border:1pxsolid#CCC;border-radius:6px;}ulli:nth-child(1){background:url(./sprite.png)no-repeat4px1px;}ulli:nth-child(2){background:url(./sprite.png)no-repeat-38px1px;}ulli:nth-child(3){background:url(./sprite.png)no-repeat-81px3px;}ulli:nth-child(4){background:url(./sprite.png)no-repeat-123px2px;}ulli:nth-child(5){background:url(./sprite.png)no-repeat-171px0px;}ulli:nth-child(6){background:url(./sprite.png)no-repeat-214px2px;}ulli:nth-child(7){background:url(./sprite.png)no-repeat-267px1px;}ulli:nth-child(8){background:url(./sprite.png)no-repeat2px-36px;}&lt;/style&gt;简单来说，精灵图就是一个大的背景图，您只需要使用background-position来移动背景图，从而只显示背景图的一部分。目前为止，精灵图发展的已经非常成熟，阿里巴巴、百度、谷歌、京东、淘宝等大型网站中都可以看到精灵图的影子，使用精灵图可以减少图片的体积，也可以显著的减少对服务器的请求次数，提高网页的加载速度。当然，使用精灵图也不是没有弊端，比如：在图片合并的时候，需要把多张图片有序的、合理的合并成一张图片，每个小图之间需要预留足够的空间；在宽屏或者高分辨率的屏幕下来自适应页面宽度时，如果图片不够宽，会出现背景断裂；精灵图在维护的时候比较麻烦，如果页面背景有少许改动，就需要修改整个精灵图。计数器CSS中的计数器类似于变量，可以实现简单的计数功能，并将结果显示在页面上，在早期的网站上应用比较广泛。要实现计数器需要用到以下几个属性：counter-reset：创建或者重置计数器；counter-increment：递增变量；content：插入生成的内容；counter()或counters()：将计数器的值添加到元素。初始化计数器要使用计数器首先需要使用counter-reset属性来创建一个计数器，这一过程便叫做初始化计数器counter-reset：none|[&lt;identifier&gt;&lt;integer&gt;]none：阻止计数器复位；&lt;identifier&gt;：定义计数器的名称；&lt;integer&gt;：定义计数器的起始值，默认值为0，可以为负值。计数器自增初始化计数器后，可以通过counter-increment属性来指定计数器何时自增counter-increment：none|[&lt;identifier&gt;&lt;integer&gt;]none：阻止计数器增加；：定义要自增的计数器名称；：定义计数器每次增加的数值，默认值为1，可以为负值。&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;body{counter-reset:chapter;}h5,h6{margin:5px05px;}h5{counter-reset:section;counter-increment:chapter;}h6{counter-increment:section;}h5:before{content:&quot;Chapter&quot;counter(chapter)&quot;.&quot;;}h6:before{content:counter(chapter)&quot;.&quot;counter(section)&quot;&quot;;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h5&gt;程序设计语言&lt;/h5&gt;&lt;h6&gt;HTMLandCSS&lt;/h6&gt;&lt;h6&gt;JavaScript&lt;/h6&gt;&lt;h6&gt;PHP&lt;/h6&gt;&lt;h6&gt;Java&lt;/h6&gt;&lt;h5&gt;数据库管理系统&lt;/h5&gt;&lt;h6&gt;MySQL&lt;/h6&gt;&lt;h6&gt;MariaDB&lt;/h6&gt;&lt;h6&gt;PostgreSQL&lt;/h6&gt;&lt;h6&gt;Oracle&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt;注意：在使用CSS计数器之前，必须使用counter-reset创建计数器。计数器嵌套另外，计数器还可以嵌套使用，而且使用counters()函数可以在不同级别的嵌套计数器之间插入一个字符串&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;ol{/*为每个ol元素创建新的计数器实例*/counter-reset:ol-list;list-style-type:none;}li:before{/*只增加计数器的当前实例*/counter-increment:ol-list;/*为所有计数器实例增加以“.”分隔的值*/content:counters(ol-list,&quot;.&quot;)&quot;、&quot;;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ol&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;ol&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;ol&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;item&lt;ol&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt;position定位CSS中的position属性用来设置元素在页面中的位置，通过该属性您可以把任何属性放置在任何您认为合适的位置。position属性有5个可选值，分别对应5种不同的定位方式static默认值，静态定位，表示没有定位，元素会按照正常的位置显示，此时top、bottom、left和right4个定位属性也不会被应用。relative相对定位，即相对于元素的正常位置进行定位，您可以通过top、right、bottom、left这4个属性来设置元素相对于正常位置的偏移量，在此过程中不会对其它元素造成影响。absolute绝对定位，相对于第一个非static定位的父级元素进行定位，可以通过top、right、bottom、left这4个属性来设置元素相对于父级元素位置的偏移量。如果没有满足条件的父级元素，则会相对于浏览器窗口来进行定位。使用绝对定位的元素不会对其它元素造成影响。fixed固定定位，相对于浏览器的创建进行定位，可以使用top、right、bottom、left这4个属性来定义元素相对于浏览器窗口的位置。使用固定定位的元素无论如何滚动浏览器窗口元素的位置都是固定不变的。sticky粘性定位，它是relative和fixed的结合体，能够实线类似吸附的效果，当滚动页面时它的效果与relative相同，当要滚动到屏幕之外时则会自动变成fixed的效果。静态定位：staticstatic是position属性的默认值，表示没有定位，使用静态定位的元素会按照元素正常的位置显示，并且不会受到top、bottom、left、right和z-index属性的影响position:static;相对定位：relative相对定位就是元素相对于自己默认的位置来进行位置上的调整，您可以通过top、bottom、left和right四个属性的组合来设置元素相对于默认位置在不同方向上的偏移量。position:relative;top:25px;left:10px;注意：相对定位的元素可以移动并与其他元素重叠，但会保留元素默认位置处的空间。绝对定位：absolute绝对定位就是元素相对于第一个非静态定位（static）的父级元素进行定位，如果找不到符合条件的父级元素则会相对与浏览器窗口来进行定位。您同样可以使用top、bottom、left和right四个属性来设置元素相对于父元素或浏览器窗口不同方向上的偏移量。使用绝对定位的元素会脱离原来的位置，不再占用网页上的空间。与相对定位相同，使用绝对定位的元素同样会与页面中的其它元素发声重叠，另外使用绝对定位的元素可以有外边距，并且外边距不会与其它元素的外边距发生重叠。div{border:1pxsolidblack;position:relative;}div.static{position:absolute;bottom:10px;right:5px;}固定定位：fixed固定定位就是将元素相对于浏览器窗口进行定位，使用固定定位的元素不会因为浏览器窗口的滚动而移动，就像是固定在了页面上一样，我们经常在网页上看到的返回顶部按钮就是使用固定定位实现的。position:fixed;right:20px;bottom:20px;粘性定位：sticky粘性定位与前面介绍的四种定位方式不太一下，它像是相对定位和固定定位的结合体，当滚动页面时它的效果与相对定位相同，当元素滚动到一定程度时它又会呈现出固定定位的效果。比如一些网页上的导航菜单，当页面加载完成时它在自己默认的位置，当我们向下滚动页面时它又会固定在页面的最顶端。&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div{height:500px;position:relative;}p{width:100%;height:50px;margin:0;text-align:center;line-height:50px;background-color:#CCC;}p.sticky{background-color:blue;position:sticky;top:0px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;p&gt;2&lt;/p&gt;&lt;pclass=&quot;sticky&quot;&gt;position:sticky;&lt;/p&gt;&lt;p&gt;4&lt;/p&gt;&lt;p&gt;5&lt;/p&gt;&lt;p&gt;6&lt;/p&gt;&lt;p&gt;7&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;在使用粘性定位时，需要注意以下几点：在设置position:sticky;时，必须再定义top、bottom、right、left四个属性之一，否则只会处于相对定位；使用固定定位元素的父元素不能定义overflow:hidden或者overflow:auto属性；父元素的高度不能低于固定定位元素的高度；固定定位的元素仅在其父元素内有效。","link":"https://18279493170.github.io/l5s4wiXV_/"},{"title":"html之表单标签","content":"表单标签表单（form）是用户输入信息与网页互动的一种形式。大多数情况下，用户提交的信息会发给服务器，比如网站的搜索栏就是表单。表单由一种或多种的小部件组成，比如输入框、按钮、单选框或复选框。这些小部件称为控件（controls）。&lt;form&gt;简介&lt;form&gt;标签用来定义一个表单，所有表单内容放到这个容器元素之中。&lt;form&gt;&lt;!--各种表单控件--&gt;&lt;/form&gt;上面代码就是表单的基本形式。下面是一个比较常见的例子。&lt;formaction=&quot;https://example.com/api&quot;method=&quot;post&quot;&gt;&lt;labelfor=&quot;POST-name&quot;&gt;用户名：&lt;/label&gt;&lt;inputid=&quot;POST-name&quot;type=&quot;text&quot;name=&quot;user&quot;&gt;&lt;inputtype=&quot;submit&quot;value=&quot;提交&quot;&gt;&lt;/form&gt;上面代码就是一个表单，一共包含三个控件：一个&lt;label&gt;标签，一个文本输入框，一个提交按钮。其中，文本输入框的name属性是user，表示将向服务器发送一个键名为user的键值对，键值就是这个控件的value属性，等于用户输入的值。用户在文本输入框里面，输入用户名，比如foobar，然后点击提交按钮，浏览器就会向服务器https://example.com/api发送一个POST请求，发送user=foobar这样一段数据。&lt;form&gt;有以下属性。accept-charset：服务器接受的字符编码列表，使用空格分隔，默认与网页编码相同。action：服务器接收数据的URL。autocomplete：如果用户没有填写某个控件，浏览器是否可以自动填写该值。它的可能取值分别为off（不自动填写）和on（自动填写）。method：提交数据的HTTP方法，可能的值有post（表单数据作为HTTP数据体发送），get（表单数据作为URL的查询字符串发送），dialog（表单位于&lt;dialog&gt;内部使用）。enctype：当method属性等于post时，该属性指定提交给服务器的MIME类型。可能的值为application/x-www-form-urlencoded（默认值），multipart/form-data（文件上传的情况），text/plain。name：表单的名称，应该在网页中是唯一的。注意，如果一个控件没有设置name属性，那么这个控件的值就不会作为键值对，向服务器发送。novalidate：布尔属性，表单提交时是否取消验证。target：在哪个窗口展示服务器返回的数据，可能的值有_self（当前窗口），_blank（新建窗口），_parent（父窗口），_top（顶层窗口），&lt;iframe&gt;标签的name属性（即表单返回结果展示在&lt;iframe&gt;窗口）。enctype属性&lt;form&gt;表单的enctype属性，指定了采用POST方法提交数据时，浏览器给出的数据的MIME类型。该属性可以取以下值。（1）application/x-www-form-urlencodedapplication/x-www-form-urlencoded是默认类型，控件名和控件值都要转义（空格转为+号，非数字和非字母转为%HH的形式，换行转为CRLF），控件名和控件值之间用=分隔。控件按照出现顺序排列，控件之间用&amp;分隔。（2）multipart/form-datamultipart/form-data主要用于文件上传。这个类型上传大文件时，会将文件分成多块传送，每一块的HTTP头信息都有Content-Disposition属性，值为form-data，以及一个name属性，值为控件名。Content-Disposition:form-data;name=&quot;mycontrol&quot;下面是上传文件的表单。&lt;formaction=&quot;https://example.com/api&quot;enctype=&quot;multipart/form-data&quot;method=&quot;post&quot;&gt;用户名：&lt;inputtype=&quot;text&quot;name=&quot;submit-name&quot;&gt;&lt;br&gt;文件：&lt;inputtype=&quot;file&quot;name=&quot;files&quot;&gt;&lt;br&gt;&lt;inputtype=&quot;submit&quot;value=&quot;上传&quot;&gt;&lt;inputtype=&quot;reset&quot;value=&quot;清除&quot;&gt;&lt;/form&gt;上面代码中，输入用户名Larry，选中一个file1.txt文件，然后点击“上传”。浏览器发送的实际数据如下。Content-Type:multipart/form-data;boundary=--AaB03x--AaB03xContent-Disposition:form-data;name=&quot;submit-name&quot;Larry--AaB03xContent-Disposition:form-data;name=&quot;files&quot;;filename=&quot;file1.txt&quot;Content-Type:text/plain...contentsoffile1.txt...--AaB03x--上面代码中，浏览器将这个表单发成多个数据块。最上面使用Content-Type字段告诉服务器，数据格式是multipart/form-data（即多个数据块），每个数据块的分隔标志是--AaB03x。每个数据块的第一行是Content-Disposition，其中的name字段表示这个数据块的控件名，数据体则是该控件的数据值，比如第一个数据块的name属性是submit-name控件，数据体是该控件的值Larry。第二个数据块是控件files，由于该控件是上传文件，所以还要用filename属性给出文件名file1.txt，数据体是file1.txt的内容。&lt;fieldset&gt;，&lt;legend&gt;&lt;fieldset&gt;标签是一个块级容器标签，表示控件的集合，用于将一组相关控件组合成一组。&lt;form&gt;&lt;fieldset&gt;&lt;p&gt;年龄：&lt;inputtype=&quot;text&quot;name=&quot;age&quot;&gt;&lt;/p&gt;&lt;p&gt;性别：&lt;inputtype=&quot;text&quot;name=&quot;gender&quot;&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;/form&gt;上面代码中，两个输入框是一组，它们的外面会显示一个方框。&lt;fieldset&gt;有以下属性。disabled：布尔属性，一旦设置会使得&lt;fieldset&gt;内部包含的控件都不可用，都变成灰色状态。form：指定控件组所属的&lt;form&gt;，它的值等于&lt;form&gt;的id属性。name：该控件组的名称。&lt;legend&gt;标签用来设置&lt;fieldset&gt;控件组的标题，通常是&lt;fieldset&gt;内部的第一个元素，会嵌入显示在控件组的上边框里面。&lt;fieldset&gt;&lt;legend&gt;学生情况登记&lt;/legend&gt;&lt;p&gt;年龄：&lt;inputtype=&quot;text&quot;name=&quot;age&quot;&gt;&lt;/p&gt;&lt;p&gt;性别：&lt;inputtype=&quot;text&quot;name=&quot;gender&quot;&gt;&lt;/p&gt;&lt;/fieldset&gt;上面代码中，这个控件组的标题会，嵌入显示在&lt;fieldset&gt;的上边框。&lt;label&gt;&lt;label&gt;标签是一个行内元素，提供控件的文字说明，帮助用户理解控件的目的。&lt;labelfor=&quot;user&quot;&gt;用户名：&lt;/label&gt;&lt;inputtype=&quot;text&quot;name=&quot;user&quot;id=&quot;user&quot;&gt;上面代码中，输入框前面会有文字说明“用户名：”。&lt;label&gt;的一大优势是增加了控件的可用性。有些控件比较小（比如单选框），不容易点击，那么点击对应的&lt;label&gt;标签，也能选中该控件。点击&lt;label&gt;，就相当于控件本身的click事件。&lt;label&gt;的for属性关联相对应的控件，它的值是对应控件的id属性。所以，控件最好设置id属性。控件也可以放在&lt;label&gt;之中，这时不需要for属性和id属性。&lt;label&gt;用户名：&lt;inputtype=&quot;text&quot;name=&quot;user&quot;&gt;&lt;/label&gt;&lt;label&gt;的属性如下。for：关联控件的id属性。form：关联表单的id属性。设置了该属性后，&lt;label&gt;可以放置在页面的任何位置，否则只能放在&lt;form&gt;内部。一个控件可以有多个关联的&lt;label&gt;标签。&lt;labelfor=&quot;username&quot;&gt;用户名：&lt;/label&gt;&lt;inputtype=&quot;text&quot;id=&quot;username&quot;name=&quot;username&quot;&gt;&lt;labelfor=&quot;username&quot;&gt;&lt;abbrtitle=&quot;required&quot;&gt;*&lt;/abbr&gt;&lt;/label&gt;上面代码中，&lt;input&gt;有两个关联的&lt;label&gt;。&lt;input&gt;简介&lt;input&gt;标签是一个行内元素，用来接收用户的输入。它是一个单独使用的标签，没有结束标志。它有多种类型，取决于type属性的值，默认值是text，表示一个输入框。&lt;input&gt;&lt;!--等同于--&gt;&lt;inputtype=&quot;text&quot;&gt;上面代码会生成一个单行的输入框，用户可以在里面输入文本。&lt;input&gt;的属性非常多，有些属性是某个类型专用的，放在下文的“类型”部分介绍。这里介绍一些所有类型的共同属性。autofocus：布尔属性，是否在页面加载时自动获得焦点。disabled：布尔属性，是否禁用该控件。一旦设置，该控件将变灰，用户可以看到，但是无法操作。form：关联表单的id属性。设置了该属性后，控件可以放置在页面的任何位置，否则只能放在&lt;form&gt;内部。list：关联的&lt;datalist&gt;的id属性，设置该控件相关的数据列表，详见后文。name：控件的名称，主要用于向服务器提交数据时，控件键值对的键名。注意，只有设置了name属性的控件，才会向服务器提交，不设置就不会提交。readonly：布尔属性，是否为只读。required：布尔属性，是否为必填。type：控件类型，详见下文。value：控件的值。类型type属性决定了&lt;input&gt;的形式。该属性可以取以下值。（1）texttype=&quot;text&quot;是普通的文本输入框，用来输入单行文本。如果用户输入换行符，换行符会自动从输入中删除。&lt;inputtype=&quot;text&quot;id=&quot;name&quot;name=&quot;name&quot;requiredminlength=&quot;4&quot;maxlength=&quot;8&quot;size=&quot;10&quot;&gt;text输入框有以下配套属性。maxlength：可以输入的最大字符数，值为一个非负整数。minlength：可以输入的最小字符数，值为一个非负整数，且必须小于maxlength。pattern：用户输入必须匹配的正则表达式，比如要求用户输入4个～8个英文字符，可以写成pattern=&quot;[a-z]{4,8}&quot;。如果用户输入不符合要求，浏览器会弹出提示，不会提交表单。placeholder：输入字段为空时，用于提示的示例值。只要用户没有任何字符，该提示就会出现，否则会消失。readonly：布尔属性，表示该输入框是只读的，用户只能看，不能输入。size：表示输入框的显示长度有多少个字符宽，它的值是一个正整数，默认等于20。超过这个数字的字符，必须移动光标才能看到。spellcheck：是否对用户输入启用拼写检查，可能的值为true或false。（2）searchtype=&quot;search&quot;是一个用于搜索的文本输入框，基本等同于type=&quot;text&quot;。某些浏览器会在输入的时候，在输入框的尾部显示一个删除按钮，点击就会删除所有输入，让用户从头开始输入。下面是一个例子。&lt;form&gt;&lt;inputtype=&quot;search&quot;id=&quot;mySearch&quot;name=&quot;q&quot;placeholder=&quot;输入搜索词……&quot;required&gt;&lt;inputtype=&quot;submit&quot;value=&quot;搜索&quot;&gt;&lt;/form&gt;（3）buttontype=&quot;button&quot;是没有默认行为的按钮，通常脚本指定click事件的监听函数来使用。&lt;inputtype=&quot;button&quot;value=&quot;点击&quot;&gt;建议尽量不使用这个类型，而使用&lt;button&gt;标签代替，一则语义更清晰，二则&lt;button&gt;标签内部可以插入图片或其他HTML代码。（4）submittype=&quot;submit&quot;是表单的提交按钮。用户点击这个按钮，就会把表单提交给服务器。&lt;inputtype=&quot;submit&quot;value=&quot;提交&quot;&gt;如果不指定value属性，浏览器会在提交按钮上显示默认的文字，通常是Submit。该类型有以下配套属性，用来覆盖&lt;form&gt;标签的相应设置。formaction：提交表单数据的服务器URL。formenctype：表单数据的编码类型。formmethod：提交表单使用的HTTP方法（get或post）。formnovalidate：一个布尔值，表示数据提交给服务器之前，是否要忽略表单验证。formtarget：收到服务器返回的数据后，在哪一个窗口显示。（5）imagetype=&quot;image&quot;表示将一个图像文件作为提交按钮，行为和用法与type=&quot;submit&quot;完全一致。&lt;inputtype=&quot;image&quot;alt=&quot;登陆&quot;src=&quot;login-button.png&quot;&gt;上面代码中，图像文件是一个可以点击的按钮，点击后会提交数据到服务器。该类型有以下配套属性。alt：图像无法加载时显示的替代字符串。src：加载的图像URL。height：图像的显示高度，单位为像素。width：图像的显示宽度，单位为像素。formaction：提交表单数据的服务器URL。formenctype：表单数据的编码类型。formmethod：提交表单使用的HTTP方法（get或post）。formnovalidate：一个布尔值，表示数据提交给服务器之前，是否要忽略表单验证。formtarget：收到服务器返回的数据后，在哪一个窗口显示。用户点击图像按钮提交时，会额外提交两个参数x和y到服务器，表示鼠标的点击位置，比如x=52&amp;y=55。x是横坐标，y是纵坐标，都以图像左上角作为原点(0,0)。如果图像按钮设置了name属性，比如name=&quot;position&quot;，那么将以该值作为坐标的前缀，比如position.x=52&amp;position.y=55。这个功能通常用来地图类型的操作，让服务器知道用户点击了地图的哪个部分。（6）resettype=&quot;reset&quot;是一个重置按钮，用户点击以后，所有表格控件重置为初始值。&lt;inputtype=&quot;reset&quot;value=&quot;重置&quot;&gt;如果不设置value属性，浏览器会在按钮上面加上默认文字，通常是Reset。这个控件用处不大，用户点错了还会使得所有已经输入的值都被重置，建议不要使用。（7）checkboxtype=&quot;checkbox&quot;是复选框，允许选择或取消选择该选项。&lt;inputtype=&quot;checkbox&quot;id=&quot;agreement&quot;name=&quot;agreement&quot;checked&gt;&lt;labelfor=&quot;agreement&quot;&gt;是否同意&lt;/label&gt;上面代码会在文字前面，显示一个可以点击的选择框，点击可以选中，再次点击可以取消。上面代码中，checked属性表示默认选中。value属性的默认值是on。也就是说，如果没有设置value属性，以上例来说，选中复选框时，会提交agreement=on。如果没有选中，提交时不会有该项。多个相关的复选框，可以放在&lt;fieldset&gt;里面。&lt;fieldset&gt;&lt;legend&gt;你的兴趣&lt;/legend&gt;&lt;div&gt;&lt;inputtype=&quot;checkbox&quot;id=&quot;coding&quot;name=&quot;interest&quot;value=&quot;coding&quot;&gt;&lt;labelfor=&quot;coding&quot;&gt;编码&lt;/label&gt;&lt;/div&gt;&lt;div&gt;&lt;inputtype=&quot;checkbox&quot;id=&quot;music&quot;name=&quot;interest&quot;value=&quot;music&quot;&gt;&lt;labelfor=&quot;music&quot;&gt;音乐&lt;/label&gt;&lt;/div&gt;&lt;/fieldset&gt;上面代码中，如果用户同时选中两个复选框，提交的时候就会有两个name属性，比如interest=coding&amp;interest=music。（8）radiotype=&quot;radio&quot;是单选框，表示一组选择之中，只能选中一项。单选框通常为一个小圆圈，选中时会被填充或突出显示。&lt;fieldset&gt;&lt;legend&gt;性别&lt;/legend&gt;&lt;div&gt;&lt;inputtype=&quot;radio&quot;id=&quot;male&quot;name=&quot;gender&quot;value=&quot;male&quot;&gt;&lt;labelfor=&quot;male&quot;&gt;男&lt;/label&gt;&lt;/div&gt;&lt;div&gt;&lt;inputtype=&quot;radio&quot;id=&quot;female&quot;name=&quot;gender&quot;value=&quot;female&quot;&gt;&lt;labelfor=&quot;female&quot;&gt;女&lt;/label&gt;&lt;/div&gt;&lt;/fieldset&gt;上面代码中，性别只能在两个选项之中，选择一项。注意，多个单选框的name属性的值，应该都是一致的。提交到服务器的就是选中的那个值。该类型的配套属性如下。checked：布尔属性，表示是否默认选中当前项。value：用户选中该项时，提交到服务器的值，默认为on。（9）emailtype=&quot;email&quot;是一个只能输入电子邮箱的文本输入框。表单提交之前，浏览器会自动验证是否符合电子邮箱的格式，如果不符合就会显示提示，无法提交到服务器。&lt;inputtype=&quot;email&quot;pattern=&quot;.+@foobar.com&quot;size=&quot;30&quot;required&gt;上面代码会生成一个必填的文本框，只能输入后缀为foobar.com的邮箱地址。该类型有一个multiple的布尔属性，一旦设置，就表示该输入框可以输入多个逗号分隔的电子邮箱。&lt;inputid=&quot;emailAddress&quot;type=&quot;email&quot;multiplerequired&gt;注意，如果同时设置了multiple属性和required属性，零个电子邮箱是允许的，也就是该输入框允许为空。该类型的配套属性如下。maxlength：可以输入的最大字符数。minlength：可以输入的最少字符数。multiple：布尔属性，是否允许输入多个以逗号分隔的电子邮箱。pattern：输入必须匹配的正则表达式。placeholder：输入为空时的显示文本。readonly：布尔属性，该输入框是否只读。size：一个非负整数，表示输入框的显示长度为多少个字符。spellcheck：是否对输入内容启用拼写检查，可能的值为true或false。该类型还可以搭配&lt;datalist&gt;标签，提供输入的备选项。&lt;inputtype=&quot;email&quot;size=&quot;40&quot;list=&quot;defaultEmails&quot;&gt;&lt;datalistid=&quot;defaultEmails&quot;&gt;&lt;optionvalue=&quot;jbond007@mi6.defence.gov.uk&quot;&gt;&lt;optionvalue=&quot;jbourne@unknown.net&quot;&gt;&lt;optionvalue=&quot;nfury@shield.org&quot;&gt;&lt;optionvalue=&quot;tony@starkindustries.com&quot;&gt;&lt;optionvalue=&quot;hulk@grrrrrrrr.arg&quot;&gt;&lt;/datalist&gt;上面代码中，输入焦点进入输入框以后，会显示一个下拉列表，里面有五个参考项，供用户参考。（10）passwordtype=&quot;password&quot;是一个密码输入框。用户的输入会被遮挡，字符通常显示星号（*）或点（·）。&lt;inputtype=&quot;password&quot;id=&quot;pass&quot;name=&quot;password&quot;minlength=&quot;8&quot;required&gt;浏览器对该类型输入框的显示，会有所差异。一种常见的处理方法是，用户每输入一个字符，先在输入框里面显示一秒钟，然后再遮挡该字符。如果用户输入内容包含换行符（U+000A）和回车符（U+000D），浏览器会自动将这两个字符过滤掉。该类型的配套属性如下。maxlength：可以输入的最大字符数。minlength：可以输入的最少字符数。pattern：输入必须匹配的正则表达式。placeholder：输入为空时的显示文本。readonly：布尔属性，该输入框是否只读。size：一个非负整数，表示输入框的显示长度为多少个字符。autocomplete：是否允许自动填充，可能的值有on（允许自动填充）、off（不允许自动填充）、current-password（填入当前网站保存的密码）、new-password（自动生成一个随机密码）。inputmode：允许用户输入的数据类型，可能的值有none（不使用系统输入法）、text（标准文本输入）、decimal（数字，包含小数）、numeric（数字0-9）等。（11）filetype=&quot;file&quot;是一个文件选择框，允许用户选择一个或多个文件，常用于文件上传功能。&lt;inputtype=&quot;file&quot;id=&quot;avatar&quot;name=&quot;avatar&quot;accept=&quot;image/png,image/jpeg&quot;&gt;该类型有以下属性。accept：允许选择的文件类型，使用逗号分隔，可以使用MIME类型（比如image/jpeg），也可以使用后缀名（比如.doc），还可以使用audio/*（任何音频文件）、video/*（任何视频文件）、image/*（任何图像文件）等表示法。capture：用于捕获图像或视频数据的源，可能的值有user（面向用户的摄像头或麦克风），environment（外接的摄像头或麦克风）。multiple：布尔属性，是否允许用户选择多个文件。（12）hiddentype=&quot;hidden&quot;是一个不显示在页面的控件，用户无法输入它的值，主要用来向服务器传递一些隐藏信息。比如，CSRF攻击会伪造表单数据，那么使用这个控件，可以为每个表单生成一个独一无二的隐藏编号，防止伪造表单提交。&lt;inputid=&quot;prodId&quot;name=&quot;prodId&quot;type=&quot;hidden&quot;value=&quot;xm234jq&quot;&gt;上面这个控件，页面上是看不见的。用户提交表单的时候，浏览器会将prodId=xm234jq发给服务器。（13）numbertype=&quot;number&quot;是一个数字输入框，只能输入数字。浏览器通常会在输入框的最右侧，显示一个可以点击的上下箭头，点击向上箭头，数字会递增，点击向下箭头，数字会递减。&lt;inputtype=&quot;number&quot;id=&quot;tentacles&quot;name=&quot;tentacles&quot;min=&quot;10&quot;max=&quot;100&quot;&gt;上面代码指定数字输入框，最小可以输入10，最大可以输入100。该类型可以接受任何数值，包括小数和整数。可以通过step属性，限定只接受整数。该类型有以下配套属性。max：允许输入的最大数值。min：允许输入的最小数值。placeholder：用户输入为空时，显示的示例值。readonly：布尔属性，表示该控件是否为只读。step：点击向上和向下箭头时，数值每次递减的步长值。如果用户输入的值，不符合步长值的设定，浏览器会自动四舍五入到最近似的值。默认的步长值是1，如果初始的value属性设为1.5，那么点击向上箭头得到2.5，点击向下箭头得到0.5。（14）rangetype=&quot;range&quot;是一个滑块，用户拖动滑块，选择给定范围之中的一个数值。因为拖动产生的值是不精确的，如果需要精确数值，不建议使用这个控件。常见的例子是调节音量。&lt;inputtype=&quot;range&quot;id=&quot;start&quot;name=&quot;volume&quot;min=&quot;0&quot;max=&quot;11&quot;&gt;上面代码会产生一个最小值为0、最大值为11的滑块区域。用户拖动滑块，选择想要的音量。该类型的配套属性如下，用法与type=&quot;number&quot;一致。max：允许的最大值，默认为100。min：允许的最小值，默认为0。step：步长值，默认为1。value属性的初始值就是滑块的默认位置。如果没有设置value属性，滑块默认就会停在最大值和最小值中间。如果max属性、min属性、value属性都没有设置，那么value属性为50。该类型与&lt;datalist&gt;标签配合使用，可以在滑动区域产生刻度。&lt;inputtype=&quot;range&quot;list=&quot;tickmarks&quot;&gt;&lt;datalistid=&quot;tickmarks&quot;&gt;&lt;optionvalue=&quot;0&quot;label=&quot;0%&quot;&gt;&lt;optionvalue=&quot;10&quot;&gt;&lt;optionvalue=&quot;20&quot;&gt;&lt;optionvalue=&quot;30&quot;&gt;&lt;optionvalue=&quot;40&quot;&gt;&lt;optionvalue=&quot;50&quot;label=&quot;50%&quot;&gt;&lt;optionvalue=&quot;60&quot;&gt;&lt;optionvalue=&quot;70&quot;&gt;&lt;optionvalue=&quot;80&quot;&gt;&lt;optionvalue=&quot;90&quot;&gt;&lt;optionvalue=&quot;100&quot;label=&quot;100%&quot;&gt;&lt;/datalist&gt;上面代码会在0～100之间产生11个刻度。其中，0%、50%和100%三个位置会有文字提示，不过浏览器很可能不支持。注意，浏览器生成的都是水平滑块。如果想要生成垂直滑块，可以使用CSS改变滑块区域的方向。（15）urltype=&quot;url&quot;是一个只能输入网址的文本框。提交表单之前，浏览器会自动检查网址格式是否正确，如果不正确，就会无法提交。&lt;inputtype=&quot;url&quot;name=&quot;url&quot;id=&quot;url&quot;placeholder=&quot;https://example.com&quot;pattern=&quot;https://.*&quot;size=&quot;30&quot;required&gt;上面代码的pattern属性指定输入的网址只能使用HTTPS协议。注意，该类型规定，不带有协议的网址是无效的，比如foo.com是无效的，http://foo.com是有效的。该类型的配套属性如下。maxlength：允许的最大字符数。minlength：允许的最少字符串。pattern：输入内容必须匹配的正则表达式。placeholder：输入为空时显示的示例文本。readonly：布尔属性，表示该控件的内容是否只读。size：一个非负整数，表示该输入框显示宽度为多少个字符。spellcheck：是否启动拼写检查，可能的值为true（启用）和false（不启用）。该类型与&lt;datalist&gt;标签搭配使用，可以形成下拉列表供用户选择。随着用户不断键入，会缩小显示范围，只显示匹配的备选项。&lt;inputid=&quot;myURL&quot;name=&quot;myURL&quot;type=&quot;url&quot;list=&quot;defaultURLs&quot;&gt;&lt;datalistid=&quot;defaultURLs&quot;&gt;&lt;optionvalue=&quot;https://developer.mozilla.org/&quot;label=&quot;MDNWebDocs&quot;&gt;&lt;optionvalue=&quot;http://www.google.com/&quot;label=&quot;Google&quot;&gt;&lt;optionvalue=&quot;http://www.microsoft.com/&quot;label=&quot;Microsoft&quot;&gt;&lt;optionvalue=&quot;https://www.mozilla.org/&quot;label=&quot;Mozilla&quot;&gt;&lt;optionvalue=&quot;http://w3.org/&quot;label=&quot;W3C&quot;&gt;&lt;/datalist&gt;上面代码中，&lt;option&gt;的label属性表示文本标签，显示在备选下拉框的右侧，网址显示在左侧。（16）teltype=&quot;tel&quot;是一个只能输入电话号码的输入框。由于全世界的电话号码格式都不相同，因此浏览器没有默认的验证模式，大多数时候需要自定义验证。&lt;inputtype=&quot;tel&quot;id=&quot;phone&quot;name=&quot;phone&quot;pattern=&quot;[0-9]{3}-[0-9]{3}-[0-9]{4}&quot;required&gt;&lt;small&gt;Format:123-456-7890&lt;/small&gt;上面代码定义了一个只能输入10位电话号码的输入框。该类型的配套属性如下。maxlength：允许的最大字符数。minlength：允许的最少字符串。pattern：输入内容必须匹配的正则表达式。placeholder：输入为空时显示的示例文本。readonly：布尔属性，表示该控件的内容是否只读。size：一个非负整数，表示该输入框显示宽度为多少个字符。（17）colortype=&quot;color&quot;是一个选择颜色的控件，它的值一律都是#rrggbb格式。&lt;inputtype=&quot;color&quot;id=&quot;background&quot;name=&quot;background&quot;value=&quot;#e66465&quot;&gt;上面代码在Chrome浏览器中，会显示一个#e66465的色块。点击色块，就会出现一个拾色器，供用户选择颜色。如果没有指定value属性的初始值，默认值为#000000（黑色）。（18）datetype=&quot;date&quot;是一个只能输入日期的输入框，用户可以输入年月日，但是不能输入时分秒。输入格式是YYYY-MM-DD。&lt;inputtype=&quot;date&quot;id=&quot;start&quot;name=&quot;start&quot;value=&quot;2018-07-22&quot;min=&quot;2018-01-01&quot;max=&quot;2018-12-31&quot;&gt;上面代码会显示一个输入框，默认日期是2018年7月22日。用户点击以后，会日期选择器，供用户选择新的日期。该类型有以下配套属性。max：可以允许的最晚日期，格式为yyyy-MM-dd。min：可以允许的最早日期，格式为yyyy-MM-dd。step：步长值，一个数字，以天为单位。（19）timetype=&quot;time&quot;是一个只能输入时间的输入框，可以输入时分秒，不能输入年月日。日期格式是24小时制的hh:mm，如果包括秒数，格式则是hh:mm:ss。日期选择器的形式则随浏览器不同而不同。&lt;inputtype=&quot;time&quot;id=&quot;appt&quot;name=&quot;appt&quot;min=&quot;9:00&quot;max=&quot;18:00&quot;required&gt;&lt;small&gt;营业时间上午9点到下午6点&lt;/small&gt;该类型有以下配套属性。max：允许的最晚时间。min：允许的最早时间。readonly：布尔属性，表示用户是否不可以编辑时间。step：步长值，单位为秒。&lt;inputid=&quot;appt&quot;type=&quot;time&quot;name=&quot;appt&quot;step=&quot;2&quot;&gt;上面代码中，调节控件的话，时间每次改变的幅度是2秒钟。（20）monthtype=&quot;month&quot;是一个只能输入年份和月份的输入框，格式为YYYY-MM。&lt;inputtype=&quot;month&quot;id=&quot;start&quot;name=&quot;start&quot;min=&quot;2018-03&quot;value=&quot;2018-05&quot;&gt;该类型有以下配套属性。max：允许的最晚时间，格式为yyyy-MM。min：允许的最早时间，格式为yyyy-MM。readonly：布尔属性，表示用户是否不可以编辑时间。step：步长值，单位为月。（21）weektype=&quot;week&quot;是一个输入一年中第几周的输入框。格式为yyyy-Www，比如2018-W18表示2018年第18周。&lt;inputtype=&quot;week&quot;name=&quot;week&quot;id=&quot;camp-week&quot;min=&quot;2018-W18&quot;max=&quot;2018-W26&quot;required&gt;该类型有以下配套属性。max：允许的最晚时间，格式为yyyy-Www。min：允许的最早时间，格式为yyyy-Www。readonly：布尔属性，表示用户是否不可以编辑时间。step：步长值，单位为周。（22）datetime-localtype=&quot;datetime-local&quot;是一个时间输入框，让用户输入年月日和时分，格式为yyyy-MM-ddThh:mm。注意，该控件不支持秒。&lt;inputtype=&quot;datetime-local&quot;id=&quot;meeting-time&quot;name=&quot;meeting-time&quot;value=&quot;2018-06-12T19:30&quot;min=&quot;2018-06-07T00:00&quot;max=&quot;2018-06-14T00:00&quot;&gt;该类型有以下配套属性。max：允许的最晚时间，格式为yyyy-MM-ddThh:mm。min：允许的最早时间，格式为yyyy-MM-ddThh:mm。step：步长值，单位为秒，默认值是60。&lt;button&gt;&lt;button&gt;标签会生成一个可以点击的按钮，没有默认行为，通常需要用type属性或脚本指定按钮的功能。&lt;button&gt;点击&lt;/button&gt;上面代码会产生一个按钮，上面的文字就是“点击”。&lt;button&gt;内部不仅放置文字，还可以放置图像，这可以形成图像按钮。&lt;buttonname=&quot;search&quot;type=&quot;submit&quot;&gt;&lt;imgsrc=&quot;search.gif&quot;&gt;搜索&lt;/button&gt;&lt;button&gt;具有以下属性。autofocus：布尔属性，表示网页加载时，焦点就在这个按钮。网页里面只能有一个元素，具有这个属性。disabled：布尔属性，表示按钮不可用，会导致按钮变灰，不可点击。name：按钮的名称（与value属性配合使用），将以name=value的形式，随表单一起提交到服务器。value：按钮的值（与name属性配合使用），将以name=value的形式，随表单一起提交到服务器。type：按钮的类型，可能的值有三种：submit（点击后将数据提交给服务器），reset（将所有控件的值重置为初始值），button（没有默认行为，由脚本指定按钮的行为）。form：指定按钮关联的&lt;form&gt;表单，值为&lt;form&gt;的id属性。如果省略该属性，默认关联按钮所在父表单。formaction：数据提交到服务器的目标URL，会覆盖&lt;form&gt;元素的action属性。formenctype：数据提交到服务器的编码方式，会覆盖&lt;form&gt;元素的enctype属性。可能的值有三种：application/x-www-form-urlencoded（默认值），multipart/form-data（只用于文件上传），text/plain。formmethod：数据提交到服务器使用的HTTP方法，会覆盖&lt;form&gt;元素的method属性，可能的值为post或get。formnovalidate：布尔属性，数据提交到服务器时关闭本地验证，会覆盖&lt;form&gt;元素的novalidate属性。formtarget：数据提交到服务器后，展示服务器返回数据的窗口，会覆盖&lt;form&gt;元素的target属性。可能的值有_self（当前窗口），_blank（新的空窗口）、_parent（父窗口）、_top（顶层窗口）。&lt;select&gt;&lt;select&gt;标签用于生成一个下拉菜单。&lt;labelfor=&quot;pet-select&quot;&gt;宠物：&lt;/label&gt;&lt;selectid=&quot;pet-select&quot;name=&quot;pet-select&quot;&gt;&lt;optionvalue=&quot;&quot;&gt;--请选择一项--&lt;/option&gt;&lt;optionvalue=&quot;dog&quot;&gt;狗&lt;/option&gt;&lt;optionvalue=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;optionvalue=&quot;others&quot;&gt;其他&lt;/option&gt;&lt;/select&gt;上面代码中，&lt;select&gt;生成一个下拉菜单，菜单标题是“--请选择一项--”，最右侧有一个下拉箭头。点击下拉箭头，会显示三个菜单项，供用户点击选择。下拉菜单的菜单项由&lt;option&gt;标签给出，每个&lt;option&gt;代表可以选择的一个值。选中的&lt;option&gt;的value属性，就是&lt;select&gt;控件发送的服务器的值。&lt;option&gt;有一个布尔属性selected，一旦设置，就表示该项是默认选中的菜单项。&lt;selectname=&quot;choice&quot;&gt;&lt;optionvalue=&quot;first&quot;&gt;FirstValue&lt;/option&gt;&lt;optionvalue=&quot;second&quot;selected&gt;SecondValue&lt;/option&gt;&lt;optionvalue=&quot;third&quot;&gt;ThirdValue&lt;/option&gt;&lt;/select&gt;上面代码中，第二项SecondValue是默认选中的。页面加载的时候，会直接显示在下拉菜单上。&lt;select&gt;有如下属性。autofocus：布尔属性，页面加载时是否自动获得焦点。disabled：布尔属性，是否禁用当前控件。form：关联表单的id属性。multiple：布尔属性，是否可以选择多个菜单项。默认情况下，只能选择一项。一旦设置，多数浏览器会显示一个滚动列表框。用户可能需要按住Shift或其他功能键，选中多项。name：控件名。required：布尔属性，是否为必填控件。size：设置了multiple属性时，页面显示时一次可见的行数，其他行需要滚动查看。&lt;option&gt;，&lt;optgroup&gt;&lt;option&gt;标签用在&lt;select&gt;、&lt;optgroup&gt;、&lt;datalist&gt;里面，表示一个菜单项，参见&lt;select&gt;的示例。它有如下属性。disabled：布尔属性，是否禁用该项。label：该项的说明。如果省略，则等于该项的文本内容。selected：布尔属性，是否为默认值。显然，一组菜单中，只能有一个菜单项设置该属性。value：该项提交到服务器的值。如果省略，则等于该项的文本内容。&lt;optgroup&gt;表示菜单项的分组，通常用在&lt;select&gt;内部。&lt;label&gt;宠物：&lt;selectname=&quot;pets&quot;multiplesize=&quot;4&quot;&gt;&lt;optgrouplabel=&quot;四条腿的宠物&quot;&gt;&lt;optionvalue=&quot;dog&quot;&gt;狗&lt;/option&gt;&lt;optionvalue=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;/optgroup&gt;&lt;optgrouplabel=&quot;鸟类&quot;&gt;&lt;optionvalue=&quot;parrot&quot;&gt;鹦鹉&lt;/option&gt;&lt;optionvalue=&quot;thrush&quot;&gt;画眉&lt;/option&gt;&lt;/optgroup&gt;&lt;/select&gt;&lt;/label&gt;上面代码中，&lt;select&gt;是一个下拉菜单，它的内部使用&lt;optgroup&gt;将菜单项分成两组。每组有自己的标题，会加粗显示，但是用户无法选中。它的属性如下。disabled：布尔设置，是否禁用该组。一旦设置，该组所有的菜单项都不可选。label：菜单项分组的标题。&lt;datalist&gt;&lt;datalist&gt;标签是一个容器标签，用于为指定控件提供一组相关数据，通常用于生成输入提示。它的内部使用&lt;option&gt;，生成每个菜单项。&lt;labelfor=&quot;ice-cream-choice&quot;&gt;冰淇淋：&lt;/label&gt;&lt;inputtype=&quot;text&quot;list=&quot;ice-cream-flavors&quot;id=&quot;ice-cream-choice&quot;name=&quot;ice-cream-choice&quot;&gt;&lt;datalistid=&quot;ice-cream-flavors&quot;&gt;&lt;optionvalue=&quot;巧克力&quot;&gt;&lt;optionvalue=&quot;椰子&quot;&gt;&lt;optionvalue=&quot;薄荷&quot;&gt;&lt;optionvalue=&quot;草莓&quot;&gt;&lt;optionvalue=&quot;香草&quot;&gt;&lt;/datalist&gt;上面代码中，&lt;input&gt;生成一个文本输入框，用户可以输入文本。&lt;input&gt;的list属性指定关联的&lt;datalist&gt;的id属性。&lt;datalist&gt;的数据列表用于输入建议，用户点击输入框的时候，会显示一个下拉菜单，里面是建议的输入项。并且还会自动匹配用户已经输入的字符，缩小可选的范围，比如用户输入“香”，则只会显示“香草”这一项。注意，&lt;option&gt;在这里可以不需要闭合标签。&lt;option&gt;标签还可以加入label属性，作为说明文字。Chrome浏览器会将其显示在value的下一行。&lt;datalistid=&quot;ide&quot;&gt;&lt;optionvalue=&quot;Brackets&quot;label=&quot;byAdobe&quot;&gt;&lt;optionvalue=&quot;Coda&quot;label=&quot;byPanic&quot;&gt;&lt;/datalist&gt;上面代码的渲染结果是，Chrome浏览器会在下拉列表显示value值（比如Brackets），然后在其下方以小字显示label值（比如byAdobe）。&lt;textarea&gt;&lt;textarea&gt;是一个块级元素，用来生成多行的文本框。&lt;textareaid=&quot;story&quot;name=&quot;story&quot;rows=&quot;5&quot;cols=&quot;33&quot;&gt;这是一个很长的故事。&lt;/textarea&gt;上面代码会生成一个长度为5行，宽度为33个字符的文本框。该标签有如下属性。autofocus：布尔属性，是否自动获得焦点。cols：文本框的宽度，单位为字符，默认值为20。disabled：布尔属性，是否禁用该控件。form：关联表单的id属性。maxlength：允许输入的最大字符数。如果未指定此值，用户可以输入无限数量的字符。minlength：允许输入的最小字符数。name：控件的名称。placeholder：输入为空时显示的提示文本。readonly：布尔属性，控件是否为只读。required：布尔属性，控件是否为必填。rows：文本框的高度，单位为行。spellcheck：是否打开浏览器的拼写检查。可能的值有true（打开），default（由父元素或网页设置决定），false（关闭）。wrap：输入的文本是否自动换行。可能的值有hard（浏览器自动插入换行符CR+LF，使得每行不超过控件的宽度），soft（输入内容超过宽度时自动换行，但不会加入新的换行符，并且浏览器保证所有换行符都是CR+LR，这是默认值），off（关闭自动换行，单行长度超过宽度时，会出现水平滚动条）。&lt;output&gt;&lt;output&gt;标签是一个行内元素，用于显示用户操作的结果。&lt;inputtype=&quot;number&quot;name=&quot;a&quot;value=&quot;10&quot;&gt;+&lt;inputtype=&quot;number&quot;name=&quot;b&quot;value=&quot;10&quot;&gt;=&lt;outputname=&quot;result&quot;&gt;20&lt;/output&gt;该标签有如下属性。for：关联控件的id属性，表示为该控件的操作结果。form：关联表单的id属性。name：控件的名称。&lt;progress&gt;&lt;progress&gt;标签是一个行内元素，表示任务的完成进度。浏览器通常会将显示为进度条。&lt;progressid=&quot;file&quot;max=&quot;100&quot;value=&quot;70&quot;&gt;70%&lt;/progress&gt;该标签有如下属性。max：进度条的最大值，应该是一个大于0的浮点数。默认值为1。value：进度条的当前值。它必须是0和max属性之间的一个有效浮点数。如果省略了max属性，该值则必须在0和1之间。如果省略了value属性，则进度条会出现滚动，表明正在进行中，无法知道完成的进度。&lt;meter&gt;&lt;meter&gt;标签是一个行内元素，表示指示器，用来显示已知范围内的一个值，很适合用于任务的当前进度、磁盘已用空间、充电量等带有比例性质的场合。浏览器通常会将其显示为一个不会滚动的指示条。&lt;p&gt;烤箱的当前温度是&lt;metermin=&quot;200&quot;max=&quot;500&quot;value=&quot;350&quot;&gt;350度&lt;/meter&gt;。&lt;/p&gt;上面代码会显示一个指示条，左侧表示200，右侧表示500，当前位置停留在350。注意，&lt;meter&gt;元素的子元素，正常情况下不会显示。只有在浏览器不支持&lt;meter&gt;时才会显示。该标签有如下属性。min：范围的下限，必须小于max属性。如果省略，则默认为0。max：范围的上限，必须大于min属性。如果省略，则默认为1。value：当前值，必须在min属性和max属性之间。如果省略，则默认为0。low：表示“低端”的上限门槛值，必须大于min属性，小于high属性和max属性。如果省略，则等于min属性。high：表示“高端”的下限门槛值，必须小于max属性，大于low属性和min属性。如果省略，则等于max属性。optimum：指定最佳值，必须在min属性和max属性之间。它应该与low属性和high属性一起使用，表示最佳范围。如果optimum小于low属性，则表示“低端”是最佳范围；如果大于high属性，则表示“高端”是最佳范围；如果在low和high之间，则表示“中间地带”是最佳范围。如果省略，则等于min和max的中间值。form：关联表单的id属性。Chrome浏览器使用三种颜色，表示指示条所处的位置。较好情况时，当前位置为绿色；一般情况时，当前位置为黄色；较差情况时，当前位置为红色。&lt;meterid=&quot;fuel&quot;name=&quot;fuel&quot;min=&quot;0&quot;max=&quot;100&quot;low=&quot;33&quot;high=&quot;66&quot;optimum=&quot;80&quot;value=&quot;50&quot;&gt;at50/100&lt;/meter&gt;上面代码中，指示条可以分成三段：0～32，33～65，66～100。由于optimum属性是80，因此66～100是较好情况，33～65是一般情况，0～32是较差情况。浏览器因此会根据value属性，将当前位置显示为不同颜色，小于33时显示红色，大于65时显示绿色，两者之间显示黄色。","link":"https://18279493170.github.io/EFnTZ5ElP/"},{"title":"css之鼠标样式，轮廓与滚动条","content":"cursor（鼠标样式）在浏览网页的过程中，当我们将鼠标移动到一些元素上时，鼠标的样式会发生相应的改变，例如当鼠标指向文本时，鼠标的样式会变成类似大写字母I的样子；当鼠标指向链接时，鼠标会变成一个小手的形状等。除了这些默认的变化外，您还可以通过CSS中的cursor属性来改变网页中鼠标（光标）的样式auto默认值，由浏览器根据当前上下文确定要显示的光标样式default默认光标默认光标，不考虑上下文，通常是一个箭头none不显示光标initial将此属性设置为其默认值inherit从父元素基础cursor属性的值context-menu上下文菜单光标表示上下文菜单可用help帮助光标表示有帮助pointer指针光标表示一个链接progress进度游标进度指示器，表示程序正在执行一些处理，但是您仍然可以在该界面进行一些操作（与wait不同）wait等待光标表示程序繁忙，您应该等待程序指向完成cell单元游标表示可以选择一个单元格（或一组单元格）crosshair十字准线光标一个简单的十字准线text文字游标表示可以选择的文本vertical-text垂直文本光标表示可以选择的垂直文本alias别名光标表示要创建别名或快捷方式copy复制光标表示可以复制某些内容move移动光标表示可以移动鼠标下方的对象no-drop无丢游标表示所拖动的项目不能放置在当前位置not-allowed不允许的游标表示无法完成某事all-scroll全滚动光标表示对象可以沿任何方向滚动（平移）col-resize彩色游标表示可以水平调整列的大小row-resize行大小调整游标表示可以垂直调整行的大小n-resizeN尺寸游标表示对象的边缘可以向上（向北）移动e-resize电子调整游标表示对象的边缘可以向右（向东）移动s-resizeS调整游标表示对象的边缘可以向下（向南）移动w-resizeW尺寸游标表示对象的边缘可以向左（向西）移动ne-resizeNE调整大小的游标表示对象的边缘可以向上和向右（北/东）移动nw-resizeNW调整游标表示对象的边缘可以向上和向左（北/西）移动se-resizeSE调整游标表示对象的边缘可以向下和向右（向南/向东）移动sw-resizeSW调整游标表示对象的边缘可以向下和向左（南/西）移动ew-resizeEW调整游标表示可以双向调整对象大小的光标ns-resizeNS调整大小的游标nesw-resizeNESW调整大小的游标nwse-resizeNWSE调整大小的游标zoom-in放大光标表示可以放大某些内容zoom-out缩小光标表示可以缩小某些内容grab抓取光标表示可以抓取（拖动）某些东西grabbing抓取光标表示已经抓取到某些东西url(&quot;&quot;)自定义光标的样式，括号中的内容为光标图像的源文件路径提示：由于计算机系统的不同，鼠标的样式会存在一定的差异。cursor:cell;自定义光标样式除了可以使用上表中介绍的光标样式外，您也可以使用图像文件来自定义光标的样式cursor:url(&quot;custom.gif&quot;),url(&quot;custom.cur&quot;),default;您可以使用url()定义多个光标的样式文件，每个url()之间使用逗号,分隔，上面示例中custom.gif、custom.cur就是自定义的光标文件。需要注意的是，在自定义光标样式时，要在最后定义一个上表中的通用光标样式，防止使用url()中定义的光标图像资源失效。提示：.cur格式是光标文件的标准格式，您可以使用一些在线工具（例如https://convertio.co/zh/cur-converter/）将.jpg、.gif等格式的图像文件转换为.cur格式。outline（轮廓）轮廓（outline）是绘制于元素周围的一条线，位于边框的外围（紧贴着边框），主要用来突出显示某个元素轮廓和边框看起来非常相似，但它们之间也并非没有区别，例如：元素上下左右四个方向上边框的样式、宽度、颜色可以单独设置，而轮廓在元素四个方向的宽度、样式、颜色都是相同的，不能单独设置；边框的宽度会直接影响元素的尺寸，而轮廓不会占用页面空间，不会影响页面的布局，但是轮廓会与页面上的其它元素发声重叠；除了会与周围的元素发声重叠外，轮廓对周围的元素没有任何影响；边框是元素尺寸的一部分，而轮廓不是，也就是说无论轮廓的宽度是多少，元素的尺寸都不会改变；轮廓可以不是矩形的，但您不能直接创建圆形轮廓。outline-color：设置轮廓的颜色；outline-style：设置轮廓的样式；outline-width：设置轮廓的宽度；outline：轮廓的简写属性，可以使用outline属性中同时设置上面的三个轮廓属性；outline-offset：设置轮廓与边框之间的距离。outline-styleoutline-style属性可以设置轮廓得样式none默认值，没有轮廓dotted定义点状的轮廓dashed定义虚线轮廓solid定义实线轮廓double定义双实线轮廓，两条实线之间的宽度等同于outline-width的值groove定义3D凹槽轮廓，具体效果取决于outline-color的值ridge定义3D凸槽轮廓，具体效果取决于outline-color的值inset定义3D凹边轮廓，具体效果取决于outline-color的值outset定义3D凸边轮廓，具体效果取决于outline-color的值inherit从父元素继承轮廓样式的设置outline-style:dotted;注意：因为轮廓的默认样式为none，所以您必须指定轮廓的样式才可以使轮廓显示在元素周围。outline-widthoutline-width属性用来设置轮廓的宽度，只有当outline-style属性的值不为none时，outline-width属性才会生效thin设置较细的轮廓medium默认值，设置中等宽度的轮廓thick设置较粗的轮廓length使用具体数值加单位（px、em、cm等）的形式设置轮廓的宽度inherit从父元素继承轮廓的宽度outline-style:solid;outline-width:5px;outline-coloroutline-color属性用来设置轮廓的颜色color指定轮廓颜色，与使用color、border-color等属性设置颜色相同，您可以使用颜色名称、十六进制码和RGB值等形式定义具体颜色invert使用背景色的反色来设置轮廓的颜色，仅在IE和Opera浏览器下有效inherit从父元素继承轮廓颜色的设置注意：如果只设置outline-width或outline-color属性的话，轮廓的设置并不会生效。您必须使用outline-style属性设置了轮廓的样式之后，才可以使用outline-width和outline-color属性来设置轮廓的宽度和颜色。outline-style:solid;outline-width:5px;outline-color:red;outlineoutline属性是上述outline-width、outline-style、outline-color三个属性的简写形式，使用outline属性可以同时设置这三个属性中的一个或多个outline:outline-widthoutline-styleoutline-color;在使用outline属性时，outline-width、outline-style、outline-color这几个参数的顺序并不是固定的，您可以按照上面语法中介绍的顺序，也可以根据自己的喜好改变它们的顺序。outline:5pxinsetrgb(217,0,217);outline-offset默认情况下轮廓是紧贴着边框的，通过outline-offset属性可以设置轮廓与边框之间的距离length使用具体数值加单位的形式设置轮廓与边框之间的距离，可以为负值inherit从父元素继承outline-offset属性的值outline:6pxinset#AAA;outline-offset:10px;滚动条样式（overflow）页面中的每个元素都可以看作是一个矩形的盒子，我们可以使用CSS来控制盒子的大小、位置等等信息。默认情况下，当元素中的内容超出盒子的大小时，例如元素内容区的宽度和高度所组成的矩形区域中不足以容纳元素中的内容时，一部分内容就会溢出盒子。overflow为了能更好的处理溢出的内容，CSS中提供了一个名为overflow的属性，该属性可以设置如何处理溢出元素内容区的内容visible默认值，对溢出的内容不做处理，内容会在元素内容区之外显示hidden隐藏溢出元素内容区的内容scroll隐藏溢出元素内容区的内容，并在元素的左侧和下方分别创建一个滚动条，通过滑动滚动条可以查看元素中的所有内容auto如果出现内容溢出，则会在元素左侧创建一个滚动条，通过滑动滚动条可以查看元素中的全部内容inherit从父元素继承overflow属性的值overflow:scroll;overflow-x、overflow-y在CSS3中还提供了overflow-x和overflow-y两个属性，它们的作用与overflow属性相似，属性的可选值与overflow属性相同，其中：overflow-x：设置当元素内容区的内容在水平方向上溢出元素时如何处理溢出的内容；overflow-y​：设置当元素内容区的内容在垂直方向上溢出元素时如何处理溢出的内容。提示：当单独设置overflow-x或overflow-y其中的一个属性为非visible时，另外一个属性将自动设置为auto。另外，因为CSS3还没有最终定稿，所以这两个属性的作用可能会变更或调整。","link":"https://18279493170.github.io/css-zhi-shu-biao-yang-shi-lun-kuo-yu-gun-dong-tiao/"},{"title":"css之鼠标样式，轮廓与滚动条","content":"cursor（鼠标样式）在浏览网页的过程中，当我们将鼠标移动到一些元素上时，鼠标的样式会发生相应的改变，例如当鼠标指向文本时，鼠标的样式会变成类似大写字母I的样子；当鼠标指向链接时，鼠标会变成一个小手的形状等。除了这些默认的变化外，您还可以通过CSS中的cursor属性来改变网页中鼠标（光标）的样式auto默认值，由浏览器根据当前上下文确定要显示的光标样式default默认光标默认光标，不考虑上下文，通常是一个箭头none不显示光标initial将此属性设置为其默认值inherit从父元素基础cursor属性的值context-menu上下文菜单光标表示上下文菜单可用help帮助光标表示有帮助pointer指针光标表示一个链接progress进度游标进度指示器，表示程序正在执行一些处理，但是您仍然可以在该界面进行一些操作（与wait不同）wait等待光标表示程序繁忙，您应该等待程序指向完成cell单元游标表示可以选择一个单元格（或一组单元格）crosshair十字准线光标一个简单的十字准线text文字游标表示可以选择的文本vertical-text垂直文本光标表示可以选择的垂直文本alias别名光标表示要创建别名或快捷方式copy复制光标表示可以复制某些内容move移动光标表示可以移动鼠标下方的对象no-drop无丢游标表示所拖动的项目不能放置在当前位置not-allowed不允许的游标表示无法完成某事all-scroll全滚动光标表示对象可以沿任何方向滚动（平移）col-resize彩色游标表示可以水平调整列的大小row-resize行大小调整游标表示可以垂直调整行的大小n-resizeN尺寸游标表示对象的边缘可以向上（向北）移动e-resize电子调整游标表示对象的边缘可以向右（向东）移动s-resizeS调整游标表示对象的边缘可以向下（向南）移动w-resizeW尺寸游标表示对象的边缘可以向左（向西）移动ne-resizeNE调整大小的游标表示对象的边缘可以向上和向右（北/东）移动nw-resizeNW调整游标表示对象的边缘可以向上和向左（北/西）移动se-resizeSE调整游标表示对象的边缘可以向下和向右（向南/向东）移动sw-resizeSW调整游标表示对象的边缘可以向下和向左（南/西）移动ew-resizeEW调整游标表示可以双向调整对象大小的光标ns-resizeNS调整大小的游标nesw-resizeNESW调整大小的游标nwse-resizeNWSE调整大小的游标zoom-in放大光标表示可以放大某些内容zoom-out缩小光标表示可以缩小某些内容grab抓取光标表示可以抓取（拖动）某些东西grabbing抓取光标表示已经抓取到某些东西url(&quot;&quot;)自定义光标的样式，括号中的内容为光标图像的源文件路径提示：由于计算机系统的不同，鼠标的样式会存在一定的差异。cursor:cell;自定义光标样式除了可以使用上表中介绍的光标样式外，您也可以使用图像文件来自定义光标的样式cursor:url(&quot;custom.gif&quot;),url(&quot;custom.cur&quot;),default;您可以使用url()定义多个光标的样式文件，每个url()之间使用逗号,分隔，上面示例中custom.gif、custom.cur就是自定义的光标文件。需要注意的是，在自定义光标样式时，要在最后定义一个上表中的通用光标样式，防止使用url()中定义的光标图像资源失效。提示：.cur格式是光标文件的标准格式，您可以使用一些在线工具（例如https://convertio.co/zh/cur-converter/）将.jpg、.gif等格式的图像文件转换为.cur格式。outline（轮廓）轮廓（outline）是绘制于元素周围的一条线，位于边框的外围（紧贴着边框），主要用来突出显示某个元素轮廓和边框看起来非常相似，但它们之间也并非没有区别，例如：元素上下左右四个方向上边框的样式、宽度、颜色可以单独设置，而轮廓在元素四个方向的宽度、样式、颜色都是相同的，不能单独设置；边框的宽度会直接影响元素的尺寸，而轮廓不会占用页面空间，不会影响页面的布局，但是轮廓会与页面上的其它元素发声重叠；除了会与周围的元素发声重叠外，轮廓对周围的元素没有任何影响；边框是元素尺寸的一部分，而轮廓不是，也就是说无论轮廓的宽度是多少，元素的尺寸都不会改变；轮廓可以不是矩形的，但您不能直接创建圆形轮廓。outline-color：设置轮廓的颜色；outline-style：设置轮廓的样式；outline-width：设置轮廓的宽度；outline：轮廓的简写属性，可以使用outline属性中同时设置上面的三个轮廓属性；outline-offset：设置轮廓与边框之间的距离。outline-styleoutline-style属性可以设置轮廓得样式none默认值，没有轮廓dotted定义点状的轮廓dashed定义虚线轮廓solid定义实线轮廓double定义双实线轮廓，两条实线之间的宽度等同于outline-width的值groove定义3D凹槽轮廓，具体效果取决于outline-color的值ridge定义3D凸槽轮廓，具体效果取决于outline-color的值inset定义3D凹边轮廓，具体效果取决于outline-color的值outset定义3D凸边轮廓，具体效果取决于outline-color的值inherit从父元素继承轮廓样式的设置outline-style:dotted;注意：因为轮廓的默认样式为none，所以您必须指定轮廓的样式才可以使轮廓显示在元素周围。outline-widthoutline-width属性用来设置轮廓的宽度，只有当outline-style属性的值不为none时，outline-width属性才会生效thin设置较细的轮廓medium默认值，设置中等宽度的轮廓thick设置较粗的轮廓length使用具体数值加单位（px、em、cm等）的形式设置轮廓的宽度inherit从父元素继承轮廓的宽度outline-style:solid;outline-width:5px;outline-coloroutline-color属性用来设置轮廓的颜色color指定轮廓颜色，与使用color、border-color等属性设置颜色相同，您可以使用颜色名称、十六进制码和RGB值等形式定义具体颜色invert使用背景色的反色来设置轮廓的颜色，仅在IE和Opera浏览器下有效inherit从父元素继承轮廓颜色的设置注意：如果只设置outline-width或outline-color属性的话，轮廓的设置并不会生效。您必须使用outline-style属性设置了轮廓的样式之后，才可以使用outline-width和outline-color属性来设置轮廓的宽度和颜色。outline-style:solid;outline-width:5px;outline-color:red;outlineoutline属性是上述outline-width、outline-style、outline-color三个属性的简写形式，使用outline属性可以同时设置这三个属性中的一个或多个outline:outline-widthoutline-styleoutline-color;在使用outline属性时，outline-width、outline-style、outline-color这几个参数的顺序并不是固定的，您可以按照上面语法中介绍的顺序，也可以根据自己的喜好改变它们的顺序。outline:5pxinsetrgb(217,0,217);outline-offset默认情况下轮廓是紧贴着边框的，通过outline-offset属性可以设置轮廓与边框之间的距离length使用具体数值加单位的形式设置轮廓与边框之间的距离，可以为负值inherit从父元素继承outline-offset属性的值outline:6pxinset#AAA;outline-offset:10px;滚动条样式（overflow）页面中的每个元素都可以看作是一个矩形的盒子，我们可以使用CSS来控制盒子的大小、位置等等信息。默认情况下，当元素中的内容超出盒子的大小时，例如元素内容区的宽度和高度所组成的矩形区域中不足以容纳元素中的内容时，一部分内容就会溢出盒子。overflow为了能更好的处理溢出的内容，CSS中提供了一个名为overflow的属性，该属性可以设置如何处理溢出元素内容区的内容visible默认值，对溢出的内容不做处理，内容会在元素内容区之外显示hidden隐藏溢出元素内容区的内容scroll隐藏溢出元素内容区的内容，并在元素的左侧和下方分别创建一个滚动条，通过滑动滚动条可以查看元素中的所有内容auto如果出现内容溢出，则会在元素左侧创建一个滚动条，通过滑动滚动条可以查看元素中的全部内容inherit从父元素继承overflow属性的值overflow:scroll;overflow-x、overflow-y在CSS3中还提供了overflow-x和overflow-y两个属性，它们的作用与overflow属性相似，属性的可选值与overflow属性相同，其中：overflow-x：设置当元素内容区的内容在水平方向上溢出元素时如何处理溢出的内容；overflow-y​：设置当元素内容区的内容在垂直方向上溢出元素时如何处理溢出的内容。提示：当单独设置overflow-x或overflow-y其中的一个属性为非visible时，另外一个属性将自动设置为auto。另外，因为CSS3还没有最终定稿，所以这两个属性的作用可能会变更或调整。","link":"https://18279493170.github.io/8SdYO4ijW/"},{"title":"html之表格标签","content":"表格标签表格（table）以行（row）和列（column）的形式展示数据。&lt;table&gt;，&lt;caption&gt;&lt;table&gt;是一个块级容器标签，所有表格内容都要放在这个标签里面。&lt;table&gt;......&lt;/table&gt;&lt;caption&gt;总是&lt;table&gt;里面的第一个子元素，表示表格的标题。该元素是可选的。&lt;table&gt;&lt;caption&gt;示例表格&lt;/caption&gt;&lt;/table&gt;&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;都是块级容器元素，且都是&lt;table&gt;的一级子元素，分别表示表头、表体和表尾。&lt;table&gt;&lt;thead&gt;......&lt;/thead&gt;&lt;tbody&gt;......&lt;/tbody&gt;&lt;tfoot&gt;......&lt;/tfoot&gt;&lt;/table&gt;这三个元素都是可选的。如果使用了&lt;thead&gt;，那么&lt;tbody&gt;和&lt;tfoot&gt;一定在&lt;thead&gt;的后面。如果使用了&lt;tbody&gt;，那么&lt;tfoot&gt;一定在&lt;tbody&gt;后面。大型表格内部可以使用多个&lt;tbody&gt;，表示连续的多个部分。&lt;colgroup&gt;，&lt;col&gt;&lt;colgroup&gt;是&lt;table&gt;的一级子元素，用来包含一组列的定义。&lt;col&gt;是&lt;colgroup&gt;的子元素，用来定义表格的一列。&lt;table&gt;&lt;colgroup&gt;&lt;col&gt;&lt;col&gt;&lt;col&gt;&lt;/colgroup&gt;&lt;/table&gt;上面代码表明表格有3列。&lt;col&gt;不仅是一个单独使用的标签，没有结束标志，而且还是一个空元素，没有子元素。它的主要作用，除了申明表格结构，还可以为表格附加样式。&lt;table&gt;&lt;colgroup&gt;&lt;colclass=&quot;c1&quot;&gt;&lt;colclass=&quot;c2&quot;&gt;&lt;colclass=&quot;c3&quot;&gt;&lt;/colgroup&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;上面代码中，&lt;colgroup&gt;声明表格有三列，每一列有自己的class，可以使用CSS针对每个class设定样式，会对整个表格生效。&lt;col&gt;有一个span属性，值为正整数，默认为1。如果大于1，就表示该列的宽度包含连续的多列。&lt;table&gt;&lt;colgroup&gt;&lt;col&gt;&lt;colspan=&quot;2&quot;&gt;&lt;col&gt;&lt;/colgroup&gt;&lt;/table&gt;上面代码中，表格的表头定义了3列，实际数据有4列。表头的第2列会连续跨2列。&lt;tr&gt;&lt;tr&gt;标签表示表格的一行（tablerow）。如果表格有&lt;thead&gt;、&lt;tbody&gt;、&lt;tfoot&gt;，那么&lt;tr&gt;就放在这些容器元素之中，否则直接放在&lt;table&gt;的下一级。&lt;table&gt;&lt;tr&gt;...&lt;/tr&gt;&lt;tr&gt;...&lt;/tr&gt;&lt;tr&gt;...&lt;/tr&gt;&lt;/table&gt;上面代码表示表格共有3行。&lt;th&gt;，&lt;td&gt;&lt;th&gt;和&lt;td&gt;都用来定义表格的单元格。其中，&lt;th&gt;是标题单元格，&lt;td&gt;是数据单元格。&lt;table&gt;&lt;tr&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;张三&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;李四&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;上面代码中，表格一共有三行。第一行是标题行，所以使用&lt;th&gt;；第二行和第三行是数据行，所以使用&lt;td&gt;。（1）colspan属性，rowspan属性单元格会有跨越多行或多列的情况，这要通过colspan属性和rowspan属性设置，前者表示单元格跨越的栏数，后者表示单元格跨越的行数。它们的值都是一个非负整数，默认为1。&lt;table&gt;&lt;tr&gt;&lt;tdcolspan=&quot;2&quot;&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;上面代码中，第一行的第一个单元格会跨两列。（2）headers属性如果表格很大，单元格很多，源码里面会看不清，哪个单元格对应哪个表头，这时就可以使用headers属性。&lt;table&gt;&lt;tr&gt;&lt;thid=&quot;no&quot;&gt;学号&lt;/th&gt;&lt;thid=&quot;names&quot;&gt;姓名&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;tdheaders=&quot;no&quot;&gt;001&lt;/td&gt;&lt;tdheaders=&quot;names&quot;&gt;张三&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;tdheaders=&quot;no&quot;&gt;002&lt;/td&gt;&lt;tdheaders=&quot;names&quot;&gt;李四&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;上面代码中，标题栏的&lt;th&gt;设置了id属性，后面的&lt;td&gt;单元格的headers属性就对应这些id属性的值，因此就能看出来这些单元格对应哪个标题栏。headers属性的值总是对应&lt;th&gt;标签的id属性的值。由于一个单元格可以对应多个标题栏（跨行的情况），所以headers属性可以是一个空格分隔的字符串，对应多个id属性的值。（3）scope属性scope属性只有&lt;th&gt;标签支持，一般不在&lt;td&gt;标签使用，表示该&lt;th&gt;单元格到底是栏的标题，还是列的标题。&lt;table&gt;&lt;tr&gt;&lt;thscope=&quot;col&quot;&gt;姓名&lt;/th&gt;&lt;thscope=&quot;col&quot;&gt;学号&lt;/th&gt;&lt;thscope=&quot;col&quot;&gt;性别&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;thscope=&quot;row&quot;&gt;张三&lt;/th&gt;&lt;td&gt;001&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;thscope=&quot;row&quot;&gt;李四&lt;/th&gt;&lt;td&gt;002&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;上面代码中，第一行的标题栏都是列标题，所以&lt;th&gt;的scope属性为col，第二行和第三行的第一列是行标题，所以&lt;th&gt;标签的scope属性为row。scope属性可以取下面这些值。row：该行的所有单元格，都与该标题单元格相关。col：该列的所有单元格，都与该标题单元格相关。rowgroup：多行组成的一个行组的所有单元格，都与该标题单元格相关，可以与rowspan属性配合使用。colgroup：多列组成的一个列组的所有单元格，都与该标题单元格相关，可以与colspan属性配合使用。auto：默认值，表示由浏览器自行决定。下面是一个colgroup属性和rowgroup属性的例子。&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;thscope=&quot;col&quot;&gt;海报名称&lt;/th&gt;&lt;thscope=&quot;col&quot;&gt;颜色&lt;/th&gt;&lt;thcolspan=&quot;3&quot;scope=&quot;colgroup&quot;&gt;尺寸&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;throwspan=&quot;3&quot;scope=&quot;rowgroup&quot;&gt;Zodiac&lt;/th&gt;&lt;thscope=&quot;row&quot;&gt;Fullcolor&lt;/th&gt;&lt;td&gt;A2&lt;/td&gt;&lt;td&gt;A3&lt;/td&gt;&lt;td&gt;A4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;thscope=&quot;row&quot;&gt;Blackandwhite&lt;/th&gt;&lt;td&gt;A1&lt;/td&gt;&lt;td&gt;A2&lt;/td&gt;&lt;td&gt;A3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;thscope=&quot;row&quot;&gt;Sepia&lt;/th&gt;&lt;td&gt;A3&lt;/td&gt;&lt;td&gt;A4&lt;/td&gt;&lt;td&gt;A5&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;上面的例子中，列标题“尺寸”的scope属性为colgroup，表示这个标题单元格对应多列（本例为3列）；行标题的scope属性为rowgroup，表示这个标题单元格对应多行（本例为3行）。渲染结果就是下面的样子。海报名称颜色尺寸ZodiacFullcolorA2A3A4BlackandwhiteA1A2A3SepiaA3A4A5","link":"https://18279493170.github.io/l9K6AWdEl/"},{"title":"html之iframe","content":"iframe&lt;iframe&gt;标签用于在网页里面嵌入其他网页。基本用法&lt;iframe&gt;标签生成一个指定区域，在该区域中嵌入其他网页。它是一个容器元素，如果浏览器不支持&lt;iframe&gt;，就会显示内部的子元素。&lt;iframesrc=&quot;https://www.example.com&quot;width=&quot;100%&quot;height=&quot;500&quot;frameborder=&quot;0&quot;allowfullscreensandbox&gt;&lt;p&gt;&lt;ahref=&quot;https://www.example.com&quot;&gt;点击打开嵌入页面&lt;/a&gt;&lt;/p&gt;&lt;/iframe&gt;上面的代码在当前网页嵌入https://www.example.com，显示区域的宽度是100%，高度是500像素。如果当前浏览器不支持&lt;iframe&gt;，则会显示一个链接，让用户点击。浏览器普遍支持&lt;iframe&gt;，所以内部的子元素可以不写。&lt;iframe&gt;的属性如下。allowfullscreen：允许嵌入的网页全屏显示，需要全屏API的支持，请参考相关的JavaScript教程。frameborder：是否绘制边框，0为不绘制，1为绘制（默认值）。建议尽量少用这个属性，而是在CSS里面设置样式。src：嵌入的网页的URL。width：显示区域的宽度。height：显示区域的高度。sandbox：设置嵌入的网页的权限，详见下文。importance：浏览器下载嵌入的网页的优先级，可以设置三个值。high表示高优先级，low表示低优先级，auto表示由浏览器自行决定。name：内嵌窗口的名称，可以用于&lt;a&gt;、&lt;form&gt;、&lt;base&gt;的target属性。referrerpolicy：请求嵌入网页时，HTTP请求的Referer字段的设置。参见&lt;a&gt;标签的介绍。sandbox属性嵌入的网页默认具有正常权限，比如执行脚本、提交表单、弹出窗口等。如果嵌入的网页是其他网站的页面，你不了解对方会执行什么操作，因此就存在安全风险。为了限制&lt;iframe&gt;的风险，HTML提供了sandbox属性，允许设置嵌入的网页的权限，等同于提供了一个隔离层，即“沙箱”。sandbox可以当作布尔属性使用，表示打开所有限制。&lt;iframesrc=&quot;https://www.example.com&quot;sandbox&gt;&lt;/iframe&gt;sandbox属性可以设置具体的值，表示逐项打开限制。未设置某一项，就表示不具有该权限。allow-forms：允许提交表单。allow-modals：允许提示框，即允许执行window.alert()等会产生弹出提示框的JavaScript方法。allow-popups：允许嵌入的网页使用window.open()方法弹出窗口。allow-popups-to-escape-sandbox：允许弹出窗口不受沙箱的限制。allow-orientation-lock：允许嵌入的网页用脚本锁定屏幕的方向，即横屏或竖屏。allow-pointer-lock：允许嵌入的网页使用PointerLockAPI，锁定鼠标的移动。allow-presentation：允许嵌入的网页使用PresentationAPI。allow-same-origin：不打开该项限制，将使得所有加载的网页都视为跨域。allow-scripts：允许嵌入的网页运行脚本（但不创建弹出窗口）。allow-storage-access-by-user-activation：sandbox属性同时设置了这个值和allow-same-origin的情况下，允许&lt;iframe&gt;嵌入的第三方网页通过用户发起document.requestStorageAccess()请求，经由StorageAccessAPI访问父窗口的Cookie。allow-top-navigation：允许嵌入的网页对顶级窗口进行导航。allow-top-navigation-by-user-activation：允许嵌入的网页对顶级窗口进行导航，但必须由用户激活。allow-downloads-without-user-activation：允许在没有用户激活的情况下，嵌入的网页启动下载。注意，不要同时设置allow-scripts和allow-same-origin属性，这将使得嵌入的网页可以改变或删除sandbox属性。loading属性&lt;iframe&gt;指定的网页会立即加载，有时这不是希望的行为。&lt;iframe&gt;滚动进入视口以后再加载，这样会比较节省带宽。loading属性可以触发&lt;iframe&gt;网页的懒加载。该属性可以取以下三个值。auto：浏览器的默认行为，与不使用loading属性效果相同。lazy：&lt;iframe&gt;的懒加载，即将滚动进入视口时开始加载。eager：立即加载资源，无论在页面上的位置如何。&lt;iframesrc=&quot;https://example.com&quot;loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;上面代码会启用&lt;iframe&gt;的懒加载。有一点需要注意，如果&lt;iframe&gt;是隐藏的，则loading属性无效，将会立即加载。只要满足以下任一个条件，Chrome浏览器就会认为&lt;iframe&gt;是隐藏的。&lt;iframe&gt;的宽度和高度为4像素或更小。样式设为display:none或visibility:hidden。使用定位坐标为负X或负Y，将&lt;iframe&gt;放置在屏幕外。","link":"https://18279493170.github.io/wHPtfC5B4/"},{"title":"html之多媒体标签","content":"多媒体标签除了图像，网页还可以放置视频和音频。&lt;video&gt;&lt;video&gt;标签是一个块级元素，用于放置视频。如果浏览器支持加载的视频格式，就会显示一个播放器，否则显示&lt;video&gt;内部的子元素。&lt;videosrc=&quot;example.mp4&quot;controls&gt;&lt;p&gt;你的浏览器不支持HTML5视频，请下载&lt;ahref=&quot;example.mp4&quot;&gt;视频文件&lt;/a&gt;。&lt;/p&gt;&lt;/video&gt;上面代码中，如果浏览器不支持该种格式的视频，就会显示&lt;video&gt;内部的文字提示。&lt;video&gt;有以下属性。src：视频文件的网址。controls：播放器是否显示控制栏。该属性是布尔属性，不用赋值，只要写上属性名，就表示打开。如果不想使用浏览器默认的播放器，而想使用自定义播放器，就不要使用该属性。width：视频播放器的宽度，单位像素。height：视频播放器的高度，单位像素。autoplay：视频是否自动播放，该属性为布尔属性。loop：视频是否循环播放，该属性为布尔属性。muted：是否默认静音，该属性为布尔属性。poster：视频播放器的封面图片的URL。preload：视频播放之前，是否缓冲视频文件。这个属性仅适合没有设置autoplay的情况。它有三个值，分别是none（不缓冲）、metadata（仅仅缓冲视频文件的元数据）、auto（可以缓冲整个文件）。playsinline：iPhone的Safari浏览器播放视频时，会自动全屏，该属性可以禁止这种行为。该属性为布尔属性。crossorigin：是否采用跨域的方式加载视频。它可以取两个值，分别是anonymous（跨域请求时，不发送用户凭证，主要是Cookie），use-credentials（跨域时发送用户凭证）。currentTime：指定当前播放位置（双精度浮点数，单位为秒）。如果尚未开始播放，则会从这个属性指定的位置开始播放。duration：该属性只读，指示时间轴上的持续播放时间（总长度），值为双精度浮点数（单位为秒）。如果是流媒体，没有已知的结束时间，属性值为+Infinity。下面是一个例子。&lt;videowidth=&quot;400&quot;height=&quot;400&quot;autoplayloopmutedposter=&quot;poster.png&quot;&gt;&lt;/video&gt;上面代码中，视频播放器的大小是400x400，会自动播放和循环播放，并且静音，还带有封面图。这是网站首页背景视频的常见写法。HTML标准没有规定浏览器需要支持哪些视频格式，完全由浏览器厂商自己决定。为了避免浏览器不支持视频格式，可以使用&lt;source&gt;标签，放置同一个视频的多种格式。&lt;videocontrols&gt;&lt;sourcesrc=&quot;example.mp4&quot;type=&quot;video/mp4&quot;&gt;&lt;sourcesrc=&quot;example.webm&quot;type=&quot;video/webm&quot;&gt;&lt;p&gt;你的浏览器不支持HTML5视频，请下载&lt;ahref=&quot;example.mp4&quot;&gt;视频文件&lt;/a&gt;。&lt;/p&gt;&lt;/video&gt;上面代码中，&lt;source&gt;标签的type属性的值是视频文件的MIME类型，上例指定了两种格式的视频文件：MP4和WebM。如果浏览器支持MP4，就加载MP4格式的视频，不再往下执行了。如果不支持MP4，就检查是否支持WebM，如果还是不支持，则显示提示。&lt;audio&gt;&lt;audio&gt;标签是一个块级元素，用于放置音频，用法与&lt;video&gt;标签基本一致。&lt;audiocontrols&gt;&lt;sourcesrc=&quot;foo.mp3&quot;type=&quot;audio/mp3&quot;&gt;&lt;sourcesrc=&quot;foo.ogg&quot;type=&quot;audio/ogg&quot;&gt;&lt;p&gt;你的浏览器不支持HTML5音频，请直接下载&lt;ahref=&quot;foo.mp3&quot;&gt;音频文件&lt;/a&gt;。&lt;/p&gt;&lt;/audio&gt;上面代码中，&lt;audio&gt;标签内部使用&lt;source&gt;标签，指定了两种音频格式：优先使用MP3格式，如果浏览器不支持则使用Ogg格式。如果浏览器不能播放音频，则提供下载链接。&lt;audio&gt;标签的属性与&lt;video&gt;标签类似，参见上一节。autoplay：是否自动播放，布尔属性。controls：是否显示播放工具栏，布尔属性。如果不设置，浏览器不显示播放界面，通常用于背景音乐。crossorigin：是否使用跨域方式请求。loop：是否循环播放，布尔属性。muted：是否静音，布尔属性。preload：音频文件的缓冲设置。src：音频文件网址。&lt;track&gt;&lt;track&gt;标签用于指定视频的字幕，格式是WebVTT（.vtt文件），放置在&lt;video&gt;标签内部。它是一个单独使用的标签，没有结束标签。&lt;videocontrolssrc=&quot;sample.mp4&quot;&gt;&lt;tracklabel=&quot;英文&quot;kind=&quot;subtitles&quot;src=&quot;subtitles_en.vtt&quot;srclang=&quot;en&quot;&gt;&lt;tracklabel=&quot;中文&quot;kind=&quot;subtitles&quot;src=&quot;subtitles_cn.vtt&quot;srclang=&quot;cn&quot;default&gt;&lt;/video&gt;上面代码指定视频文件的英文字幕和中文字幕。&lt;track&gt;标签有以下属性。label：播放器显示的字幕名称，供用户选择。kind：字幕的类型，默认是subtitles，表示将原始声音成翻译外国文字，比如英文视频提供中文字幕。另一个常见的值是captions，表示原始声音的文字描述，通常是视频原始使用的语言，比如英文视频提供英文字幕。src：vtt字幕文件的网址。srclang：字幕的语言，必须是有效的语言代码。default：是否默认打开，布尔属性。&lt;source&gt;&lt;source&gt;标签用于&lt;picture&gt;、&lt;video&gt;、&lt;audio&gt;的内部，用于指定一项外部资源。单标签是单独使用的，没有结束标签。它有如下属性，具体示例请参见相应的容器标签。type：指定外部资源的MIME类型。src：指定源文件，用于&lt;video&gt;和&lt;audio&gt;。srcset：指定不同条件下加载的图像文件，用于&lt;picture&gt;。media：指定媒体查询表达式，用于&lt;picture&gt;。sizes：指定不同设备的显示大小，用于&lt;picture&gt;，必须跟srcset搭配使用。&lt;embed&gt;&lt;embed&gt;标签用于嵌入外部内容，这个外部内容通常由浏览器插件负责控制。由于浏览器的默认插件都不一致，很可能不是所有浏览器的用户都能访问这部分内容，建议谨慎使用。下面是嵌入视频播放器的例子。&lt;embedtype=&quot;video/webm&quot;src=&quot;/media/examples/flower.mp4&quot;width=&quot;250&quot;height=&quot;200&quot;&gt;上面代码嵌入的视频，将由浏览器插件负责控制。如果浏览器没有安装MP4插件，视频就无法播放。&lt;embed&gt;标签具有如下的通用属性。height：显示高度，单位为像素，不允许百分比。width：显示宽度，单位为像素，不允许百分比。src：嵌入的资源的URL。type：嵌入资源的MIME类型。浏览器通过type属性得到嵌入资源的MIME类型，一旦该种类型已经被某个插件注册了，就会启动该插件，负责处理嵌入的资源。下面是QuickTime插件播放MOV视频文件的例子。&lt;embedtype=&quot;video/quicktime&quot;src=&quot;movie.mov&quot;width=&quot;640&quot;height=&quot;480&quot;&gt;下面是启动Flash插件的例子。&lt;embedsrc=&quot;whoosh.swf&quot;quality=&quot;medium&quot;bgcolor=&quot;#ffffff&quot;width=&quot;550&quot;height=&quot;400&quot;name=&quot;whoosh&quot;align=&quot;middle&quot;allowScriptAccess=&quot;sameDomain&quot;allowFullScreen=&quot;false&quot;type=&quot;application/x-shockwave-flash&quot;pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot;&gt;上面代码中，如果浏览器没有安装Flash插件，就会提示去pluginspage属性指定的网址下载。&lt;object&gt;，&lt;param&gt;&lt;object&gt;标签作用跟&lt;embed&gt;相似，也是插入外部资源，由浏览器插件处理。它可以视为&lt;embed&gt;的替代品，有标准化行为，只限于插入少数几种通用资源，没有历史遗留问题，因此更推荐使用。下面是插入PDF文件的例子。&lt;objecttype=&quot;application/pdf&quot;data=&quot;/media/examples/In-CC0.pdf&quot;width=&quot;250&quot;height=&quot;200&quot;&gt;&lt;/object&gt;上面代码中，如果浏览器安装了PDF插件，就会在网页显示PDF浏览窗口。&lt;object&gt;具有如下的通用属性。data：嵌入的资源的URL。form：当前网页中相关联表单的id属性（如果有的话）。height：资源的显示高度，单位为像素，不能使用百分比。width：资源的显示宽度，单位为像素，不能使用百分比。type：资源的MIME类型。typemustmatch：布尔属性，表示data属性与type属性是否必须匹配。下面是插入Flash影片的例子。&lt;objectdata=&quot;movie.swf&quot;type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&lt;object&gt;标签是一个容器元素，内部可以使用&lt;param&gt;标签，给出插件所需要的运行参数。&lt;objectdata=&quot;movie.swf&quot;type=&quot;application/x-shockwave-flash&quot;&gt;&lt;paramname=&quot;foo&quot;value=&quot;bar&quot;&gt;&lt;/object&gt;","link":"https://18279493170.github.io/LmCWCPvjq/"},{"title":"css之盒子模型，内边距与外边距","content":"盒子模型盒子模型是网页设计中经常用到的一种思维模型，由四个部分构成，从内到外分别为内容区（content）、内边距（padding）、边框（border）和外边距（margin），CSS为这四个部分提供了一系列相关属性，通过对这些属性的设置可以丰富盒子的表现效果。网页中的每个元素都可以看作是如下图所示一个盒子模型：内容区（content）内容区是整个盒子模型的中心，其中存放了盒子的主要内容，这些内容可以是文本、图像等资源。内容区有width、height、overflow三个属性，其中width和height属性用来指定盒子内容区域的宽度和高度，当内容信息过多，超出内容区所设置的范围时，则可以使用overflow属性设置溢出内容的处理方式，overflow属性有四个可选值：hidden：表示隐藏溢出的部分；visible：表示显示溢出的部分（溢出的部分将显示在盒子外部）；scroll：表示为内容区添加一个滚动条，您可以通过滑动这个滚动条来查看内容区的全部内容；auto：表示由浏览器决定如何处理溢出部分。width:100px;height:100px;overflow:hidden;内边距（padding）内边距是内容区和边框之间的空间，您可以通过padding-top、padding-right、padding-bottom、padding-left以及它们的简写属性padding来设置内容区各个方向上与边框之间的距离。在为盒子模型设置背景属性时，背景属性可以覆盖到内边距区域。padding:20px;边框（border）边框是环绕内容区和内边距的边界，您可以使用border-style、border-width和border-color以及它们的简写属性border来设置边框的样式。其中border-style属性为边框中最主要的属性，如果没有设置该属性的话，其它的边框属性也会被忽略。注意：在IE浏览器中背景属性不会覆盖到边框区域，但是在其它主流浏览器中，背景属性则可以覆盖到边框区域，当将边框设置为虚线时就可以透过虚线看到后面的背景。width:100px;height:100px;border:10pxdashedred;padding:20px;外边距（margin）外边距位于盒子模型的最外围，是边框之外的空间，通过外边距可以使盒子与盒子之间不会紧凑的连接在一起，是CSS布局中的一种重要手段。您可以使用margin-top、margin-bottom、margin-left、margin-right以及它们的简写属性margin来设置各个方向上外边距的宽度。对于两个相邻的（水平或垂直方向）且都设置有外边距的盒子，它们之间的距离并不是两者外边距相加的和，而是它们之中较大的那个值。另外，您也可以将外边距的值设置为负值，当外边距的值为负时整个盒子将向反方向移动，当到达一定程度时盒子之间会产生重叠效果。div.box-one{width:100px;height:100px;border:10pxdashedred;padding:20px;margin:15px;background:#CCC;}div.box-two{width:50px;height:50px;border:10pxdottedblack;padding:20px;margin:20px;background:yellow;}元素的宽度和高度当您使用CSS中的width和height属性设置元素的宽度和高度时，实际上设置的只是元素内容区域的宽度和高度，元素的实际宽度和高度还取决于一些其它因素：总宽度：width+padding-left+padding-right+border-left+border-right+margin-left+margin-right总高度：height+padding-top+padding-bottom+border-top+border-bottom+margin-top+margin-bottompadding（内边距）内边距（padding）是指元素内容区与边框之间的区域，与外边距不同，内边距会受到背景属性的影响。您可以通过下面的属性来设置元素内边距的尺寸：padding-top：设置元素内容区上方的内边距；padding-right：设置元素内容区右侧的内边距；padding-bottom：设置元素内容区下方的内边距；padding-left：设置元素内容区左侧的内边距；padding：内边距属性的缩写形式，可以同时设置上下左右四个方向上的内边距。length使用具体数值配合px、cm等单位来定义元素内边距的尺寸，不能为负值，默认值为0px%定义基于父元素的宽度百分比的内边距，不能为负值inherit从父元素继承内边距属性的值定义各个方向上的内边距使用padding-top、padding-bottom、padding-left和padding-right属性来分别设置元素上下左右四个方向上的内边距。padding-top:10px;padding-bottom:2em;padding-left:1cm;padding-right:3ex;border:1pxsolidred;内边距简写形式padding属性是其余四个属性的简写形式，在实际开发中我们使用最多的也是这个简写属性。与margin属性相似，paddiing属性同样可以接受1~4个参数（参数之间使用空格分隔）：如果提供四个参数，那么将按照上、右、下、左的顺序依次设置元素四个方向上的内边距；如果提供三个参数，那么第一个参数将用来设置元素上方的内边距，第二个参数将用来设置元素左、右两个方向上的内边距，第三个参数将用来设置元素下方的内边距；如果提供两个参数，那么第一个参数将用来设置元素上、下两个方向上的内边距，第二个参数用来设置元素左、右两个方向上的内边距；如果只提供一个参数，那么这个参数将同时作用于元素四个方向上的外边距。padding:10px3ex2em1cm;margin（外边距）元素的外边距（margin）是围绕在元素边框以外（不包括边框）的空白区域，这片区域不受background属性的影响，始终是透明的。为元素设置外边距默认情况下如果不设置外边距属性，HTML元素就是不会有外边距，但也有例外的情况，因为浏览器会为一些HTML元素设置默认的外边距，例如&lt;p&gt;元素。您可以使用下面的属性来为HTML元素设置外边距：margin-top：设置元素上方的外边距；margin-bottom：设置元素下方的外边距；margin-right：设置元素右侧的外边距；margin-left：设置元素左侧的外边距；margin：外边距的简写属性，可以同时设置元素四个方向（上下左右）的外边距。auto由浏览器计算外边距的尺寸length使用具体数值配合px、cm等单位来定义元素外边距的尺寸，可以为负值，默认值为0px%定义基于父元素的宽度百分比的外边距，可以为负值inherit从父元素继承外边距属性的值margin-top:10px;margin-bottom:1em;margin-right:10px;margin-left:1cm;这里需要特别说明一下margin属性，与其它几个属性不同，margin属性可以接受1~4个参数（参数之间使用空格分隔）：如果提供四个参数，那么将按照上、右、下、左的顺序分别作用于元素四个方向的外边距；如果提供三个参数，那么第一个参数会作用在元素上方的外边距，第二个参数会作用在元素左右两侧的外边距，第三个参数则作用在元素下方的外边距；如果提供两个参数，那么第一个参数会作用在元素上方和下方的外边距，第二个参数会作用在元素的左右两侧的外边距；如果只提供一个参数，那么这个值将同时作用于元素上下左右四个方向的外边距。margin:10px0px1ex1em;外边距折叠外边距折叠指的是相邻的两个或多个外边距会在垂直方向上发生合并，合并为一个外边距。关于外边距折叠有以下几点需要注意：margin折叠只发生在块级元素上；浮动元素的外边距不会与任何外边距发生折叠；设置了overflow属性且值不为visible的块级元素，将不会与它的子元素发生外边距折叠；绝对定位元素的外边距不与任何外边距发生折叠；根元素（例如&lt;body&gt;）的外边距不与其它任何外边距发生折叠。在相邻的两个兄弟元素之间：如果相邻两个元素外边距的值都为正数，那么两个元素的实际间距为两个外边距中较大的那个；如果相邻两个元素外边距的值都为负数，那么两个元素的实际间距为两个外边距中较小的那个；如果相邻两个元素外边距的值一个为正数、一个为负数，那么两个元素之间的实际间距为两个外边距相加的和。在父元素与其子元素之间：（注意：父元素不能定义边框和内边距，且父元素与子元素之间不能有其它元素）如果父元素与子元素外边距的值都为正数，那么折叠后的外边距为两个外边距中较大的那个；如果父元素与子元素外边距的值都为负数，那么折叠后的外边距为两个外边距中较小的那个；如果父元素与子元素外边距的值一个为正数、一个负数，那么折叠后的外边距为两个外边距相加的和。","link":"https://18279493170.github.io/shs9OqQen/"},{"title":"html之链接标签","content":"链接标签链接（hyperlink）是互联网的核心。它允许用户在页面上，从一个网址跳转到另一个网址，从而把所有资源联系在一起。URL是链接指向的地址。链接不仅可以指向另一个网页，也可以指向文本、图像、文件等资源。可以这样说，所有互联网上的资源，都可以通过链接访问。&lt;a&gt;链接通过&lt;a&gt;标签表示，用户点击后，浏览器会跳转到指定的网址。下面就是一个典型的链接。&lt;ahref=&quot;https://wikipedia.org/&quot;&gt;维基百科&lt;/a&gt;上面代码就定义了一个超级链接。浏览器显示“维基百科”，文字下面默认会有下划线，表示这是一个链接。用户点击后，浏览器跳转到href属性指定的网址。&lt;a&gt;标签内部不仅可以放置文字，也可以放置其他元素，比如段落、图像、多媒体等等。&lt;ahref=&quot;https://www.example.com/&quot;&gt;&lt;imgsrc=&quot;https://www.example.com/foo.jpg&quot;&gt;&lt;/a&gt;上面代码中，&lt;a&gt;标签内部就是一个图像。用户点击图像，就会跳转到指定网址。&lt;a&gt;标签有如下属性。（1）hrefhref属性给出链接指向的网址。它的值应该是一个URL或者锚点。上文已经给出了完整URL的例子，下面是锚点的例子。&lt;ahref=&quot;#demo&quot;&gt;示例&lt;/a&gt;上面代码中，href属性的值是#加上锚点名称。点击后，浏览器会自动滚动，停在当前页面里面demo锚点所在的位置。（2）hreflanghreflang属性给出链接指向的网址所使用的语言，纯粹是提示性的，没有实际功能。&lt;ahref=&quot;https://www.example.com&quot;hreflang=&quot;en&quot;&gt;示例网址&lt;/a&gt;上面代码表明，href属性指向的网址的语言是英语。该属性的值跟通用属性lang一样，语言代码可以参考《属性》一章的lang属性的介绍。（3）titletitle属性给出链接的说明信息。鼠标悬停在链接上方时，浏览器会将这个属性的值，以提示块的形式显示出来。&lt;ahref=&quot;https://www.example.com/&quot;title=&quot;hello&quot;&gt;示例&lt;/a&gt;。上面代码中，用户鼠标停留在链接上面，会出现文字提示hello。（4）targettarget属性指定如何展示打开的链接。它可以是在指定的窗口打开，也可以在&lt;iframe&gt;里面打开。&lt;p&gt;&lt;ahref=&quot;http://foo.com&quot;target=&quot;test&quot;&gt;foo&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;ahref=&quot;http://bar.com&quot;target=&quot;test&quot;&gt;bar&lt;/a&gt;&lt;/p&gt;上面代码中，两个链接都在名叫test的窗口打开。首先点击链接foo，浏览器发现没有叫做test的窗口，就新建一个窗口，起名为test，在该窗口打开foo.com。然后，用户又点击链接bar，由于已经存在test窗口，浏览器就在该窗口打开bar.com，取代里面已经打开的foo.com。target属性的值也可以是以下四个关键字之一。_self：当前窗口打开，这是默认值。_blank：新窗口打开。_parent：上层窗口打开，这通常用于从父窗口打开的子窗口，或者&lt;iframe&gt;里面的链接。如果当前窗口没有上层窗口，这个值等同于_self。_top：顶层窗口打开。如果当前窗口就是顶层窗口，这个值等同于_self。&lt;ahref=&quot;https://www.example.com&quot;target=&quot;_blank&quot;&gt;示例链接&lt;/a&gt;上面代码点击后，浏览器会新建一个窗口，在该窗口打开链接，并且新窗口没有名字。注意，使用target属性的时候，最好跟rel=&quot;noreferrer&quot;一起使用，这样可以避免安全风险。（5）relrel属性说明链接与当前页面的关系。&lt;ahref=&quot;help.html&quot;rel=&quot;help&quot;&gt;帮助&lt;/a&gt;上面代码的rel属性，说明链接是当前页面的帮助文档。下面是一些常见的rel属性的值。alternate：当前文档的另一种形式，比如翻译。author：作者链接。bookmark：用作书签的永久地址。external：当前文档的外部参考文档。help：帮助链接。license：许可证链接。next：系列文档的下一篇。nofollow：告诉搜索引擎忽略该链接，主要用于用户提交的内容，防止有人企图通过添加链接，提高该链接的搜索排名。noreferrer：告诉浏览器打开链接时，不要将当前网址作为HTTP头信息的Referer字段发送出去，这样可以隐藏点击的来源。noopener：告诉浏览器打开链接时，不让链接窗口通过JavaScript的window.opener属性引用原始窗口，这样就提高了安全性。prev：系列文档的上一篇。search：文档的搜索链接。tag：文档的标签链接。（6）referrerpolicyreferrerpolicy属性用于精确设定点击链接时，浏览器发送HTTP头信息的Referer字段的行为。该属性可以取下面八个值：no-referrer、no-referrer-when-downgrade、origin、origin-when-cross-origin、unsafe-url、same-origin、strict-origin、strict-origin-when-cross-origin。其中，no-referrer表示不发送Referer字段，same-origin表示同源时才发送Referer字段，origin表示只发送源信息（协议+域名+端口）。其他几项的解释，请查阅HTTP文档。（7）pingping属性指定一个网址，用户点击的时候，会向该网址发出一个POST请求，通常用于跟踪用户的行为。&lt;ahref=&quot;http://localhost:3000/other&quot;ping=&quot;http://localhost:3000/log&quot;&gt;GotoOtherPage&lt;/a&gt;上面示例中，用户点击链接时，除了发生跳转，还会向http://localhost:3000/log发送一个POST请求。服务端收到这个请求以后，就会知道用户点击了这个链接。这个请求的HTTP标头，包含了ping-from属性（点击行为发生的页面）和ping-to属性（href属性所指向的页面）。headers:{'ping-from':'http://localhost:3000/','ping-to':'http://localhost:3000/other''content-type':'text/ping'//...otherheaders},注意，ping属性只对链接有效，对其他的交互行为无效，比如按钮点击或表单提交。另外，Firefox浏览器不支持该属性。并且，也无法让它发送任何的自定义数据。（8）typetype属性给出链接URL的MIME类型，比如到底是网页，还是图像或文件。它也是纯粹提示性的属性，没有实际功能。&lt;ahref=&quot;smile.jpg&quot;type=&quot;image/jpeg&quot;&gt;示例图片&lt;/a&gt;上面代码中，type属性提示这是一张图片。（9）downloaddownload属性表明当前链接用于下载，而不是跳转到另一个URL。&lt;ahref=&quot;demo.txt&quot;download&gt;下载&lt;/a&gt;上面代码点击后，会出现下载对话框。注意，download属性只在链接与网址同源时，才会生效。也就是说，链接应该与网址属于同一个网站。如果download属性设置了值，那么这个值就是下载的文件名。&lt;ahref=&quot;foo.exe&quot;download=&quot;bar.exe&quot;&gt;点击下载&lt;/a&gt;上面代码中，下载文件的原始文件名是foo.exe。点击后，下载对话框提示的文件名是bar.exe。注意，如果链接点击后，服务器的HTTP回应的头信息设置了Content-Disposition字段，并且该字段的值与download属性不一致，那么该字段优先，下载时将显示其设置的文件名。download属性还有一个用途，就是有些地址不是真实网址，而是数据网址，比如data:开头的网址。这时，download属性可以为虚拟网址指定下载的文件名。&lt;ahref=&quot;data:,Hello%2C%20World!&quot;&gt;点击&lt;/a&gt;上面链接点击后，会打开一个虚拟网页，上面显示HelloWorld!。&lt;ahref=&quot;data:,Hello%2C%20World!&quot;download=&quot;hello.txt&quot;&gt;点击&lt;/a&gt;上面链接点击后，下载的hello.txt文件内容就是“Hello,World!”。邮件链接链接也可以指向一个邮件地址，使用mailto协议。用户点击后，浏览器会打开本机默认的邮件程序，让用户向指定的地址发送邮件。&lt;ahref=&quot;mailto:contact@example.com&quot;&gt;联系我们&lt;/a&gt;上面代码中，链接就指向邮件地址。点击后，浏览器会打开一个邮件地址，让你可以向contact@example.com发送邮件。除了邮箱，邮件协议还允许指定其他几个邮件要素。subject：主题cc：抄送bcc：密送body：邮件内容使用方法是将这些邮件要素，以查询字符串的方式，附加在邮箱地址后面。&lt;ahref=&quot;mailto:foo@bar.com?cc=test@test.com&amp;subject=The%20subject&amp;body=The%20body&quot;&gt;发送邮件&lt;/a&gt;上面代码中，邮件链接里面不仅包含了邮箱地址，还包含了cc、subject、body等邮件要素。这些要素的值需要经过URL转义，比如空格转成%20。不指定邮箱也是允许的，就像下面这样。这时用户自己在邮件程序里面，填写想要发送的邮箱，通常用于邮件分享网页。&lt;ahref=&quot;mailto:&quot;&gt;告诉朋友&lt;/a&gt;电话链接如果是手机浏览的页面，还可以使用tel协议，创建电话链接。用户点击该链接，会唤起电话，可以进行拨号。&lt;ahref=&quot;tel:13312345678&quot;&gt;13312345678&lt;/a&gt;上面代码在手机中，点击链接会唤起拨号界面，可以直接拨打指定号码。&lt;link&gt;基本用法&lt;link&gt;标签主要用于将当前网页与相关的外部资源联系起来，通常放在&lt;head&gt;元素里面。最常见的用途就是加载CSS样式表。&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;theme.css&quot;&gt;上面代码为网页加载样式表theme.css。除了默认样式表，网页还可以加载替代样式表，即默认不生效、需要用户手动切换的样式表。&lt;linkhref=&quot;default.css&quot;rel=&quot;stylesheet&quot;title=&quot;DefaultStyle&quot;&gt;&lt;linkhref=&quot;fancy.css&quot;rel=&quot;alternatestylesheet&quot;title=&quot;Fancy&quot;&gt;&lt;linkhref=&quot;basic.css&quot;rel=&quot;alternatestylesheet&quot;title=&quot;Basic&quot;&gt;上面代码中，default.css是默认样式表，默认就会生效。fancy.css和basic.css是替换样式表（rel=&quot;alternatestylesheet&quot;），默认不生效。title属性在这里是必需的，用来在浏览器菜单里面列出这些样式表的名字，供用户选择，以替代默认样式表。&lt;link&gt;还可以加载网站的favicon图标文件。&lt;linkrel=&quot;icon&quot;href=&quot;/favicon.ico&quot;type=&quot;image/x-icon&quot;&gt;手机访问时，网站通常需要提供不同分辨率的图标文件。&lt;linkrel=&quot;apple-touch-icon-precomposed&quot;sizes=&quot;114x114&quot;href=&quot;favicon114.png&quot;&gt;&lt;linkrel=&quot;apple-touch-icon-precomposed&quot;sizes=&quot;72x72&quot;href=&quot;favicon72.png&quot;&gt;上面代码指定iPhone设备需要的114像素和72像素的图标。&lt;link&gt;也用于提供文档的相关链接，比如下面是给出文档的RSSFeed地址。&lt;linkrel=&quot;alternate&quot;type=&quot;application/atom+xml&quot;href=&quot;/blog/news/atom&quot;&gt;rel属性rel属性表示外部资源与当前文档之间的关系，是&lt;link&gt;标签的必需属性。它可以但不限于取以下值。alternate：文档的另一种表现形式的链接，比如打印版。author：文档作者的链接。dns-prefetch：要求浏览器提前执行指定网址的DNS查询。help：帮助文档的链接。icon：加载文档的图标文件。license：许可证链接。next：系列文档下一篇的链接。pingback：接收当前文档pingback请求的网址。preconnect：要求浏览器提前与给定服务器，建立HTTP连接。prefetch：要求浏览器提前下载并缓存指定资源，供下一个页面使用。它的优先级较低，浏览器可以不下载。preload：要求浏览器提前下载并缓存指定资源，当前页面稍后就会用到。它的优先级较高，浏览器必须立即下载。prerender：要求浏览器提前渲染指定链接。这样的话，用户稍后打开该链接，就会立刻显示，感觉非常快。prev：表示当前文档是系列文档的一篇，这里给出上一篇文档的链接。search：提供当前网页的搜索链接。stylesheet：加载一张样式表。下面是一些示例。&lt;!--作者信息--&gt;&lt;linkrel=&quot;author&quot;href=&quot;humans.txt&quot;&gt;&lt;!--版权信息--&gt;&lt;linkrel=&quot;license&quot;href=&quot;copyright.html&quot;&gt;&lt;!--另一个语言的版本--&gt;&lt;linkrel=&quot;alternate&quot;href=&quot;https://es.example.com/&quot;hreflang=&quot;es&quot;&gt;&lt;!--联系方式--&gt;&lt;linkrel=&quot;me&quot;href=&quot;https://google.com/profiles/someone&quot;type=&quot;text/html&quot;&gt;&lt;linkrel=&quot;me&quot;href=&quot;mailto:name@example.com&quot;&gt;&lt;linkrel=&quot;me&quot;href=&quot;sms:+15035550125&quot;&gt;&lt;!--历史资料--&gt;&lt;linkrel=&quot;archives&quot;href=&quot;http://example.com/archives/&quot;&gt;&lt;!--目录--&gt;&lt;linkrel=&quot;index&quot;href=&quot;http://example.com/article/&quot;&gt;&lt;!--导航--&gt;&lt;linkrel=&quot;first&quot;href=&quot;http://example.com/article/&quot;&gt;&lt;linkrel=&quot;last&quot;href=&quot;http://example.com/article/?page=42&quot;&gt;&lt;linkrel=&quot;prev&quot;href=&quot;http://example.com/article/?page=1&quot;&gt;&lt;linkrel=&quot;next&quot;href=&quot;http://example.com/article/?page=3&quot;&gt;资源的预加载某些情况下，你需要浏览器预加载某些资源，也就是先把资源缓存下来，等到使用的时候，就不用再从网上下载了，立即就能使用。预处理指令可以做到这一点。预加载主要有下面五种类型。（1）&lt;linkrel=&quot;preload&quot;&gt;&lt;linkrel=&quot;preload&quot;&gt;告诉浏览器尽快下载并缓存资源（如脚本或样式表），该指令优先级较高，浏览器肯定会执行。当加载页面几秒钟后需要该资源时，它会很有用。下载后，浏览器不会对资源执行任何操作，脚本未执行，样式表未应用。它只是缓存，当其他东西需要它时，它立即可用。&lt;linkrel=&quot;preload&quot;href=&quot;image.png&quot;as=&quot;image&quot;&gt;rel=&quot;preload&quot;除了优先级较高，还有两个优点：一是允许指定预加载资源的类型，二是允许onload事件的回调函数。下面是rel=&quot;preload&quot;配合as属性，告诉浏览器预处理资源的类型，以便正确处理。&lt;linkrel=&quot;preload&quot;href=&quot;style.css&quot;as=&quot;style&quot;&gt;&lt;linkrel=&quot;preload&quot;href=&quot;main.js&quot;as=&quot;script&quot;&gt;上面代码要求浏览器提前下载并缓存style.css和main.js。as属性指定加载资源的类型，它的值一般有下面几种。&quot;script&quot;&quot;style&quot;&quot;image&quot;&quot;media&quot;&quot;document&quot;如果不指定as属性，或者它的值是浏览器不认识的，那么浏览器会以较低的优先级下载这个资源。有时还需要type属性，进一步明确MIME类型。&lt;linkrel=&quot;preload&quot;href=&quot;sintel-short.mp4&quot;as=&quot;video&quot;type=&quot;video/mp4&quot;&gt;上面代码要求浏览器提前下载视频文件，并且说明这是MP4编码。下面是预下载字体文件的例子。&lt;linkrel=&quot;preload&quot;href=&quot;font.woff2&quot;as=&quot;font&quot;type=&quot;font/woff2&quot;crossorigin&gt;注意，所有预下载的资源，只是下载到浏览器的缓存，并没有执行。如果希望资源预下载后立刻执行，可以参考下面的写法。&lt;linkrel=&quot;preload&quot;as=&quot;style&quot;href=&quot;async_style.css&quot;onload=&quot;this.rel='stylesheet'&quot;&gt;上面代码中，onload指定的回调函数会在脚本下载完成后执行，立即插入页面。（2）&lt;linkrel=&quot;prefetch&quot;&gt;&lt;linkrel=&quot;prefetch&quot;&gt;的使用场合是，如果后续的页面需要某个资源，并且希望预加载该资源，以便加速页面渲染。该指令不是强制性的，优先级较低，浏览器不一定会执行。这意味着，浏览器可以不下载该资源，比如连接速度很慢时。&lt;linkrel=&quot;prefetch&quot;href=&quot;https://www.example.com/&quot;&gt;（3）&lt;linkrel=&quot;preconnect&quot;&gt;&lt;linkrel=&quot;preconnect&quot;&gt;要求浏览器提前与某个域名建立TCP连接。当你知道，很快就会请求该域名时，这会很有帮助。&lt;linkrel=&quot;preconnect&quot;href=&quot;https://www.example.com/&quot;&gt;（4）&lt;linkrel=&quot;dns-prefetch&quot;&gt;&lt;linkrel=&quot;dns-prefetch&quot;&gt;要求浏览器提前执行某个域名的DNS解析。&lt;linkrel=&quot;dns-prefetch&quot;href=&quot;//example.com/&quot;&gt;（5）&lt;linkrel=&quot;prerender&quot;&gt;&lt;linkrel=&quot;prerender&quot;&gt;要求浏览器加载某个网页，并且提前渲染它。用户点击指向该网页的链接时，就会立即呈现该页面。如果确定用户下一步会访问该页面，这会很有帮助。&lt;linkrel=&quot;prerender&quot;href=&quot;http://example.com/&quot;&gt;media属性media属性给出外部资源生效的媒介条件。&lt;linkhref=&quot;print.css&quot;rel=&quot;stylesheet&quot;media=&quot;print&quot;&gt;&lt;linkhref=&quot;mobile.css&quot;rel=&quot;stylesheet&quot;media=&quot;screenand(max-width:600px)&quot;&gt;上面代码中，打印时加载print.css，移动设备访问时（设备宽度小于600像素）加载mobile.css。下面是使用media属性实现条件加载的例子。&lt;linkrel=&quot;preload&quot;as=&quot;image&quot;href=&quot;map.png&quot;media=&quot;(max-width:600px)&quot;&gt;&lt;linkrel=&quot;preload&quot;as=&quot;script&quot;href=&quot;map.js&quot;media=&quot;(min-width:601px)&quot;&gt;上面代码中，如果屏幕宽度在600像素以下，则只加载第一个资源，否则就加载第二个资源。其他属性&lt;link&gt;标签的其他属性如下。crossorigin：加载外部资源的跨域设置。href：外部资源的网址。referrerpolicy：加载时Referer头信息字段的处理方法。as：rel=&quot;preload&quot;或rel=&quot;prefetch&quot;时，设置外部资源的类型。type：外部资源的MIME类型，目前仅用于rel=&quot;preload&quot;或rel=&quot;prefetch&quot;的情况。title：加载样式表时，用来标识样式表的名称。sizes：用来声明图标文件的尺寸，比如加载苹果手机的图标文件。&lt;script&gt;&lt;script&gt;用于加载脚本代码，目前主要是加载JavaScript代码。&lt;script&gt;console.log('helloworld');&lt;/script&gt;上面代码嵌入网页，会立即执行。&lt;script&gt;也可以加载外部脚本，src属性给出外部脚本的地址。&lt;scriptsrc=&quot;javascript.js&quot;&gt;&lt;/script&gt;上面代码会加载javascript.js脚本文件，并执行。type属性给出脚本的类型，默认是JavaScript代码，所以可省略。完整的写法其实是下面这样。&lt;scripttype=&quot;text/javascript&quot;src=&quot;javascript.js&quot;&gt;&lt;/script&gt;type属性也可以设成module，表示这是一个ES6模块，不是传统脚本。&lt;scripttype=&quot;module&quot;src=&quot;main.js&quot;&gt;&lt;/script&gt;对于那些不支持ES6模块的浏览器，可以设置nomodule属性。支持ES6模块的浏览器，会不加载指定的脚本。这个属性通常与type=&quot;module&quot;配合使用，作为老式浏览器的回退方案。&lt;scripttype=&quot;module&quot;src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;scriptnomodulesrc=&quot;fallback.js&quot;&gt;&lt;/script&gt;&lt;script&gt;还有下面一些其他属性，大部分跟JavaScript语言有关，可以参考相关的JavaScript教程。async：该属性指定JavaScript代码为异步执行，不是造成阻塞效果，JavaScript代码默认是同步执行。defer：该属性指定JavaScript代码不是立即执行，而是页面解析完成后执行。crossorigin：如果采用这个属性，就会采用跨域的方式加载外部脚本，即HTTP请求的头信息会加上origin字段。integrity：给出外部脚本的哈希值，防止脚本被篡改。只有哈希值相符的外部脚本，才会执行。nonce：一个密码随机数，由服务器在HTTP头信息里面给出，每次加载脚本都不一样。它相当于给出了内嵌脚本的白名单，只有在白名单内的脚本才能执行。referrerpolicy：HTTP请求的Referer字段的处理方法。&lt;noscript&gt;&lt;noscript&gt;标签用于浏览器不支持或关闭JavaScript时，所要显示的内容。用户关闭JavaScript可能是为了节省带宽，以延长手机电池寿命，或者为了防止追踪，保护隐私。&lt;noscript&gt;您的浏览器不能执行JavaScript语言，页面无法正常显示。&lt;/noscript&gt;上面这段代码，只有浏览器不能执行JavaScript代码时才会显示，否则就不会显示。","link":"https://18279493170.github.io/YZybvbkZC/"},{"title":"html之图像标签","content":"图像标签图片是互联网的重要组成部分，让网页变得丰富多彩。本章介绍如何在网页插入图片。&lt;img&gt;&lt;img&gt;标签用于插入图片。它是单独使用的，没有闭合标签。&lt;imgsrc=&quot;foo.jpg&quot;&gt;上面代码在网页插入一张图片foo.jpg。src属性指定图片的网址，上例是相对URL，表示图片与网页在同一个目录。&lt;img&gt;默认是一个行内元素，与前后的文字处在同一行。&lt;p&gt;Hello&lt;imgsrc=&quot;foo.jpg&quot;&gt;World&lt;/p&gt;上面代码的渲染结果是，文字和图片在同一行显示。图像默认以原始大小显示。如果图片很大，又与文字处在同一行，那么图片将把当前行的行高撑高，并且图片的底边与文字的底边在同一条水平线上。&lt;img&gt;可以放在&lt;a&gt;标签内部，使得图片变成一个可以点击的链接。&lt;ahref=&quot;example.html&quot;&gt;&lt;imgsrc=&quot;foo.jpg&quot;&gt;&lt;/a&gt;上面代码中，图片可以像链接那样点击，点击后会产生跳转。（1）alt属性alt属性用来设定图片的文字说明。图片不显示时（比如下载失败，或用户关闭图片加载），图片的位置上会显示该文本。&lt;imgsrc=&quot;foo.jpg&quot;alt=&quot;示例图片&quot;&gt;上面代码中，alt是图片的说明。图片下载失败时，浏览器会在图片位置，显示文字“示例图片”。（2）width属性，height属性图片默认以原始大小插入网页，width属性和height属性可以指定图片显示时的宽度和高度，单位是像素或百分比。&lt;imgsrc=&quot;foo.jpg&quot;width=&quot;400&quot;height=&quot;300&quot;&gt;上面代码中，width属性指定图片显示的宽度为400像素，height属性指定显示高度为300像素。注意，一旦设置了这两个属性，浏览器会在网页中预先留出这个大小的空间，不管图片有没有加载成功。不过，由于图片的显示大小可以用CSS设置，所以不建议使用这两个属性。一种特殊情况是，width属性和height属性只设置了一个，另一个没有设置。这时，浏览器会根据图片的原始大小，自动设置对应比例的图片宽度或高度。举例来说，图片大小是800像素x800像素，width属性设置成200，那么浏览器会自动将height设成200。（3）srcset，sizes详见下文的《响应式图像》部分。（4）referrerpolicy&lt;img&gt;导致的图片加载的HTTP请求，默认会带有Referer的头信息。referrerpolicy属性对这个行为进行设置。（5）crossorigin有时，图片和网页属于不同的网站，网页加载图片就会导致跨域请求，对方服务器可能要求跨域认证。crossorigin属性用来告诉浏览器，是否采用跨域的形式下载图片，默认是不采用。简单说，只要打开了这个属性，HTTP请求的头信息里面，就会加入origin字段，给出请求发出的域名，不打开这个属性就不加。一旦打开该属性，它可以设为两个值。anonymous：跨域请求不带有用户凭证（通常是Cookie）。use-credentials：跨域请求带有用户凭证。下面是一个例子。&lt;imgsrc=&quot;foo.jpg&quot;crossorigin=&quot;anonymous&quot;&gt;crossorigin属性如果省略值的部分，则等同于anonymous。&lt;imgsrc=&quot;foo.jpg&quot;crossorigin&gt;（6）loading浏览器的默认行为是，只要解析到&lt;img&gt;标签，就开始加载图片。对于很长的网页，这样做很浪费带宽，因为用户不一定会往下滚动，一直看到网页结束。用户很可能是点开网页，看了一会就关掉了，那些不在视口的图片加载的流量，就都浪费了。loading属性改变了这个行为，可以指定图片的懒加载，即图片默认不加载，只有即将滚动进入视口，变成用户可见时才会加载，这样就节省了带宽。loading属性可以取以下三个值。auto：浏览器默认行为，等同于不使用loading属性。lazy：启用懒加载。eager：立即加载资源，无论它在页面上的哪个位置。&lt;imgsrc=&quot;image.png&quot;loading=&quot;lazy&quot;alt=&quot;…&quot;width=&quot;200&quot;height=&quot;200&quot;&gt;由于行内图片的懒加载，可能会导致页面布局重排，所以使用这个属性的时候，最好指定图片的高和宽。&lt;figure&gt;，&lt;figcaption&gt;&lt;figure&gt;标签可以理解为一个图像区块，将图像和相关信息封装在一起。&lt;figcaption&gt;是它的可选子元素，表示图像的文本描述，通常用于放置标题，可以出现多个。&lt;figure&gt;&lt;imgsrc=&quot;https://example.com/foo.jpg&quot;&gt;&lt;figcaption&gt;示例图片&lt;/figcaption&gt;&lt;/figure&gt;除了图像，&lt;figure&gt;还可以封装引言、代码、诗歌等等。它等于是一个将主体内容与附加信息，封装在一起的语义容器。&lt;figure&gt;&lt;figcaption&gt;JavaScript代码示例&lt;/figcaption&gt;&lt;p&gt;&lt;code&gt;constfoo='hello';&lt;/code&gt;&lt;/p&gt;&lt;/figure&gt;响应式图像网页在不同尺寸的设备上，都能产生良好的显示效果，叫做“响应式设计”（responsivewebdesign）。响应式设计的网页图像，就是“响应式图像”（responsiveimage）。响应式图像的解决方案有很多，JavaScript和CSS都可以实现。这里只介绍语义性最好的HTML方法，浏览器原生支持。问题的由来我们知道，&lt;img&gt;标签用于插入网页图像，所有情况默认插入的都是同一张图像。&lt;imgsrc=&quot;foo.jpg&quot;&gt;上面代码在桌面端和手机上，插入的都是图像文件foo.jpg。这种处理方法固然简单，但是有三大弊端。（1）体积一般来说，桌面端显示的是大尺寸的图像，文件体积较大。手机的屏幕较小，只需要小尺寸的图像，可以节省带宽，加速网页渲染。（2）像素密度桌面显示器一般是单倍像素密度，而手机的显示屏往往是多倍像素密度，即显示时多个像素合成为一个像素，这种屏幕称为Retina屏幕。图像文件很可能在桌面端很清晰，放到手机上会有点模糊，因为图像没有那么高的像素密度，浏览器自动把图像的每个像素复制到周围像素，满足像素密度的要求，导致图像的锐利度有所下降。（3）视觉风格桌面显示器的面积较大，图像可以容纳更多细节。手机的屏幕较小，许多细节是看不清的，需要突出重点。上面两张图片，下方的手机图片经过裁剪以后，更突出图像重点，明显效果更好。srcset属性为了解决上面这些问题，HTML语言提供了一套完整的解决方案。首先，&lt;img&gt;标签引入了srcset属性。srcset属性用来指定多张图像，适应不同像素密度的屏幕。它的值是一个逗号分隔的字符串，每个部分都是一张图像的URL，后面接一个空格，然后是像素密度的描述符。请看下面的例子。&lt;imgsrcset=&quot;foo-320w.jpg,foo-480w.jpg1.5x,foo-640w.jpg2x&quot;src=&quot;foo-640w.jpg&quot;&gt;上面代码中，srcset属性给出了三个图像URL，适应三种不同的像素密度。图像URL后面的像素密度描述符，格式是像素密度倍数+字母x。1x表示单倍像素密度，可以省略。浏览器根据当前设备的像素密度，选择需要加载的图像。如果srcset属性都不满足条件，那么就加载src属性指定的默认图像。sizes属性像素密度的适配，只适合显示区域一样大小的图像。如果希望不同尺寸的屏幕，显示不同大小的图像，srcset属性就不够用了，必须搭配sizes属性。第一步，srcset属性列出所有可用的图像。&lt;imgsrcset=&quot;foo-160.jpg160w,foo-320.jpg320w,foo-640.jpg640w,foo-1280.jpg1280w&quot;src=&quot;foo-1280.jpg&quot;&gt;上面代码中，srcset属性列出四张可用的图像，每张图像的URL后面是一个空格，再加上宽度描述符。宽度描述符就是图像原始的宽度，加上字符w。上例的四种图片的原始宽度分别为160像素、320像素、640像素和1280像素。第二步，sizes属性列出不同设备的图像显示宽度。sizes属性的值是一个逗号分隔的字符串，除了最后一部分，前面每个部分都是一个放在括号里面的媒体查询表达式，后面是一个空格，再加上图像的显示宽度。&lt;imgsrcset=&quot;foo-160.jpg160w,foo-320.jpg320w,foo-640.jpg640w,foo-1280.jpg1280w&quot;sizes=&quot;(max-width:440px)100vw,(max-width:900px)33vw,254px&quot;src=&quot;foo-1280.jpg&quot;&gt;上面代码中，sizes属性给出了三种屏幕条件，以及对应的图像显示宽度。宽度不超过440像素的设备，图像显示宽度为100%；宽度441像素到900像素的设备，图像显示宽度为33%；宽度900像素以上的设备，图像显示宽度为254px。第三步，浏览器根据当前设备的宽度，从sizes属性获得图像的显示宽度，然后从srcset属性找出最接近该宽度的图像，进行加载。假定当前设备的屏幕宽度是480px，浏览器从sizes属性查询得到，图片的显示宽度是33vw（即33%），等于160px。srcset属性里面，正好有宽度等于160px的图片，于是加载foo-160.jpg。如果省略sizes属性，那么浏览器将根据实际的图像显示宽度，从srcset属性选择最接近的图片。一旦使用sizes属性，就必须与srcset属性搭配使用，单独使用sizes属性是无效的。&lt;picture&gt;响应式用法&lt;img&gt;标签的srcset属性和sizes属性分别解决了像素密度和屏幕大小的适配，但如果要同时适配不同像素密度、不同大小的屏幕，就要用到&lt;picture&gt;标签。&lt;picture&gt;是一个容器标签，内部使用&lt;source&gt;和&lt;img&gt;，指定不同情况下加载的图像。&lt;picture&gt;&lt;sourcemedia=&quot;(max-width:500px)&quot;srcset=&quot;cat-vertical.jpg&quot;&gt;&lt;sourcemedia=&quot;(min-width:501px)&quot;srcset=&quot;cat-horizontal.jpg&quot;&gt;&lt;imgsrc=&quot;cat.jpg&quot;alt=&quot;cat&quot;&gt;&lt;/picture&gt;上面代码中，&lt;picture&gt;标签内部有两个&lt;source&gt;标签和一个&lt;img&gt;标签。&lt;picture&gt;内部的&lt;source&gt;标签，主要使用media属性和srcset属性。media属性给出媒体查询表达式，srcset属性就是&lt;img&gt;标签的srcset属性，给出加载的图像文件。sizes属性其实这里也可以用，但由于有了media属性，就没有必要了。浏览器按照&lt;source&gt;标签出现的顺序，依次判断当前设备是否满足media属性的媒体查询表达式，如果满足就加载srcset属性指定的图片文件，并且不再执行后面的&lt;source&gt;标签和&lt;img&gt;标签。&lt;img&gt;标签是默认情况下加载的图像，用来满足上面所有&lt;source&gt;都不匹配的情况，或者不支持&lt;picture&gt;的老式浏览器。上面例子中，设备宽度如果不超过500px，就加载竖屏的图像，否则加载横屏的图像。下面给出一个例子，同时考虑屏幕尺寸和像素密度的适配。&lt;picture&gt;&lt;sourcesrcset=&quot;homepage-person@desktop.png,homepage-person@desktop-2x.png2x&quot;media=&quot;(min-width:990px)&quot;&gt;&lt;sourcesrcset=&quot;homepage-person@tablet.png,homepage-person@tablet-2x.png2x&quot;media=&quot;(min-width:750px)&quot;&gt;&lt;imgsrcset=&quot;homepage-person@mobile.png,homepage-person@mobile-2x.png2x&quot;alt=&quot;ShopifyMerchant,CorrineAnestopoulos&quot;&gt;&lt;/picture&gt;上面代码中，&lt;source&gt;标签的media属性给出屏幕尺寸的适配条件，每个条件都用srcset属性，再给出两种像素密度的图像URL。图像格式的选择除了响应式图像，&lt;picture&gt;标签还可以用来选择不同格式的图像。比如，如果当前浏览器支持Webp格式，就加载这种格式的图像，否则加载PNG图像。&lt;picture&gt;&lt;sourcetype=&quot;image/svg+xml&quot;srcset=&quot;logo.xml&quot;&gt;&lt;sourcetype=&quot;image/webp&quot;srcset=&quot;logo.webp&quot;&gt;&lt;imgsrc=&quot;logo.png&quot;alt=&quot;ACMECorp&quot;&gt;&lt;/picture&gt;上面代码中，&lt;source&gt;标签的type属性给出图像的MIME类型，srcset是对应的图像URL。浏览器按照&lt;source&gt;标签出现的顺序，依次检查是否支持type属性指定的图像格式，如果支持就加载图像，并且不再检查后面的&lt;source&gt;标签了。上面例子中，图像加载优先顺序依次为svg格式、webp格式和png格式。","link":"https://18279493170.github.io/X-cWsPMDC/"},{"title":"html之列表标签","content":"列表标签列表是一系列排列好的项目，主要分成两类：有序列表和无序列表。有序列表是每个列表项前面有编号，呈现出顺序，就像下面这样。1.列表项A2.列表项B3.列表项C无序列表则是列表项前面没有编号，只有一个列表符号，默认是一个圆点。·列表项A·列表项B·列表项C&lt;ol&gt;&lt;ol&gt;标签是一个有序列表容器（orderedlist），会在内部的列表项前面产生数字编号。列表项的顺序有意义时，比如排名，就会采用这个标签。&lt;ol&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码会在列表项A、B、C前面，分别产生1、2、3的编号。&lt;ol&gt;标签内部可以嵌套&lt;ol&gt;标签或&lt;ul&gt;标签，形成多级列表。&lt;ol&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;ol&gt;&lt;li&gt;列表项B1&lt;/li&gt;&lt;li&gt;列表项B2&lt;/li&gt;&lt;li&gt;列表项B3&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码中，一个有序列表内部嵌套了另一个有序列表，渲染结果如下。1.列表项A2.列表项B1.列表项B12.列表项B23.列表项B33.列表项C该标签有以下属性。（1）reversedreversed属性产生倒序的数字列表。&lt;olreversed&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码中，列表项A、B、C前面，产生的编号是3、2、1。（2）startstart属性的值是一个整数，表示数字列表的起始编号。&lt;olstart=&quot;5&quot;&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码中，列表项A、B、C前面，产生的编号是5、6、7。（3）typetype属性指定数字编号的样式。目前，浏览器支持以下样式。a：小写字母A：大写字母i：小写罗马数字I：大写罗马数字1：整数（默认值）&lt;oltype=&quot;a&quot;&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码中，列表项A、B、C前面的编号，分别是英文小写字母a、b、c。注意，即使编号是字母，start属性也依然使用整数。&lt;oltype=&quot;a&quot;start=&quot;3&quot;&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码中，type属性指定编号采用小写英文字母，start属性等于3，表示从c开始编号。&lt;ul&gt;&lt;ul&gt;标签是一个无序列表容器（unorderedlist），会在内部的列表项前面产生实心小圆点，作为列表符号。列表项的顺序无意义时，采用这个标签。&lt;ul&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;li&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ul&gt;上面代码的渲染结果是，列表项A、B、C前面，分别产生一个实心小圆点，作为列表符号。&lt;ul&gt;标签内部可以嵌套&lt;ul&gt;或&lt;ol&gt;，形成多级列表。&lt;li&gt;&lt;li&gt;表示列表项，用在&lt;ol&gt;或&lt;ul&gt;容器之中。有序列表&lt;ol&gt;之中，&lt;li&gt;有一个value属性，定义当前列表项的编号，后面列表项会从这个值开始编号。&lt;ol&gt;&lt;li&gt;列表项A&lt;/li&gt;&lt;livalue=&quot;4&quot;&gt;列表项B&lt;/li&gt;&lt;li&gt;列表项C&lt;/li&gt;&lt;/ol&gt;上面代码中，value属性指定第二个列表项的编号是4，因此三个列表项的编号，分别为1、4、5。&lt;dl&gt;，&lt;dt&gt;，&lt;dd&gt;&lt;dl&gt;标签是一个块级元素，表示一组术语的列表（descriptionlist）。术语名（descriptionterm）由&lt;dt&gt;标签定义，术语解释（descriptiondetail）由&lt;dd&gt;标签定义。&lt;dl&gt;常用来定义词汇表。&lt;dl&gt;&lt;dt&gt;CPU&lt;/dt&gt;&lt;dd&gt;中央处理器&lt;/dd&gt;&lt;dt&gt;Memory&lt;/dt&gt;&lt;dd&gt;内存&lt;/dd&gt;&lt;dt&gt;HardDisk&lt;/dt&gt;&lt;dd&gt;硬盘&lt;/dd&gt;&lt;/dl&gt;&lt;dt&gt;和&lt;dd&gt;都是块级元素，&lt;dd&gt;默认会在&lt;dt&gt;下方缩进显示。上面代码的默认渲染结果如下。CPU中央处理器Memory内存HardDisk硬盘多个术语（&lt;dt&gt;）对应一个解释（&lt;dd&gt;），或者多个解释（&lt;dd&gt;）对应一个术语（&lt;dt&gt;），都是合法的。&lt;dl&gt;&lt;dt&gt;A&lt;/dt&gt;&lt;dt&gt;B&lt;/dt&gt;&lt;dd&gt;C&lt;/dd&gt;&lt;dt&gt;D&lt;/dt&gt;&lt;dd&gt;E&lt;/dd&gt;&lt;dd&gt;F&lt;/dd&gt;&lt;/dl&gt;上面代码中，A和B有共同的解释C，而D有两个解释E和F。","link":"https://18279493170.github.io/3cHNIqT9x/"},{"title":"html之文本标签","content":"文本标签历史上，网页的主要功能是文本展示。所以，HTML提供了大量的文本处理标签。&lt;div&gt;&lt;div&gt;是一个通用标签，表示一个区块（division）。它没有语义，如果网页需要一个块级元素容器，又没有其他合适的标签，就可以使用这个标签。它的最常见用途就是提供CSS的钩子，用来指定各种样式。所以在早期，下面层层包裹的&lt;div&gt;就很常见。&lt;divclass=&quot;main&quot;&gt;&lt;divclass=&quot;article&quot;&gt;&lt;divclass=&quot;title&quot;&gt;&lt;h1&gt;文章标题&lt;/h1&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;上面代码读起来很费力，因为不带有语义。后来，HTML5就提出了语义标签，改进了上面的代码。&lt;main&gt;&lt;article&gt;&lt;header&gt;&lt;h1&gt;文章标题&lt;/h1&gt;&lt;/header&gt;&lt;/article&gt;&lt;/main&gt;&lt;div&gt;是无语义的块级元素。下面的例子使用&lt;div&gt;，将图像和文字组合在一起，构成一个警告区块。&lt;div&gt;&lt;imgsrc=&quot;warning.jpg&quot;alt=&quot;警告&quot;&gt;&lt;p&gt;小心&lt;/p&gt;&lt;/div&gt;只要样式上需要多个块级元素组合在一起，就可以使用&lt;div&gt;。但是，这应该是最后的措施，带有语义的块级标签（比如&lt;article&gt;、&lt;section&gt;、&lt;aside&gt;、&lt;nav&gt;等）始终应该优先使用，当且仅当没有其他语义元素合适时，才可以使用&lt;div&gt;。&lt;p&gt;&lt;p&gt;标签是一个块级元素，代表文章的一个段落（paragraph）。不仅是文本，任何想以段落显示的内容，比如图片和表单项，都可以放进&lt;p&gt;元素。&lt;p&gt;helloworld&lt;/p&gt;上面代码就是一个简单的段落。&lt;span&gt;&lt;span&gt;是一个通用目的的行内标签（即不会产生换行），不带有任何语义。它通常用作CSS样式的钩子，如果需要对某些行内内容指定样式，就可以把它们放置在&lt;span&gt;。&lt;p&gt;这是一句&lt;span&gt;重要&lt;/span&gt;的句子。&lt;/p&gt;上面代码中，句子里面需要强调的部分，就可以放在&lt;span&gt;。&lt;br&gt;，&lt;wbr&gt;&lt;br&gt;让网页产生一个换行效果。该标签是单独使用的，没有闭合标签。hello&lt;br&gt;world浏览器渲染上面代码时，会分成两行，hello和world各占一行。&lt;br&gt;对于诗歌和地址的换行非常有用。&lt;p&gt;床前明月光，&lt;br&gt;疑是地上霜。&lt;br&gt;举头望明月，&lt;br&gt;低头思故乡。&lt;/p&gt;上面的代码如果不用&lt;br&gt;，会显示成一行。注意，块级元素的间隔，不要使用&lt;br&gt;来产生，而要使用CSS指定。&lt;p&gt;第一段&lt;/p&gt;&lt;br&gt;&lt;br&gt;&lt;p&gt;第二段&lt;/p&gt;上面的代码希望段落之间有两个换行，这时不应该使用&lt;br&gt;，而应该使用CSS。&lt;wbr&gt;标签跟&lt;br&gt;很相似，表示一个可选的断行。如果一行的宽度足够，则不断行；如果宽度不够，需要断行，就在&lt;wbr&gt;的位置的断行。它是为了防止浏览器在一个很长的单词中间，不正确地断行或者不断行，所以事先标明可以断行的位置，主要用于欧洲一些单词很长的语言或者URL的断行。&lt;p&gt;Fernstraßen&lt;wbr&gt;bau&lt;wbr&gt;privat&lt;wbr&gt;finanzierungs&lt;wbr&gt;gesetz&lt;/p&gt;上面代码是一个很长的德语单词，为了防止不正确断行，事先用&lt;wbr&gt;告诉浏览器，可以选择在哪里断行。&lt;hr&gt;&lt;hr&gt;用来在一篇文章中分隔两个不同的主题，浏览器会将其渲染为一根水平线。该标签是单独使用的，没有闭合标签。&lt;p&gt;第一个主题&lt;/p&gt;&lt;hr&gt;&lt;p&gt;第二个主题&lt;/p&gt;上面代码的渲染结果是，两段之间会出现一根水平线。该标签是历史遗留下来的，建议尽量避免使用。主题之间的分隔可以使用&lt;section&gt;，如果想要水平线的效果，可以使用CSS。&lt;pre&gt;&lt;pre&gt;是一个块级元素，表示保留原来的格式（preformatted），即浏览器会保留该标签内部原始的换行和空格。浏览器默认以等宽字体显示标签内容。&lt;pre&gt;helloworld&lt;/pre&gt;上面代码中，换行和连续空格都会由于&lt;pre&gt;标签，而被保留下来，浏览器按照原样输出。注意，HTML标签在&lt;pre&gt;里面还是起作用的。&lt;pre&gt;只保留空格和换行，不会保留HTML标签。&lt;pre&gt;&lt;strong&gt;helloworld&lt;/strong&gt;&lt;/pre&gt;上面代码中，&lt;pre&gt;标签的内容会加粗显示。&lt;strong&gt;，&lt;b&gt;&lt;strong&gt;是一个行内元素，表示它包含的内容具有很强的重要性，需要引起注意。浏览器会以粗体显示内容。&lt;p&gt;开会时间是&lt;strong&gt;下午两点&lt;/strong&gt;。&lt;/p&gt;&lt;b&gt;与&lt;strong&gt;很相似，也表示它包含的内容需要引起注意，浏览器会加粗显示。它是Boldface的缩写。&lt;p&gt;开会时间是&lt;b&gt;下午两点&lt;/b&gt;。&lt;/p&gt;它与&lt;strong&gt;的区别在于，由于历史原因，它没有语义，是一个纯样式的标签，违反了语义与样式分离的原则，因此不建议使用，应该优先使用&lt;strong&gt;标签。&lt;em&gt;，&lt;i&gt;&lt;em&gt;是一个行内标签，表示强调（emphasize），浏览器会以斜体显示它包含的内容。&lt;p&gt;我们&lt;em&gt;已经&lt;/em&gt;讨论过这件事情了。&lt;/p&gt;虽然浏览器通常会以斜体显示&lt;em&gt;，但无法保证一定如此，所以最好还是用CSS指定一下这个标签的样式。&lt;i&gt;标签与&lt;em&gt;相似，也表示与其他地方有所区别，浏览器会以斜体显示。它是Italic的缩写。&lt;p&gt;我心想，这件事是&lt;i&gt;真的&lt;/i&gt;吗？&lt;/p&gt;&lt;i&gt;标签的语义不强，更接近是一个纯样式的标签，建议优先使用&lt;em&gt;标签代替它。&lt;sub&gt;，&lt;sup&gt;，&lt;var&gt;&lt;sub&gt;标签将内容变为下标，&lt;sup&gt;标签将内容变为上标。它们都是行内元素，主要用于数学公式、分子式等。&lt;p&gt;水分子是H&lt;sub&gt;2&lt;/sub&gt;O。&lt;/p&gt;&lt;var&gt;标签表示代码或数学公式的变量。&lt;p&gt;勾股定理是&lt;var&gt;a&lt;/var&gt;&lt;sup&gt;2&lt;/sup&gt;+&lt;var&gt;b&lt;/var&gt;&lt;sup&gt;2&lt;/sup&gt;=&lt;var&gt;c&lt;/var&gt;&lt;sup&gt;2&lt;/sup&gt;。&lt;/p&gt;&lt;u&gt;，&lt;s&gt;&lt;u&gt;标签是一个行内元素，表示对内容提供某种注释，提醒用户这里可能有问题，基本上只用来表示拼写错误。浏览器默认以下划线渲染内容。&lt;p&gt;一个容易写错的成语是把&lt;em&gt;安分守己&lt;/em&gt;写成&lt;u&gt;安份守己&lt;/u&gt;。&lt;/p&gt;上面代码中，&lt;u&gt;提示用户这是一个拼写错误，“安份守己”的下方会有一个下划线。注意，&lt;u&gt;会产生下划线，由于链接也默认带有下划线，所以必须非常小心使用&lt;u&gt;标签，避免用户误以为可以点击。万一确有必要使用，最好使用CSS改变&lt;u&gt;的默认样式。&lt;s&gt;标签是一个行内元素，为内容加上删除线。&lt;p&gt;今天特价商品：&lt;s&gt;三文鱼&lt;/s&gt;（售完）&lt;/p&gt;上面代码中，“三文鱼”会有一根删除线。&lt;blockquote&gt;，&lt;cite&gt;，&lt;q&gt;&lt;blockquote&gt;是一个块级标签，表示引用他人的话。浏览器会在样式上，与正常文本区别显示。&lt;blockquotecite=&quot;https://quote.example.com&quot;&gt;&lt;p&gt;天才就是1%的天赋和99%的汗水。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;标签有一个cite属性，它的值是一个网址，表示引言来源，不会显示在网页上。&lt;cite&gt;标签表示引言出处或者作者，浏览器默认使用斜体显示这部分内容。&lt;blockquotecite=&quot;https://quote.example.com&quot;&gt;&lt;p&gt;天才就是1%的天赋和99%的汗水。&lt;/p&gt;&lt;/blockquote&gt;&lt;cite&gt;--爱迪生&lt;/cite&gt;&lt;cite&gt;不一定跟&lt;blockquote&gt;一起使用。如果文章中提到资料来源，也可以单独使用。&lt;p&gt;更多资料请看&lt;cite&gt;维基百科&lt;/cite&gt;。&lt;/p&gt;&lt;q&gt;是一个行内标签，也表示引用。它与&lt;blockquote&gt;的区别，就是它不会产生换行。&lt;p&gt;莎士比亚的《哈姆雷特》有一句著名的台词：&lt;qcite=&quot;https://quote.example.com&quot;&gt;活着还是死亡，这是一个问题。&lt;/q&gt;&lt;/p&gt;上面例子中，引言部分跟前面的说明部分是在同一行里面。另外，跟&lt;blockquote&gt;一样，&lt;q&gt;也有cite属性，表示引言的来源网址。注意，浏览器默认会斜体显示&lt;q&gt;的内容，并且会自动添加半角的双引号。所以，引用中文内容时要小心。&lt;code&gt;&lt;code&gt;标签是一个行内元素，表示标签内容是计算机代码，浏览器默认会以等宽字体显示。&lt;code&gt;alert()&lt;/code&gt;的作用是让网页弹出一个提示框。如果要表示多行代码，&lt;code&gt;标签必须放在&lt;pre&gt;内部。&lt;code&gt;本身仅表示一行代码。&lt;pre&gt;&lt;code&gt;leta=1;console.log(a);&lt;/code&gt;&lt;/pre&gt;&lt;kbd&gt;，&lt;samp&gt;&lt;kbd&gt;标签是一个行内元素，原意是用户从键盘输入的内容，现在扩展到各种输入，包括语音输入。浏览器默认以等宽字体显示标签内容。&lt;p&gt;Windows可以按下&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;重启。&lt;/p&gt;&lt;kbd&gt;可以嵌套，方便指定样式。&lt;p&gt;Windows可以按下&lt;kbd&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;&lt;/kbd&gt;重启。&lt;/p&gt;&lt;samp&gt;标签是一个行内元素，表示计算机程序输出内容的一个例子。浏览器默认以等宽字体显示。&lt;p&gt;如果使用没有定义的变量，浏览器会报错：&lt;samp&gt;UncaughtReferenceError:fooisnotdefined&lt;/samp&gt;。&lt;/p&gt;&lt;mark&gt;&lt;mark&gt;是一个行内标签，表示突出显示的内容。Chrome浏览器默认会以亮黄色背景，显示该标签的内容。&lt;p&gt;我们讨论以后决定，&lt;mark&gt;运行会在下周三举办&lt;/mark&gt;。&lt;/p&gt;&lt;mark&gt;很适合在引用的内容（&lt;q&gt;或&lt;blockquote&gt;）中，标记出需要关注的句子。&lt;blockquote&gt;床前明月光，疑是地上霜。&lt;mark&gt;举头望明月，低头思故乡。&lt;/mark&gt;&lt;/blockquote&gt;除了标记感兴趣的文本，&lt;mark&gt;还可以用于在搜索结果中，标记出匹配的关键词。注意，不要只为了高亮的效果，而使用这个标签，因为不能保证浏览器的处理方式。如果要保证高亮，还是要使用CSS样式。&lt;small&gt;&lt;small&gt;是一个行内标签，浏览器会将它包含的内容，以小一号的字号显示，不需要使用CSS样式。它通常用于文章附带的版权信息或法律信息。&lt;p&gt;文章正文&lt;/p&gt;&lt;p&gt;&lt;small&gt;以上内容使用创意共享许可证。&lt;/small&gt;&lt;/p&gt;&lt;time&gt;，&lt;data&gt;&lt;time&gt;是一个行内标签，为跟时间相关的内容提供机器可读的格式。&lt;p&gt;运动会预定&lt;timedatetime=&quot;2015-06-10&quot;&gt;下周三&lt;/time&gt;举行。&lt;/p&gt;上面代码中，&lt;time&gt;表示下周三的具体日期。这方便搜索引擎抓取，或者下一步的其他处理。&lt;time&gt;的datetime属性，用来指定机器可读的日期，可以有多种格式。有效年份：2011有效月份：2011-11有效日期：2011-11-18无年份的日期：11-18年度的第几周：2011-W47有效时间：14:54、14:54:39、14:54:39.929日期和时间：2011-11-18T14:54:39.929&lt;p&gt;音乐会在&lt;timedatetime=&quot;20:00&quot;&gt;晚上八点&lt;/time&gt;开始。&lt;/p&gt;&lt;data&gt;标签与&lt;time&gt;类似，也是提供机器可读的内容，但是用于非时间的场合。&lt;p&gt;本次马拉松比赛第一名是&lt;datavalue=&quot;39&quot;&gt;张三&lt;/data&gt;&lt;/p&gt;。上面代码中，选手的机读数据就放在&lt;data&gt;标签的value属性。&lt;address&gt;&lt;address&gt;标签是一个块级元素，表示某人或某个组织的联系方式。&lt;p&gt;作者的联系方式：&lt;/p&gt;&lt;address&gt;&lt;p&gt;&lt;ahref=&quot;mailto:foo@example.com&quot;&gt;foo@example.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;ahref=&quot;tel:+555-34762301&quot;&gt;+555-34762301&lt;/a&gt;&lt;/p&gt;&lt;/address&gt;该标签有几个注意点。（1）如果是文章里提到的地址（比如提到搬家前的地址），而不是联系信息，不要使用&lt;address&gt;标签。（2）&lt;address&gt;的内容不得有非联系信息，比如发布日期。（3）&lt;address&gt;不能嵌套，并且内部不能有标题标签（&lt;h1&gt;~&lt;h6&gt;），也不能有&lt;article&gt;、&lt;aside&gt;、&lt;section&gt;、&lt;nav&gt;、&lt;header&gt;、&lt;footer&gt;等标签。（4）通常，&lt;address&gt;会放在&lt;footer&gt;里面，下面是一个例子。&lt;footer&gt;&lt;address&gt;文章的相关问题请联系&lt;ahref=&quot;mailto:zhangsan@example.com&quot;&gt;张三McClure&lt;/a&gt;。&lt;/address&gt;&lt;/footer&gt;&lt;abbr&gt;&lt;abbr&gt;标签是一个行内元素，表示标签内容是一个缩写。它的title属性给出缩写的完整形式，或者缩写的描述。鼠标悬停在该元素上方时，title属性值作为提示，会完整显示出来。&lt;abbrtitle=&quot;HyperTextMarkupLanguage&quot;&gt;HTML&lt;/abbr&gt;注意，某些浏览器可能对该标签提供圆点下划线。&lt;ins&gt;，&lt;del&gt;&lt;ins&gt;标签是一个行内元素，表示原始文档添加（insert）的内容。&lt;del&gt;与之类似，表示删除（delete）的内容。它们通常用于展示文档的删改。&lt;del&gt;&lt;p&gt;会议定于5月8日举行。&lt;/p&gt;&lt;/del&gt;&lt;ins&gt;&lt;p&gt;会议定于5月9日举行。&lt;/p&gt;&lt;/ins&gt;浏览器默认为&lt;del&gt;标签的内容加上删除线，为&lt;ins&gt;标签的内容加上下划线。这两个标签都有以下属性。cite：该属性的值是一个URL，表示该网址可以解释本次删改。datetime：表示删改发生的时间。&lt;inscite=&quot;./why.html&quot;datetime=&quot;2018-05&quot;&gt;&lt;p&gt;项目比原定时间提前两周结束。&lt;/p&gt;&lt;/ins&gt;&lt;dfn&gt;&lt;dfn&gt;是一个行内元素，表示标签内容是一个术语（definition），本段或本句包含它的定义。&lt;p&gt;通过TCP/IP协议连接的全球性计算机网络，叫做&lt;dfn&gt;Internet&lt;/dfn&gt;。&lt;/p&gt;为了脚本操作的方便，可以把术语的定义写入&lt;dfn&gt;标签的title属性。&lt;p&gt;通过TCP/IP协议连接的全球性计算机网络，叫做&lt;dfntitle=&quot;全球性计算机网络&quot;&gt;Internet&lt;/dfn&gt;。&lt;/p&gt;上面代码中，title属性的一个作用是，鼠标悬浮的时候，术语的解释会以提示的形式显示出来。某些时候，术语本身是一个缩写，这时&lt;dfn&gt;和&lt;abbr&gt;可以结合使用。&lt;p&gt;&lt;dfn&gt;&lt;abbrtitle=&quot;acquiredimmunedeficiencysyndrome&quot;&gt;AIDS&lt;/abbr&gt;&lt;/dfn&gt;的全称是获得性免疫缺陷综合征。&lt;/p&gt;&lt;ruby&gt;&lt;ruby&gt;标签表示文字的语音注释，主要用于东亚文字，比如汉语拼音和日语的片假名。它默认将语音注释，以小字体显示在文字的上方。&lt;ruby&gt;汉&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;字&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;上面代码的渲染结果是，汉字上方有小字体的拼音hanzi。&lt;ruby&gt;标签是一个行内元素，也是一个容器标签。如果要使用语音注释，就必须把文字和注释都放在这个标签里面。&lt;ruby&gt;的内部还有许多配套的标签。（1）&lt;rp&gt;&lt;rp&gt;标签的用处，是为不支持语音注释的浏览器，提供一个兼容方案。对于那些支持语音注释的浏览器，该标签的内容不显示。&lt;rp&gt;标签一般用于放置圆括号，如果遇到不支持的浏览器，就会将语音注释显示在括号里面。&lt;ruby&gt;汉&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;字&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;上面代码在不支持语音注释的浏览器中，渲染结果为汉(han)字(zi)。遇到支持语音注释的浏览器，就不会显示圆括号。（2）&lt;rt&gt;&lt;rt&gt;标签用于放置语音注释。（3）&lt;rb&gt;&lt;rb&gt;标签用于划分文字单位，与语音注释一一对应。&lt;ruby&gt;&lt;rb&gt;汉&lt;/rb&gt;&lt;rb&gt;字&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;上面例子中，汉字这两个字是写在一起的，&lt;rb&gt;标签用于每个字划分出来，跟&lt;rt&gt;标签一一对应。注意，Chrome浏览器目前不支持这个标签。（4）&lt;rbc&gt;，&lt;rtc&gt;&lt;rbc&gt;标签表示一组文字，通常包含多个&lt;rb&gt;元素。&lt;rtc&gt;标签表示一组语音注释，跟&lt;rbc&gt;对应。&lt;rubystyle=&quot;ruby-position:under;&quot;&gt;&lt;rbc&gt;&lt;rb&gt;汉&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;rb&gt;字&lt;/rb&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/rbc&gt;&lt;rtcstyle=&quot;ruby-position:over;&quot;&gt;&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Chinese&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/rtc&gt;&lt;/ruby&gt;上面例子中，汉字这两个字有两组语音注释，分别是汉语拼音与英语。一组语音注释放在&lt;rbc&gt;标签中，另一组语音注释放在&lt;rtc&gt;，用来对应&lt;rbc&gt;。同时，分别使用style属性，指定汉语拼音显示在文字下方，英语显示在文字上方。注意，Chrome浏览器目前不支持这两个标签。&lt;bdo&gt;，&lt;bdi&gt;大部分文字的阅读方向是从左到右，但是有些文字的方向是从右到左，比如阿拉伯语、希伯来语等。&lt;bdo&gt;标签是一个行内元素，表示文字方向与网页主体内容的方向不一致。&lt;p&gt;床前明月光，&lt;bdodir=&quot;rtl&quot;&gt;霜上地是疑&lt;/bdo&gt;。&lt;/p&gt;上面代码中，&lt;bdo&gt;标签里面的文字，会以相反的方向渲染，结果就是“床前明月光，疑是地上霜”。&lt;bdo&gt;的dir属性，指定具体的文字方向。它有两个值，ltr表示从左到右，rtl表示从右到左。&lt;bdi&gt;标签用于不确定文字方向的情况。比如，网页有一个部分是用户输入的内容，但是不知道输入内容的文字方向。这种情况就可以使用&lt;bdi&gt;标签，告诉浏览器，不确定文字的方向，由浏览器自己决定。&lt;p&gt;&lt;bdi&gt;床前明月光，疑是地上霜。&lt;/bdi&gt;&lt;/p&gt;","link":"https://18279493170.github.io/4n4Ej9sHT/"},{"title":"css之边框，表格与列表","content":"边框样式（border）CSS中的边框是围绕着元素内容和内边距的一条或多条线段，您可以自定义这些线段的样式、宽度以及颜色。您可以通过下面几个属性分别定义边框的样式、宽度和颜色：border-style：设置边框的样式，例如实线、虚线等；border-width：设置边框的宽度（厚度）；border-color：设置边框的颜色；border：上面三个边框属性的缩写。border-styleborder-style属性用来设置元素中所有边框的样式，或者单独为某个边框设置样式border-style:border-top-styleborder-right-styleborder-bottom-styleborder-left-style;none无边框hidden隐藏边框，与&quot;none&quot;类似dotted定义点状虚线边框dashed定义虚线边框solid定义实线边框double定义双实线边框，双实线边框的宽度等于border-width的值groove定义3D凹槽边框，其效果取决于border-color的值ridge定义3D垄状边框，其效果取决于border-color的值inset定义3D嵌入边框，其效果取决于border-color的值outset定义3D突出边框，其效果取决于border-color的值inherit从父元素继承边框样式border-style属性有多种不同的用法：如果提供全部的四个参数，则会按照上、右、下、左的顺序分别设置边框四个边的样式；如果提供三个参数，那么第一个参数会作用在上边框，第二个参数会作用在左、右两个边框上，第三个参数会作用在下边框上；如果提供两个参数，那么第一个参数会作用在上、下两个边框上，第二个参数会作用在左、右两个边框上；如果只提供一个参数，这个参数将同时作用在四个边框上。除了可以使用border-style属性设置元素的边框样式外，您还可以使用下面的属性分别设置元素上、下、左、右四个边框的样式：border-bottom-style：设置下边框的样式；border-top-style：设置上边框的样式；border-left-style：设置左边框的样式；border-right-style：设置右边框的样式。border-style:none;border-top-style:solid;border-right-style:double;border-bottom-style:dashed;border-left-style:dotted;border-widthborder-width属性用来设置元素中所有边框的宽度，或者单独为某个边框设置宽度border-width:border-top-widthborder-right-widthborder-bottom-widthborder-left-width;thin定义较细的边框medium默认值，定义中等宽度的边框thick定义较粗的边框length使用数值加单位的形式设置具体的边框宽度，例如2pxinherit从父元素继承边框的宽度thin、medium、thick三个关键字并没有固定的值，它们的值取决于浏览器，例如在Chrome浏览器中三个关键字的值分别为1px、3px、5px。同border-style属性相同，border-width属性同样支持多种不同的用法：如果提供全部的四个参数，则会按照上、右、下、左的顺序分别设置边框四个边的宽度；如果提供三个参数，那么第一个参数会作用在上边框，第二个参数会作用在左、右两个边框上，第三个参数会作用在下边框上；如果提供两个参数，那么第一个参数会作用在上、下两个边框上，第二个参数会作用在左、右两个边框上；如果只提供一个参数，这个参数将同时作用在四个边框上。除了可以使用border-width属性设置元素的边框宽度外，您还可以使用下面的属性分别设置元素上、下、左、右四个边框的宽度：border-bottom-width：设置下边框的宽度；border-top-width：设置上边框的宽度；border-left-width：设置左边框的宽度；border-right-width：设置右边框的宽度。border-width:2px5px;border-top-width:1px;border-right-width:2px;border-bottom-width:3px;border-left-width:4px;border-colorborder-color属性用来设置元素中所有边框的颜色，或者单独为某个边框设置颜色border-color:border-top-colorborder-right-colorborder-bottom-colorborder-left-color;color_name使用颜色名称来设置边框的颜色，例如redhex_number使用颜色的十六进制值来设置边框的颜色，例如#ff0000rgb_number使用rgb()函数设置边框的颜色，例如rgb(255,0,0)transparent默认值，设置边框颜色为透明inherit从父元素继承边框的颜色同border-style属性相同，border-color属性同样支持多种不同的用法：如果提供全部的四个参数，则会按照上、右、下、左的顺序分别设置边框四个边的颜色；如果提供三个参数，那么第一个参数会作用在上边框，第二个参数会作用在左、右两个边框上，第三个参数会作用在下边框上；如果提供两个参数，那么第一个参数会作用在上、下两个边框上，第二个参数会作用在左、右两个边框上；如果只提供一个参数，这个参数将同时作用在四个边框上。除了可以使用border-color属性设置元素的边框颜色外，您还可以使用下面的属性分别设置元素上、下、左、右四个边框的颜色：border-bottom-color：设置下边框的颜色；border-top-color：设置上边框的颜色；border-left-color：设置左边框的颜色；border-right-color：设置右边框的颜色。border-color:#0000CC;border-top-color:#009900;/*绿色*/border-right-color:#FF0000;/*红色*/border-bottom-color:#330000;/*黑色*/border-left-color:#0000CC;/*蓝色*/borderborder属性是上面介绍的border-width、border-style、border-color三种属性的简写，使用border属性可以同时定义上述三个属性border:border-widthborder-styleborder-color;其中border-width用来设置边框的宽度；border-style用来设置边框的样式；border-color用来设置边框的颜色。border:2pxsolidgreen;提示：border属性的三个参数（border-width、border-style、border-color）并不需要遵守固定的顺序，将它们的顺序打乱也是可以的。另外，也可以省略其中的某个参数，例如border:soildred;，省略的参数将被设置为该参数的默认值。除了可以使用border属性统一设置边框的宽度、样式、颜色外，您还可以使用下面的属性分别设置元素上、下、左、右四个边框的宽度、样式、颜色：border-bottom：统一设置下边框的宽度、样式、颜色；border-top：统一设置上边框的宽度、样式、颜色；border-left：统一设置左边框的宽度、样式、颜色；border-right：统一设置右边框的宽度、样式、颜色。&lt;style&gt;p{width:0px;margin:5px;float:left;}.top{border:50pxsolid;border-color:redtransparenttransparent;}.bottom{border-width:050px50px;border-style:solid;border-color:transparenttransparentred;}.left{border-top:50pxsolidtransparent;border-left:50pxsolidblack;border-right:50pxsolidtransparent;border-bottom:50pxsolidtransparent;}.right{border-width:50px50px50px0px;border-style:solid;border-color:transparentredtransparenttransparent;}&lt;/style&gt;表格样式（table）在网页中我们通常使用表格来展示一些数据，例如成绩表、财务报表等，但是默认情况下表格的样式并不美观，甚至不符合页面的风格。CSS中提供了一些属性，通过这些属性您可以修改表格的样式，大大改善表格的外观。table-layout：设置表格的布局算法，布局算法有两种，分别为固定表格布局算法和自动表格布局算法；border-collapse：设置表格中单元格的边框是合并在一起还是按照标准的HTML样式分开；border-spacing：设置当表格边框分开时，相邻两个边框在横向和纵向上的间距；caption-side：设置表格标题相对于表格的位置；empty-cells：设置当表格的单元格中没有内容时，是否显示该单元格的边框。table-layouttable-layout属性用来设置表格布局时所用的布局算法automatic默认值，自定表格布局，表示表格中每列的宽度视单元格中的内容而定fixed固定表格布局，表示表格的宽度由列宽度、单元格边框、单元格之间的间距等因素而定inherit从父元素继承table-layout属性的值automatic在自动表格布局中，列的宽度视单元格中的内容（没有换行的最宽内容）而定，也就是说如果某个单元格的宽度为100px，但单元格中内容所占据的宽度要大于100px，这就会导致单元格中的内容将单元格撑大。正是因为这一特点，此种算法可能会比较慢。fixed固定表格布局允许浏览器更快地对表格进行布局。在固定表格布局中，表格的水平宽度仅取决于列宽度、表格边框宽度、单元格间距等因素，与单元格中的内容无关。也就是说，表格中超出表格宽度的内容可能会被忽略。border-collapseborder-collapse属性用来设置是否合并表格中相邻的边框separate默认值，相邻的两个边框是分开的，使用它不会忽略border-spacing和empty-cells属性collapse相邻的两个边框会合并为一个单一的边框，使用它会忽略border-spacing和empty-cells属性inherit从父元素继承border-collapse属性的值.table_one{border-collapse:separate;}.table_two{margin-left:20px;border-collapse:collapse;}默认情况下表格的边框是隐藏的，我们需要使用&lt;table&gt;标签的border属性来显示边框，另外，您也可以使用CSS的border属性来为表格设置边框&lt;tableclass=&quot;table_two&quot;border=&quot;1px&quot;&gt;border:1pxsolidblack;border-spacingborder-spacing属性可以设置相邻单元格边框之间的距离（仅在border-collapse属性为separate时才有效），它的效果等同于标签的cellspacing属性（即border-spacing:0;等同于cellspacing=&quot;0&quot;）border-spacing:lengthlength;参数length由数值和单位组成，表示相邻单元格边框之间的距离length以数值加单位的形式设置相邻边框之间的间距，例如2px，不允许使用负值。如果只定义一个length参数，那么这个值将同时作用于横向和纵向的间距；如果同时定义两个length参数，那么第一个length参数表示相邻边框的横向间距，第二个length参数表示相邻边框的纵向间距inherit从父元素继承border-spacing属性的值border-spacing:15px10px;caption-sidecaption-side属性可以设置表格标题的位置top默认值，将表格标题定位在表格正上方bottom将表格标题定位在表格正下方inherit从父元素继承caption-side属性的值caption-side:top;empty-cellsempty-cells属性用来设置当某个单元格中没有内容时，是否显示这个空单元格（仅在border-collapse属性为separate时才有效）hide隐藏空单元格周围的边框show默认值，显示空单元格周围的边框inherit从父元素继承empty-cells属性的值empty-cells:hide;list-style（列表样式）在网页中很多地方都会用到列表，例如导航菜单、新闻列表、商品分类等等。您除了可以使用HTML中的一些属性来对列表进行简单的设置外，在CSS中也提供了几种专门用来设置和格式化列表的属性，如下所示：list-style-type：设置列表项前面标记的形状（外观）；list-style-position：设置标记和列表中文本之间的距离；list-style-image：使用图像代替默认的标记；list-style：统一设置上面的三个属性。list-style-type使用list-style-type属性可以设置列表中每个列表项前标记的样式none无标记disc默认值，标记为实心圆circle将标记设置为空心圆square将标记设置为实心方块decimal将标记设置为数字decimal-leading-zero将标记设置为以0开头的数字标记，例如01、02、03lower-roman将标记设置为小写罗马数字，例如i、ii、iii、iv、vupper-roman将标记设置为大写罗马数字，例如I、II、III、IV、Vlower-alpha将标记设置为小写英文字母，例如a、b、c、d、eupper-alpha将标记设置为大写英文字母，例如A、B、C、D、Elower-greek将标记设置为小写希腊字母，例如α、β、γ、δ、εlower-latin将标记设置为小写拉丁字母，例如a、b、c、d、eupper-latin将标记设置为大写拉丁字母，例如A、B、C、D、Ehebrew将标记设置为传统的希伯来编号armenian将标记设置为传统的亚美尼亚编号georgian将标记设置为传统的乔治亚编号cjk-ideographic将标记设置为中文数字，例如一、二、三、四、五hiragana将标记设置为日文平假名字符，例如あ、い、う、え、おkatakana将标记设置为日文片假名字符，例如ア、イ、ウ、エ、オhiragana-iroha将标记设置为日文平假名序号katakana-iroha将标记设置为日文片假名序号list-style-type:circle;list-style-position使用list-style-position属性可以设置在何处放置列表项前的标记inside列表项前的标记放置在之后的文本以内，列表项中的文本会根据标记对齐outside默认值，保持标记位于文本的左侧，列表项前的标记放置在文本以外，并且列表项中的文本不会根据标记对齐inherit从父元素继承list-style-position属性的值list-style-type:lower-roman;list-style-position:inside;list-style-image通过list-style-image属性可以将列表项前的标记替换为一个图像URL图像的路径none默认值，不显示任何图像inherit从父元素继承list-style-image属性的值list-style-image:url('./css_icon.png');list-stylelist-style属性是上述三个属性（list-style-type、list-style-position、list-style-image）的简写，使用list-style可以同时设置上面的三个属性list-style:list-style-type||list-style-position||list-style-image;提示：在使用list-style属性时，需要按照上面的顺序来为参数赋值，只要遵守参数的顺序，即使忽略其中的一项或多项也是可以的，例如list-style:none;、list-style:circleinside;，被忽略的参数会设置为参数对应的默认值。list-style:lower-greekinside;","link":"https://18279493170.github.io/vrTvzIQJV/"},{"title":"html之语义结构","content":"网页的语义结构HTML标签的名称都带有语义（semantic），使用时应该尽量符合标签的语义，不要用错误语义的标签。语义良好的网页，天然具有良好的结构，对于开发者易读易写，容易维护，也能帮助计算机更好地处理网页内容。含义HTML标签的一个重要作用，就是声明网页元素的性质，使得用户只看标签，就能了解这个元素的意义，阅读HTML源码就能了解网页的大致结构。这被称为HTML的语义原则。下面就是一个典型的语义结构的网页。&lt;body&gt;&lt;header&gt;页眉&lt;/header&gt;&lt;main&gt;&lt;article&gt;&lt;h1&gt;文章标题&lt;/h1&gt;&lt;p&gt;文章内容&lt;/p&gt;&lt;/article&gt;&lt;/main&gt;&lt;footer&gt;页尾&lt;/footer&gt;&lt;/body&gt;只看上面的代码，就可以知道，页面分成页眉（&lt;header&gt;）、主体（&lt;main&gt;）、页尾（&lt;footer&gt;）三个部分。编写HTML网页，第一步就是写出语义结构的网页骨架。常用标签&lt;header&gt;&lt;header&gt;标签可以用在多个场景，既可以表示整个网页的头部，也可以表示一篇文章或者一个区块的头部。如果用在网页的头部，就称为“页眉”。网站导航和搜索栏通常会放在&lt;header&gt;里面。&lt;header&gt;&lt;h1&gt;公司名称&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;ahref=&quot;/home&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;ahref=&quot;/about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;ahref=&quot;/contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;formtarget=&quot;/search&quot;&gt;&lt;inputname=&quot;q&quot;type=&quot;search&quot;/&gt;&lt;inputtype=&quot;submit&quot;/&gt;&lt;/form&gt;&lt;/header&gt;如果&lt;header&gt;用在文章的头部，则可以把文章标题、作者等信息放进去。&lt;article&gt;&lt;header&gt;&lt;h2&gt;文章标题&lt;/h2&gt;&lt;p&gt;张三，发表于2010年1月1日&lt;/p&gt;&lt;/header&gt;&lt;/article&gt;由于&lt;header&gt;可以用在多种场景，所以一个页面可能包含多个&lt;header&gt;，但是一个具体的场景里面只能包含一个，比如网页的页眉只能有一个。另外，&lt;header&gt;里面不能包含另一个&lt;header&gt;或&lt;footer&gt;。&lt;footer&gt;&lt;footer&gt;标签表示网页、文章或章节的尾部。如果用于整张网页的尾部，就称为“页尾”，通常包含版权信息或者其他相关信息。&lt;body&gt;&lt;footer&gt;&lt;p&gt;©2018xxx公司&lt;/p&gt;&lt;/footer&gt;&lt;/body&gt;上面代码中，版权信息放在&lt;footer&gt;里面。&lt;footer&gt;也可以放在文章里面。&lt;article&gt;&lt;header&gt;&lt;h1&gt;文章标题&lt;/h1&gt;&lt;/header&gt;&lt;footer&gt;&lt;p&gt;©禁止转贴&lt;/p&gt;&lt;/footer&gt;&lt;/article&gt;&lt;footer&gt;不能嵌套，即内部不能放置另一个&lt;footer&gt;，也不能放置&lt;header&gt;。&lt;main&gt;&lt;main&gt;标签表示页面的主体内容，一个页面只能有一个&lt;main&gt;。&lt;body&gt;&lt;header&gt;页眉&lt;/header&gt;&lt;main&gt;&lt;article&gt;文章&lt;/article&gt;&lt;/main&gt;&lt;aside&gt;侧边栏&lt;/aside&gt;&lt;footer&gt;页尾&lt;/footer&gt;&lt;/body&gt;上面代码就是最典型的页面结构。注意，&lt;main&gt;是顶层标签，不能放置在&lt;header&gt;、&lt;footer&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;nav&gt;等标签之中。另外，功能性区块（比如搜索栏）不适合放入&lt;main&gt;，除非当前页面就是搜索页面。&lt;article&gt;&lt;article&gt;标签表示页面里面一段完整的内容，即使页面的其他部分不存在，也具有独立使用的意义，通常用来表示一篇文章或者一个论坛帖子。它可以有自己的标题（&lt;h1&gt;到&lt;h6&gt;）。&lt;article&gt;&lt;h2&gt;文章标题&lt;/h2&gt;&lt;p&gt;文章内容&lt;/p&gt;&lt;/article&gt;一个网页可以包含一个或多个&lt;article&gt;，比如包含多篇文章。&lt;aside&gt;&lt;aside&gt;标签用来放置与网页或文章主要内容间接相关的部分。网页级别的&lt;aside&gt;，可以用来放置侧边栏，但不一定就在页面的侧边；文章级别的&lt;aside&gt;，可以用来放置补充信息、评论或注释。下面是网页级别的&lt;aside&gt;的例子。&lt;body&gt;&lt;main&gt;主体内容&lt;/main&gt;&lt;aside&gt;侧边栏&lt;/aside&gt;&lt;/body&gt;下面是文章评注的例子。&lt;p&gt;第一段&lt;/p&gt;&lt;aside&gt;&lt;p&gt;本段是文章的重点。&lt;/p&gt;&lt;/aside&gt;&lt;section&gt;&lt;section&gt;标签表示一个含有主题的独立部分，通常用在文档里面表示一个章节，比如&lt;article&gt;可以包含多个&lt;section&gt;。&lt;section&gt;总是多个一起使用，一个页面不能只有一个&lt;section&gt;。&lt;article&gt;&lt;h1&gt;文章标题&lt;/h1&gt;&lt;section&gt;&lt;h2&gt;第一章&lt;/h2&gt;&lt;p&gt;...&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;h2&gt;第二章&lt;/h2&gt;&lt;p&gt;...&lt;/p&gt;&lt;/section&gt;&lt;/article&gt;上面代码中，&lt;article&gt;包含了两个&lt;section&gt;，代表两章。&lt;section&gt;很适合幻灯片展示的页面，每个&lt;section&gt;代表一个幻灯片。一般来说，&lt;section&gt;都应该有标题，即包含&lt;h1&gt;~&lt;h6&gt;标签。多个&lt;section&gt;可以放置在同一个&lt;article&gt;里面，一个&lt;section&gt;里面也可能包含多个&lt;article&gt;，这取决于&lt;section&gt;和&lt;article&gt;在当前页面的含义。&lt;nav&gt;&lt;nav&gt;标签用于放置页面或文档的导航信息。&lt;nav&gt;&lt;ol&gt;&lt;li&gt;&lt;ahref=&quot;item-a&quot;&gt;商品A&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;ahref=&quot;item-b&quot;&gt;商品B&lt;/a&gt;&lt;/li&gt;&lt;li&gt;商品C&lt;/li&gt;&lt;/ol&gt;&lt;/nav&gt;一般来说，&lt;nav&gt;往往放置在&lt;header&gt;里面，不适合放入&lt;footer&gt;。另外，一个页面可以有多个&lt;nav&gt;，比如一个用于站点导航，另一个用于文章导航。&lt;nav&gt;里面通常是列表，但也可以放置其他标签。&lt;h1&gt;~&lt;h6&gt;HTML提供了6个标签，用来表示文章的标题。按照标题的等级，一共分成六级。&lt;h1&gt;：一级标题&lt;h2&gt;：二级标题&lt;h3&gt;：三级标题&lt;h4&gt;：四级标题&lt;h5&gt;：五级标题&lt;h6&gt;：六级标题&lt;h1&gt;是最高级别的标题，&lt;h6&gt;是最低级别的标题。下一级标题都是上一级标题的子标题，比如，一个&lt;h1&gt;后面可以有多个&lt;h2&gt;，每个&lt;h2&gt;后面又可以有多个&lt;h3&gt;。&lt;body&gt;&lt;h1&gt;JavaScript语言介绍&lt;/h1&gt;&lt;h2&gt;概述&lt;/h2&gt;&lt;h2&gt;基本概念&lt;/h2&gt;&lt;h3&gt;网页&lt;/h3&gt;&lt;h3&gt;链接&lt;/h3&gt;&lt;h2&gt;主要用法&lt;/h2&gt;&lt;/body&gt;上面代码，通过章节标题，清晰地表明了文章的主体结构。具体的内容，就可以写在章节标题的下面。标题不应该越级，比如h1下面直接写h3。虽然这样不会报错，但会导致文章失去清晰的章节结构。默认情况下，浏览器会粗体显示标题。h1的字号比h2大，h2比h3大，以此类推。&lt;hgroup&gt;如果主标题包含多级标题（比如带有副标题），那么可以使用&lt;hgroup&gt;标签，将多级标题放在其中。&lt;hgroup&gt;&lt;h1&gt;Heading1&lt;/h1&gt;&lt;h2&gt;Subheading1&lt;/h2&gt;&lt;h2&gt;Subheading2&lt;/h2&gt;&lt;/hgroup&gt;注意，&lt;hgroup&gt;只能包含&lt;h1&gt;~&lt;h6&gt;，不能包含其他标签。","link":"https://18279493170.github.io/qlvkpWhdf/"},{"title":"html之字符编码","content":"HTML字符编码简介网页包含了大量的文字，浏览器必须知道这些文字的编码方法，才能把文字还原出来。一般情况下，服务器向浏览器发送HTML网页文件时，会通过HTTP头信息，声明网页的编码方式。Content-Type:text/html;charset=UTF-8上面代码中，HTTP头信息的Content-Type字段先声明，服务器发送的数据类型是text/html（即HTML网页），然后声明网页的文字编码是UTF-8。网页内部也会再用&lt;meta&gt;标签，再次声明网页的编码。&lt;metacharset=&quot;UTF-8&quot;&gt;字符的数字表示法网页可以使用不同语言的编码方式，但是最常用的编码是UTF-8。UTF-8编码是Unicode字符集的一种表达方式。这个字符集的设计目标是包含世界上的所有字符，目前已经收入了十多万个字符。每个字符有一个Unicode号码，称为码点（codepoint）。如果知道码点，就能查到这是什么字符。举例来说，英文字母a的码点是十进制的97（十六进制的61），汉字“中”的码点是十进制的20013（十六进制的4e2d）。由于下面的原因，不是每一个Unicode字符都能直接在HTML语言里面显示。（1）不是每个Unicode字符都可以打印出来，有些没有可打印形式，比如换行符的码点是十进制的10（十六进制的A），就没有对应的字面形式。（2）小于号（&lt;）和大于号（&gt;）用来定义HTML标签，其他需要用到这两个符号的场合，必须防止它们被解释成标签。（3）由于Unicode字符太多，无法找到一种输入法，可以直接输入所有这些字符。换言之，没有一种键盘，有办法输入所有符号。（4）网页不允许混合使用多种编码，如果使用UTF-8编码的同时，又想插入其他编码的字符，就会很困难。HTML为了解决上面这些问题，允许使用Unicode码点表示字符，浏览器会自动将码点转成对应的字符。字符的码点表示法是&amp;#N;（十进制，N代表码点）或者&amp;#xN;（十六进制，N代表码点），比如，字符a可以写成&amp;#97;（十进制）或者&amp;#x61;（十六进制），字符中可以写成&amp;#20013;（十进制）或者&amp;#x4e2d;（十六进制），浏览器会自动转换它们。&lt;p&gt;hello&lt;/p&gt;&lt;!--等同于--&gt;&lt;p&gt;&amp;#104;&amp;#101;&amp;#108;&amp;#108;&amp;#111;&lt;/p&gt;&lt;!--等同于--&gt;&lt;p&gt;&amp;#x68;&amp;#x65;&amp;#x6c;&amp;#x6c;&amp;#x6f;&lt;/p&gt;上面代码中，字符可以直接表示，也可以使用十进制码点或十六进制码点表示。注意，HTML标签本身不能使用码点表示，否则浏览器会认为这是所要显示的文本内容，而不是标签。比如，&lt;p&gt;一旦写成&lt;&amp;#112;&gt;或者&amp;#60;&amp;#112;&amp;#62;，浏览器就不再认为这是标签了，而会当作文本内容将其显示为&lt;p&gt;。字符的实体表示法数字表示法的不方便之处，在于必须知道每个字符的码点，很难记忆。为了能够快速输入，HTML为一些特殊字符，规定了容易记忆的名字，允许通过名字来表示它们，这称为实体表示法（entity）。实体的写法是&amp;name;，其中的name是字符的名字。下面是其中一些特殊字符，及其对应的实体。&lt;：&amp;lt;&gt;：&amp;gt;&quot;：&amp;quot;'：&amp;apos;&amp;：&amp;amp;©：&amp;copy;#：&amp;num;§：&amp;sect;¥：&amp;yen;$：&amp;dollar;£：&amp;pound;¢：&amp;cent;%：&amp;percnt;*：$ast;@：&amp;commat;^：&amp;Hat;±：&amp;plusmn;空格：&amp;nbsp;注意，上面最后一个特殊字符是空格，它也有对应的实体表示法。字符的数字表示法和实体表示法，都可以表示正常情况无法输入的字符，逃脱了浏览器的限制，所以英语里面称为“escape”，中文翻译为“字符的转义”。","link":"https://18279493170.github.io/7CEMXC6C_/"},{"title":"html之元素属性","content":"网页元素的属性简介网页元素的属性（attribute）可以定制元素的行为，不同的属性会导致元素有不同的行为。元素属性的写法是HTML标签内部的“键值对”。&lt;htmllang=&quot;en&quot;&gt;上面代码中，&lt;html&gt;标签内部的键值对lang=&quot;en&quot;，就称为html元素的属性。属性名为lang，属性值为en。属性名与标签名一样，不区分大小写，lang和LANG是同一个属性。属性名与属性值之间，通过等号=连接。属性值可以放在单引号或双引号之中，建议统一使用双引号。某些属性值可以不使用引号，但是建议不要这样写。有些属性是布尔属性，即属性值是一个布尔值，只有“打开”和“关闭”两种情况。这时属性值可以省略，只要添加了属性名，就表示打开该属性。&lt;inputtype=&quot;text&quot;required&gt;上面代码中，required就是&lt;input&gt;标签的布尔属性。如果加上这个属性，就表示打开，没有就是关闭。全局属性全局属性（globalattributes）是所有元素都可以使用的属性。也就是说，你可以把下面的属性，加在任意一个网页元素上面，不过有些属性对某些元素可能不产生意义。下面是一些常见的全局属性。idid属性是元素在网页内的唯一标识符。比如，网页可能包含多个&lt;p&gt;标签，id属性可以指定每个&lt;p&gt;标签的唯一标识符。&lt;pid=&quot;p1&quot;&gt;&lt;/p&gt;&lt;pid=&quot;p2&quot;&gt;&lt;/p&gt;&lt;pid=&quot;p3&quot;&gt;&lt;/p&gt;上面代码中，三个&lt;p&gt;标签具有不同的id属性，因此可以区分。id属性的值必须是全局唯一的，同一个页面不能有两个相同的id属性。另外，id属性的值不得包含空格。id属性的值还可以在最前面加上#，放到URL中作为锚点，定位到该元素在网页内部的位置。比如，用户访问网址https://foo.com/index.html#bar的时候，浏览器会自动将页面滚动到bar的位置，让用户第一眼就看到这部分内容。classclass属性用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的。&lt;pclass=&quot;para&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pclass=&quot;para&quot;&gt;&lt;/p&gt;上面代码中，第一个&lt;p&gt;和第三个&lt;p&gt;是一类，因为它们的class属性相同。元素可以同时具有多个class，它们之间使用空格分隔。&lt;pclass=&quot;p1p2p3&quot;&gt;&lt;/p&gt;上面的p元素同时具有p1、p2、p3三个class。titletitle属性用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将title属性值作为浮动提示，显示出来。&lt;divtitle=&quot;版权说明&quot;&gt;&lt;p&gt;本站内容使用创意共享许可证，可以自由使用。&lt;/p&gt;&lt;/div&gt;上面代码中，title属性解释了这一块内容的目的。鼠标悬停在上面时，浏览器会显示一个浮动提示。一旦鼠标移开，提示就会消失。tabindex网页通常使用鼠标操作，但是某些情况下，用户可能希望使用键盘，或者只有键盘可以用。因此，浏览器允许使用Tab键，遍历网页元素。也就是说，只要不停按下Tab键，网页的焦点就会从一个元素转移到另一个元素，选定焦点元素以后，就可以进行下一步操作，比如按下回车键访问某个链接，或者直接在某个输入框输入文字。这里就有一个问题，按下Tab键的时候，浏览器怎么知道跳到哪一个元素。HTML提供了tabindex属性，解决这个问题。它的名字的含义，就是Tab的顺序（index）。tabindex属性的值是一个整数，表示用户按下Tab键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。负整数：该元素可以获得焦点（比如使用JavaScript的focus()方法），但不参与Tab键对网页元素的遍历。这个值通常是-1。0：该元素参与Tab键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。正整数：网页元素按照从小到大的顺序（1、2、3、……），参与Tab键的遍历。如果多个元素的tabindex属性相同，则按照在网页源码里面出现的顺序遍历。&lt;ptabindex=&quot;0&quot;&gt;这段文字可以获得焦点。&lt;/p&gt;上面代码中，&lt;p&gt;标签的tabindex为0，意味着该元素可以获得焦点，并且也可以被Tab键遍历，顺序由其在源码里面的位置决定。一般来说，tabindex属性最好都设成0，按照自然顺序进行遍历，这样比较符合用户的预期，除非网页有特殊布局。如果网页所有元素都没有设置tabindex，那么只有那些默认可以遍历的元素（比如链接、输入框等）才能参与Tab键的遍历，顺序由其在源码的位置决定。因此实际上，只有那些无法获得焦点的元素（比如&lt;span&gt;、&lt;div&gt;）需要参与遍历，才有必要设置tabindex属性。accesskeyaccesskey属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。&lt;buttonaccesskey=&quot;s&quot;&gt;提交&lt;/button&gt;上面代码中，&lt;button&gt;的快捷键是s，按下快捷键，该元素就得到了焦点。accesskey属性的字符键，必须配合功能键，一起按下才会生效。也就是说，快捷键是“功能键+字符键”的组合。不同的浏览器与不同的操作系统，功能键都不一样。比如，Chrome浏览器在Windows系统和Linux系统的快捷键是Alt+字符键，在Mac系统的快捷键是Ctrl+Alt+字符键。注意，accesskey如果跟操作系统或浏览器级别的快捷键有冲突，这时不会生效。stylestyle属性用来指定当前元素的CSS样式。具体的设置，请看CSS教程。&lt;pstyle=&quot;color:red;&quot;&gt;hello&lt;/p&gt;上面代码指定文字颜色为红色。hiddenhidden是一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它。&lt;phidden&gt;本句不会显示在页面上。&lt;/p&gt;上面代码中，这个p元素不会出现在网页上。注意，CSS的可见性设置，高于hidden属性。如果CSS设为该元素可见，hidden属性将无效。lang，dirlang属性指定网页元素使用的语言。&lt;plang=&quot;en&quot;&gt;hello&lt;/p&gt;&lt;plang=&quot;zh&quot;&gt;你好&lt;/p&gt;上面代码中，第一个&lt;p&gt;的lang属性，表示使用英语，第二个&lt;p&gt;的lang属性，表示使用中文。lang属性的值，必须符合BCP47的标准。下面是一些常见的语言代码。zh：中文zh-Hans：简体中文zh-Hant：繁体中文en：英语en-US：美国英语en-GB：英国英语es：西班牙语fr：法语dir属性表示文字的阅读方向，有三个可能的值。ltr：从左到右阅读，比如英语。rtl：从右到左阅读，阿拉伯语、波斯语、希伯来语都属于这一类。auto：浏览器根据内容的解析结果，自行决定。contenteditableHTML网页的内容默认是用户不能编辑，contenteditable属性允许用户修改内容。它有两个可能的值。true或空字符串：内容可以编辑false：不可以编辑&lt;pcontenteditable=&quot;true&quot;&gt;鼠标点击，本句内容可修改。&lt;/p&gt;上面代码中，鼠标单击句子，就可以进入编辑状态，用户可以改变句子的内容。当然，除非提交到服务器，否则刷新页面还是显示原来的内容。该属性是枚举属性，不是布尔属性，规范的写法是最好带上属性值。spellcheck浏览器一般会自带拼写检查功能，编辑内容时，拼错的单词下面会显示红色的波浪线。spellcheck属性就表示，是否打开拼写检查。它有两个可能的值。true：打开拼写检查false：关闭拼写检查&lt;pcontenteditable=&quot;true&quot;spellcheck=&quot;true&quot;&gt;英语单词separate容易写错成seperate。&lt;/p&gt;上面代码中，seperate下面会有提示，表示拼错了。注意，由于该属性只在编辑时生效，所以这个例子必须加上contenteditable属性，表示本段内容可编辑。鼠标单击就可以进入编辑状态，这时才会看到拼写提示。不可编辑的状态下，拼写错误是不提示显示的。对于那些不可编辑的元素，该属性无效。这个属性看上去像布尔属性，但是其实是枚举属性，所以最好不要省略它的值。如果没有指定这个属性，浏览器将自行决定是否打开拼写检查。data-属性data-属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在data-属性。&lt;ahref=&quot;#&quot;class=&quot;tooltip&quot;data-tip=&quot;thisisthetip!&quot;&gt;链接&lt;/a&gt;上面代码中，data-tip用于放置链接的提示文字。由于data-属性只能通过CSS或JavaScript利用，所以这里不做详细介绍了。下面是CSS的例子。/*HTML代码如下&lt;divdata-role=&quot;mobile&quot;&gt;Mobileonlycontent&lt;/div&gt;*/div[data-role=&quot;mobile&quot;]{display:none;}/*HTML代码如下&lt;divclass=&quot;test&quot;data-content=&quot;Thisisthedivcontent&quot;&gt;test&lt;/div&gt;​*/.test{display:inline-block;}.test:after{content:attr(data-content);}事件处理属性除了上面这些属性，全局属性还包括事件处理属性（eventhandler），用来响应用户的动作。这些属性的值都是JavaScript代码，请参考JavaScript教程，这里只列出这些属性的名单。onabort,onautocomplete,onautocompleteerror,onblur,oncancel,oncanplay,oncanplaythrough,onchange,onclick,onclose,oncontextmenu,oncuechange,ondblclick,ondrag,ondragend,ondragenter,ondragexit,ondragleave,ondragover,ondragstart,ondrop,ondurationchange,onemptied,onended,onerror,onfocus,oninput,oninvalid,onkeydown,onkeypress,onkeyup,onload,onloadeddata,onloadedmetadata,onloadstart,onmousedown,onmouseenter,onmouseleave,onmousemove,onmouseout,onmouseover,onmouseup,onmousewheel,onpause,onplay,onplaying,onprogress,onratechange,onreset,onresize,onscroll,onseeked,onseeking,onselect,onshow,onsort,onstalled,onsubmit,onsuspend,ontimeupdate,ontoggle,onvolumechange,onwaiting","link":"https://18279493170.github.io/JrFvYLzDh/"},{"title":"html之简介","content":"HTML语言简介概述HTML是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载HTML代码，然后渲染出网页。HTML的全名是“超文本标记语言”（HyperTextMarkupLanguage），上个世纪90年代由欧洲核子研究中心的物理学家蒂姆·伯纳斯-李（TimBerners-Lee）发明。它的最大特点就是支持超链接，点击链接就可以跳转到其他网页，从而构成了整个互联网。1999年，HTML4.01版发布，成为广泛接受的HTML标准。2014年，HTML5发布，这是目前正在使用的版本。浏览器的网页开发，涉及三种技术：HTML、CSS和JavaScript。HTML语言定义网页的结构和内容，CSS样式表定义网页的样式，JavaScript语言定义网页与用户的互动行为。HTML语言是网页开发的基础，CSS和JavaScript都是基于HTML才能生效，即使没有这两者，HTML本身也能使用，可以完成基本的内容展示。本教程只介绍HTML语言。下面就是一个简单网页的HTML源码。&lt;!DOCTYPEhtml&gt;&lt;htmllang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;metacharset=&quot;utf-8&quot;&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;HelloWorld&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;上面这段代码，可以保存成文件hello.html。浏览器打开这个本地文件，就能看到文字“HelloWorld”。浏览器右键菜单的“查看源码”（Viewpagesource），可以展示当前网页的HTML源码。网页的基本概念标签网页的HTML代码由许许多多不同的标签（tag）构成。学习HTML语言，就是学习各种标签的用法。下面就是标签的一个例子。&lt;title&gt;网页标题&lt;/title&gt;上面代码中，&lt;title&gt;和&lt;/title&gt;就是一对标签。标签用来告诉浏览器，如何处理这段代码。标签的内容就是浏览器所要渲染的、展示在网页上的内容。标签放在一对尖括号里面（比如&lt;title&gt;），大多数标签都是成对出现的，分成开始标签和结束标签，结束标签在标签名之前加斜杠（比如&lt;/title&gt;）。但是，也有一些标签不是成对使用，而是只有开始标签，没有结束标签，比如上一节示例的&lt;meta&gt;标签。&lt;metacharset=&quot;utf-8&quot;&gt;上面代码中，&lt;meta&gt;标签就没有结束标签&lt;/meta&gt;。这种单独使用的标签，通常是因为标签本身就足够完成功能了，不需要标签之间的内容。实际应用中，它们主要用来提示浏览器，做一些特别处理。标签可以嵌套。&lt;div&gt;&lt;p&gt;helloworld&lt;/p&gt;&lt;/div&gt;上面代码中，&lt;div&gt;标签内部包含了一个&lt;p&gt;标签。嵌套时，必须保证正确的闭合顺序，不能跨层嵌套，否则会出现意想不到的渲染结果。&lt;div&gt;&lt;p&gt;helloworld&lt;/div&gt;&lt;/p&gt;上面代码就是错误的嵌套，闭合顺序不正确。HTML标签名是大小写不敏感，比如&lt;title&gt;和&lt;TITLE&gt;是同一个标签。不过，一般习惯都是使用小写。另外，HTML语言忽略缩进和换行。下面几种写法的渲染结果是一样的。&lt;title&gt;网页标题&lt;/title&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;title&gt;网页标题&lt;/title&gt;进一步说，整个网页的HTML代码完全可以写成一行，浏览器照样解析，结果完全一样。所以，正式发布网页之前，开发者有时会把源码压缩成一行，以减少传输的字节数。各种网页的样式效果，比如内容的缩进和换行，主要靠CSS来实现。元素浏览器渲染网页时，会把HTML源码解析成一个标签树，每个标签都是树的一个节点（node）。这种节点就称为网页元素（element）。所以，“标签”和“元素”基本上是同义词，只是使用的场合不一样：标签是从源码角度来看，元素是从编程角度来看，比如&lt;p&gt;标签对应网页的p元素。嵌套的标签就构成了网页元素的层级关系。&lt;div&gt;&lt;p&gt;helloworld&lt;/p&gt;&lt;/div&gt;上面代码中，div元素内部包含了一个p元素。上层元素又称为“父元素”，下层元素又称为“子元素”，即div是p的父元素，p是div的子元素。块级元素，行内元素所有元素可以分成两大类：块级元素（block）和行内元素（inline）。块级元素默认占据一个独立的区域，在网页上会自动另起一行，占据100%的宽度。&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;world&lt;/p&gt;上面代码中，p元素是块级元素，因此浏览器会将内容分成两行显示。行内元素默认与其他元素在同一行，不产生换行。比如，span就是行内元素，通常用来为某些文字指定特别的样式。&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;上面代码中，span元素是行内元素，因此浏览器会将两行内容放在一行显示。属性属性（attribute）是标签的额外信息，使用空格与标签名和其他属性分隔。&lt;imgsrc=&quot;demo.jpg&quot;width=&quot;500&quot;&gt;上面代码中，&lt;img&gt;标签有两个属性：src和width。属性可以用等号指定属性值，比如上例的demo.jpg就是src的属性值。属性值一般放在双引号里面，这不是必需的，但推荐总是使用双引号。注意，属性名是大小写不敏感的，onclick和onClick是同一个属性。HTML提供大量属性，用来定制标签的行为，详细介绍请看《元素的属性》一章。网页的基本标签符合HTML语法标准的网页，应该满足下面的基本结构。&lt;!DOCTYPEhtml&gt;&lt;htmllang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;metacharset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;不管多么复杂的网页，都是从上面这个基本结构衍生出来的。前面说过，HTML代码的缩进和换行，对于浏览器不产生作用。所以，上面的代码完全可以写成一行，渲染结果不变。上面这样分行写，只是为了提高可读性。下面就依次介绍，这个基本结构的主要标签。它们构成了网页的骨架。&lt;!doctype&gt;网页的第一个标签通常是&lt;!doctype&gt;，表示文档类型，告诉浏览器如何解析网页。一般来说，只要像下面这样，简单声明doctype为html即可。浏览器就会按照HTML5的规则处理网页。&lt;!doctypehtml&gt;有时，该标签采用完全大写的形式，以便区别于正常的HTML标签。因为&lt;!doctype&gt;本质上不是标签，更像一个处理指令。&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;html&gt;标签是网页的顶层容器，即标签树结构的顶层节点，也称为根元素（rootelement），其他元素都是它的子元素。一个网页只能有一个&lt;html&gt;标签。该标签的lang属性，表示网页内容默认的语言。&lt;htmllang=&quot;zh-CN&quot;&gt;上面代码表示，网页是中文内容。如果是英文内容，zh-CN要改成en。更详细的介绍，参见《元素的属性》一章。&lt;head&gt;&lt;head&gt;标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染提供额外信息。&lt;!doctypehtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;&lt;head&gt;是&lt;html&gt;的第一个子元素。如果网页不包含&lt;head&gt;，浏览器会自动创建一个。&lt;head&gt;的子元素一般有下面七个，后文会一一介绍。&lt;meta&gt;：设置网页的元数据。&lt;link&gt;：连接外部样式表。&lt;title&gt;：设置网页标题。&lt;style&gt;：放置内嵌的样式表。&lt;script&gt;：引入脚本。&lt;noscript&gt;：浏览器不支持脚本时，所要显示的内容。&lt;base&gt;：设置网页内部相对URL的计算基准。&lt;meta&gt;&lt;meta&gt;标签用于设置或说明网页的元数据，必须放在&lt;head&gt;里面。一个&lt;meta&gt;标签就是一项元数据，网页可以有多个&lt;meta&gt;。&lt;meta&gt;标签约定放在&lt;head&gt;内容的最前面。不管什么样的网页，一般都可以放置以下两个&lt;meta&gt;标签。&lt;head&gt;&lt;metacharset=&quot;utf-8&quot;&gt;&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;title&gt;PageTitle&lt;/title&gt;&lt;/head&gt;上面例子中，第一个&lt;meta&gt;标签表示网页采用UTF-8格式编码，第二个&lt;meta&gt;标签表示网页在手机端可以自动缩放。&lt;meta&gt;标签有五个属性，下面依次介绍。（1）charset属性&lt;meta&gt;标签的charset属性，用来指定网页的编码方式。该属性非常重要，如果设置得不正确，浏览器可能无法正确解码，就会显示乱码。&lt;metacharset=&quot;utf-8&quot;&gt;上面代码声明，网页为UTF-8编码。虽然开发者可以使用其他的编码方式，但正确的做法几乎总是应该采用UTF-8。注意，这里声明的编码方式，应该与网页实际的编码方式一致，即声明了utf-8，网页就应该使用UTF-8编码保存。如果这里声明了utf-8，实际却是使用另一种编码（比如GB2312），并不会导致浏览器的自动转码，网页可能会显示为乱码。（2）name属性，content属性&lt;meta&gt;标签的name属性表示元数据的名字，content属性表示元数据的值。它们合在一起使用，就可以为网页指定一项元数据。&lt;head&gt;&lt;metaname=&quot;description&quot;content=&quot;HTML语言入门&quot;&gt;&lt;metaname=&quot;keywords&quot;content=&quot;HTML,教程&quot;&gt;&lt;metaname=&quot;author&quot;content=&quot;张三&quot;&gt;&lt;/head&gt;上面代码包含了三个元数据：description是网页内容的描述，keywords是网页内容的关键字，author是网页作者。元数据有很多种，大部分涉及浏览器内部工作机制，或者特定的使用场景，这里就不一一介绍了。下面是一些例子。&lt;metaname=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1&quot;&gt;&lt;metaname=&quot;application-name&quot;content=&quot;ApplicationName&quot;&gt;&lt;metaname=&quot;generator&quot;content=&quot;program&quot;&gt;&lt;metaname=&quot;subject&quot;content=&quot;yourdocument'ssubject&quot;&gt;&lt;metaname=&quot;referrer&quot;content=&quot;no-referrer&quot;&gt;（3）http-equiv属性，content属性&lt;meta&gt;标签的http-equiv属性用来覆盖HTTP回应的头信息字段，content属性是对应的字段内容。这两个属性与HTTP协议相关，属于高级用法，这里就不详细介绍了。&lt;metahttp-equiv=&quot;Content-Security-Policy&quot;content=&quot;default-src'self'&quot;&gt;上面代码可以覆盖HTTP回应的Content-Security-Policy字段。下面是另一些例子。&lt;metahttp-equiv=&quot;Content-Type&quot;content=&quot;Type=text/html;charset=utf-8&quot;&gt;&lt;metahttp-equiv=&quot;refresh&quot;content=&quot;30&quot;&gt;&lt;metahttp-equiv=&quot;refresh&quot;content=&quot;30;URL='http://website.com'&quot;&gt;&lt;title&gt;&lt;title&gt;标签用于指定网页的标题，会显示在浏览器窗口的标题栏。&lt;head&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;搜索引擎根据这个标签，显示每个网页的标题。它对于网页在搜索引擎的排序，有很大的影响，应该精心安排，反映网页的主题。&lt;title&gt;标签的内部，不能再放置其他标签，只能放置无格式的纯文本。&lt;body&gt;&lt;body&gt;标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都放置在它的内部。它是&lt;html&gt;的第二个子元素，紧跟在&lt;head&gt;后面。&lt;html&gt;&lt;head&gt;&lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;helloworld&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;空格和换行HTML语言有自己的空格处理规则。标签内容的头部和尾部的空格，一律忽略不计。&lt;p&gt;helloworld&lt;/p&gt;上面代码中，hello前面的空格和world后面的空格，浏览器一律忽略不计。标签内容里面的多个连续空格（包含制表符\\t），会被浏览器合并成一个。&lt;p&gt;helloworld&lt;/p&gt;上面代码中，hello与world之间有多个连续空格，浏览器会将它们合并成一个。网页渲染的结果是，hello与world之间只有一个空格。浏览器还会将文本里面的换行符（\\n）和回车符（\\r），替换成空格。&lt;p&gt;helloworld&lt;/p&gt;上面代码中，hello与world之间有多个换行，浏览器会将它们替换成空格，然后再将多个空格合并成一个。网页渲染的结果是，hello与world之间有一个空格。这意味着，HTML源码里面的换行，不会产生换行效果。注释HTML代码可以包含注释，浏览器会自动忽略注释。注释以&lt;!--开头，以--&gt;结尾，下面就是一个注释的例子。&lt;!--这是一个注释--&gt;注释可以是多行的，并且内部的HTML都不再生效了。&lt;!--&lt;p&gt;helloworld&lt;/p&gt;--&gt;上面代码是一个注释的区块，内部的代码都是无效的，浏览器不会解析，更不会渲染它们。注释有助于理解代码的含义，复杂的代码块前面最好加上注释。","link":"https://18279493170.github.io/html-zhi-jian-jie/"},{"title":"css之宽高，文本格式与链接","content":"宽高CSS尺寸属性指的就是元素的宽度和高度属性，虽然说非常简单，但却是必须掌握的技能。CSS中提供了width、height、max-width、min-width、max-height和min-height等几个属性来设置元素的宽度和高度width通过width属性可以设置元素内容区的宽度auto默认值，浏览器自动计算元素的实际宽度length使用具体数值配合px、cm等单位来定义宽度%定义基于父元素宽度百分比的宽度inherit从父元素继承width属性的值提示：对于&lt;img&gt;标签来说，若仅指定width属性，那么它的height属性将根据原图片尺寸进行等比例缩放。一般情况下width属性需要与height属性配合使用来同时定义元素的宽度和高度，因为某些元素没有默认的宽度或高度（或者宽度与高度默认为0px），若不定义宽度或高度而且元素中又没有内容（子元素、文本等）时，这个元素的宽度或高度就会被设置为0px，从外表看起来就像被压缩成了一条线。heightheight属性用来定义元素内容区的高度auto默认值，浏览器自动计算元素的实际高度length使用具体数值配合px、cm等单位来定义高度%定义基于父元素高度百分比的高度inherit从父元素继承width属性的值提示：无论是width属性还是height属性，它们的值都不能设置为负数。默认情况下，浏览器会将某些元素的宽度设置为100%，例如、，而元素的高度则是根据元素中的内容来确定的，所以有些情况下您不必为元素设置固定的宽度或高度。max-width和max-heightmax-width和max-height属性分别用来设置元素内容区的最大宽度和最大高度。当定义了max-width和max-height属性时，不论width或height属性的实际值是多少，width和height属性的实际值都会小于等于max-width和max-height属性的值none默认值，表示对元素的最大宽度或高度没有限制length使用具体数值配合px、cm等单位来定义元素的最大宽度或高度%定义基于父元素宽度和高度百分比的最大宽度或高度inherit从父元素继承max-width或max-height属性的值当max-width属性的值小于width属性时，width属性的值会被重新定义为与max-width属性相同的值；当max-width属性的值大于width时，max-width属性将会被忽略；当max-width属性的值小于min-width时，max-width属性将会被忽略。min-width和min-heightmin-width和min-height属性用来设置元素内容区的最小宽度和最小高度，当定义了min-width和min-height属性时，不论width或height属性的实际值是多少，width和height属性的实际值都会大于等于min-width和min-height属性的值length使用具体数值配合px、cm等单位来定义元素的最小宽度或高度，默认值取决于浏览器%定义基于父元素宽度和高度百分比的最小宽度或高度inherit从父元素继承min-width和min-height属性的值当min-width属性的值小于width时，min-width属性将会被忽略；当min-width属性的值大于width时，min-width属性的值将被重新定义为与min-width属性相同的值；当min-width属性的值大于max-width时，max-width属性将会被忽略。文本格式text-align：设置文本的水平对齐方式；text-decoration：设置文本的装饰；text-transform：设置文本中英文的大小写转换方式；text-indent：设置文本的缩进方式；line-height：设置行高；letter-spacing：设置字符间距；word-spacing：设置单词与单词之间的间距（对中文无效）；text-shadow：设置文本阴影；vertical-align：设置文本的垂直对齐方式；white-space：设置文本中空白的处理方式；direction：设置文本方向。text-aligntext-align属性用来设置元素中文本的水平对齐方式left默认值，左对齐right右对齐center居中对齐justify两端对齐inherit从父元素继承text-align属性的值当text-align设置为justify时，将拉伸每一行文本（增加字符之间的间距），以使每行文本具有相同的宽度（最后一行除外），这种对齐方式通常用于出版物，例如杂志和报纸。需要特别注意的是，如果元素中的文本不足一行时，是无法实现两端对齐的（默认会以左对齐的效果显示）。只有当元素中的文本足够长，并且在元素中发生了自动换行时，才会将除最后一行以外的文本实现两端对齐。text-decorationtext-decoration属性用于设置或删除文本的装饰，最常用的做法就是使用text-decoration属性来删除&lt;a&gt;标签的默认下划线。当然了，使用text-decoration属性也可以在需要的地方为元素中的文本添加一些装饰，达到突出显示的效果。none默认值，标准文本，没有额外装饰，可以用来删除已有的文本装饰underline在文本下方添加一条下滑线overline在文本上方添加一条上滑线line-through在文本的中间定义一条横向贯穿文本的线（类似于删除线）blink定义闪烁的文本（目前主流浏览器不再支持）inherit从父元素继承text-decoration属性的值<!DOCTYPEhtml>.none{text-decoration:none;}.underline{text-decoration:underline;}.overline{text-decoration:overline;}.line-through{text-decoration:line-through;}无装饰文字带下划线文字带上划线文字带贯穿线文字text-transformtext-transform属性用来控制文本中英文字母的大小写，通过该属性您可以在不修改原文的基础上，将文本中的英文统一更改为小写字母、大写字母或者首字母大写的形式。none默认值，以原文显示，对文本中的英文不做更改capitalize将文本中的每个单词更改为以大写字母开头的形式uppercase将文本中的英文字母全部更改为大写lowercase将文本中的英文字母全部更改为小写inherit从父元素继承text-transform属性的值<!DOCTYPEhtml>.none{text-transform:none;}.uppercase{text-transform:uppercase;}.lowercase{text-transform:lowercase;}.capitalize{text-transform:capitalize;}none原文：text-transform&emsp;转换后：text-transformuppercase原文：text-transform&emsp;转换后：text-transformlowercase原文：TEXT-TRANSFROM&emsp;转换后：text-transformcapitalize原文：text-transform&emsp;转换后：text-transformtext-indenttext-indent属性用来为元素中的文本添加首行缩进的效果length以固定的值加单位的形式（例如2em）定义缩进距离，默认值为0%以基于父元素宽度的百分比来定义缩进距离inherit从父元素继承text-indent属性的值提示：不论是使用具体的值还是使用百分比的形式，都可以设置为负值，但这么做可能会造成文本内容溢出元素区域。注意：文本是从左侧还是从右侧缩进取决于direction属性定义的文本方向。line-heightline-height属性用来设置文本的行高normal默认值，使用默认的行高，不对行高进行额外设置number以具体的数字设置行高，这个数字会与当前的字体大小相乘，并将得到的值设置为行高length以数字加单位的形式设置固定的行高%以百分比的形式设置基于当前字体尺寸百分比的行高inherit从父元素继承line-height属性的值p.small{line-height:0.8;}p.big{line-height:200%;}letter-spacingletter-spacing属性用来设置字符之间的间距normal默认值，表示字符之间没有额外的间距length以数值加单位的形式设置字符之间的固定间距（允许使用负值）inherit从父元素继承letter-spacing属性的值p{letter-spacing:2px;}word-spacingword-spacing属性用来设置单词与单词之间的间距，但对中文无效normal默认值，表示单词与单词之间没有额外的间距length以数值加单位的形式设置单词与单词之间的固定间距（允许使用负值）inherit从父元素继承word-spacing属性的值<!DOCTYPEhtml>p{word-spacing:2em;}word-spacing属性用来设置单词与单词之间的间距，但对中文无效word-spacing属性用来设置单词与单词之间的间距，但对中文无效word-spacing属性用来设置单词与单词之间的间距，但对中文无效text-shadowtext-shadow属性用来为文本添加阴影及模糊效果text-shadow:h-shadowv-shadowblurcolor;h-shadow：必填值，设置阴影的水平位置，允许为负值；v-shadow：必填值，设置阴影的垂直位置，允许为负值；blur：可选值，设置模糊的距离；color：可选值，设置阴影的颜色。注意：text-shadow属性可以设置一个或多个阴影效果，只需要将每组的值使用逗号,分隔即可（类似于background属性的用法）。p{text-shadow:2px15pxred,0px-15px5pxblue;}vertical-alignvertical-align属性用来定义元素内文本的垂直对齐方式baseline默认值，将元素的基线与父元素的基线对齐sub下标对齐，将元素的基线相对于父元素的基线降低super上标对齐，将元素的基线相对于父元素的基线升高top顶部对齐，将元素行内框的顶端与行框的顶端对齐text-top文本顶部对齐，把元素的顶端与父元素字体的顶端对齐middle居中对齐，通常使用在图片上，将图片垂直方向的中线与文本的中线（文字元素行内框的中线）对齐bottom底部对齐，将元素行内框的顶端与行框的底端对齐text-bottom文本底部对齐，是将元素行内框的底端与行框的底线对齐length以数字加单位的形式设置元素基线距离父元素基线的距离（可以为负值）%使用&quot;line-height&quot;属性的百分比值来排列此元素，允许使用负值inherit从父元素继承vertical-align属性的值顶线：中文汉字的上边沿；中线：贯穿小写英文字母x中间的线；基线：小写英文字母x的下边沿；底线：中文汉字的下边沿；内容区：指底线与顶线包裹的区域；行高：包括内容区与以内容区为基础对称拓展的空白区域，我们称之为行高，也可以认为是相邻文本行基线间的距离；行距：指相邻文本行间上一个文本行底线和下一文本行顶线之间的距离；行内框：是一个浏览器渲染模型中的概念，无法显示出来，但是它又确实存在，它的高度与行高相同；行框：同行内框类似的概念，行框是指本行的一个虚拟的矩形框，也是浏览器渲染模式中的一个概念。行框高度等于本行内所有元素中行内框最大的值（以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度）。vertical-align:super;white-spacewhite-space属性用来设置如何处理元素内的空白normal默认值，忽略文本中的空白pre保留文本中的空白，类似于`&lt;pre&gt;`标签的效果nowrap文本会在一行中显示，不会自动换行，直到遇到`&lt;br&gt;`标签为止pre-wrap保留文本中的空白，但是正常地进行换行pre-line合并文本中的空白，但是保留换行符inherit从父元素继承white-space属性的值white-space:nowrap;directiondirection属性用来设置文本的方向ltr默认值，文本按从左到右的方向输出rtl文本按从右到左的方向输出inherit从父元素继承direction属性的值direction:ltr;链接样式链接是网站的重要组成部分，几乎在每个网页上都能看到不少的链接，合理的设计链接的样式能够给网页的颜值加分。链接有四种不同的状态，分别是link、visited、active和hover，可以通过以下伪类选择器来为链接的四种状态设置不同的样式：:link：定义普通或未访问链接的样式；:visited：定义已经访问过链接的样式；:hover：定义当鼠标经过或悬停在链接上时的样式；:active：定义点击链接时的样式。注意：在定义四个伪类选择器时需要按照一定的顺序，一般情况下:hover必须位于:link和:visited之后，:active必须位于:hover之后。在Chrome、Firefox、Safari等主流的Web浏览器中，都为链接定义了一套默认的样式，如果不专门为链接设置样式，浏览器则会使用默认的链接样式。普通链接：带有下划线的蓝色文本；已访问的链接：带有下划线的紫色文本；点击链接时：带有下划线的红色文本；经过或悬停在链接上时：链接的外观并没有变化，它将保持先前状态的颜色。:link通过:link伪类选择器可以为普通或未访问的链接设置样式a{text-decoration:none;}a:link{font-size:18px;border:1pxsolidblack;padding:5px;margin-left:10px;background:#ccc;color:black;}:visited通过:visited伪类选择器可以为已经访问过的链接设置样式a:visited{background:#FFFF99;border:1pxsoildred;color:red;}:hover通过:hover伪类选择器可以定义当鼠标经过或悬停在链接上时的样式a:hover{background:#9c6ae1;border:1pxsolidblack;color:black;}:active通过:active伪类选择器可以定义点击链接时的样式a:active{background:#000;border:1pxsolidblack;color:white;}","link":"https://18279493170.github.io/MBSiSe-eX/"},{"title":"html之URL","content":"URL简介概述URL是“统一资源定位符”（UniformResourceLocator）的首字母缩写，中文译为“网址”，表示各种资源的互联网地址。下面就是一个典型的URL。https://www.example.com/path/index.html所谓资源，可以简单理解成各种可以通过互联网访问的文件，比如网页、图像、音频、视频、JavaScript脚本等等。只有知道了它们的URL，才能在互联网上获取它们。只要资源可以通过互联网访问，它就必然有对应的URL。一个URL对应一个资源，但是同一个资源可能对应多个URL。URL是互联网的基础。互联网之所以“互联”，就是因为网页可以通过“链接”（link），包含其他URL。用户只要点击，就可以从一个URL跳转到另一个URL，前往不同的网站。网址的组成部分URL由多个部分组成。下面是一个比较复杂的URL，实际的URL通常不会有这么多部分。https://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#anchor我们看看，这个URL的各个部分。协议协议（scheme）是浏览器请求服务器资源的方法，上例是https://的部分，表示使用HTTPS协议。互联网支持多种协议，必须指明网址使用哪一种协议，默认是HTTP协议。也就是说，如果省略协议，直接在浏览器地址栏输入www.example.com，那么浏览器默认会访问http://www.example.com。HTTPS是HTTP的加密版本，出于安全考虑，越来越多的网站使用这个协议。HTTP和HTTPS的协议名称后面，紧跟着一个冒号和两个斜杠（://）。其他协议不一定如此，邮件地址协议mailto:的协议名后面只有一个冒号，比如mailto:foo@example.com。主机主机（host）是资源所在的网站名或服务器的名字，又称为域名。上例的主机是www.example.com。有些主机没有域名，只有IP地址，比如192.168.2.15。这种情况常常出现在局域网。端口同一个域名下面可能同时包含多个网站，它们之间通过端口（port）区分。“端口”就是一个整数，可以简单理解成，访问者告诉服务器，想要访问哪一个网站。HTTP协议的默认端口是80，如果省略了这个参数，服务器就会返回80端口的网站。端口紧跟在域名后面，两者之间使用冒号分隔，比如www.example.com:80。路径路径（path）是资源在网站的位置。比如，/path/index.html这个路径，指向网站的/path子目录下面的网页文件index.html。互联网的早期，路径是真实存在的物理位置。现在由于服务器可以模拟这些位置，所以路径只是虚拟位置。路径可能只包含目录，不包含文件名，比如/foo/，甚至结尾的斜杠都可以省略。这时，服务器通常会默认跳转到该目录里面的index.html文件（即等同于请求/foo/index.html），但也可能有其他的处理（比如列出目录里面的所有文件），这取决于服务器的设置。一般来说，访问www.example.com这个网址，很可能返回的是网页文件www.example.com/index.html。查询参数查询参数（parameter）是提供给服务器的额外信息。参数的位置是在路径后面，两者之间使用?分隔，上例是?key1=value1&amp;key2=value2。查询参数可以有一组或多组。每组参数都是键值对（key-valuepair）的形式，同时具有键名(key)和键值(value)，它们之间使用等号（=）连接。比如，key1=value就是一个键值对，key1是键名，value1是键值。多组参数之间使用&amp;连接，比如key1=value1&amp;key2=value2。锚点锚点（anchor）是网页内部的定位点，使用#加上锚点名称，放在网址的最后，比如#anchor。浏览器加载页面以后，会自动滚动到锚点所在的位置。锚点名称通过网页元素的id属性命名，详见《元素的属性》一章。URL字符URL的各个组成部分，只能使用以下这些字符。26个英语字母（包括大写和小写）10个阿拉伯数字连词号（-）句点（.）下划线（_）此外，还有18个字符属于URL的保留字符，只能在给定的位置出现。比如，查询参数的开头是问号（?），也就是说，问号只能出现查询参数的开头，出现在其他位置就是非法的，会导致网址解析错误。网址的其他部分如果要使用这些保留字符，必须使用它们的转义形式。URL字符转义的方法是，在这些字符的十六进制ASCII码前面加上百分号（%）。下面是这18个字符及其转义形式。!：%21#：%23$：%24&amp;：%26'：%27(：%28)：%29*：%2A+：%2B,：%2C/：%2F:：%3A;：%3B=：%3D?：%3F@：%40[：%5B]：%5D举例来说，有一个网页的URL是foo?bar.html，即文件里面包含一个问号，那么需要写成foo%3Fbar.html。URL的合法字符，其实也可以采用这种转义方法，但是不建议使用。比如，字母a的十六进制ASCII码是61，转义形式后就是%61。因此，www.apple.com又可以写成www.%61pple.com，浏览器一样识别。值得注意的是，空格的转义形式是%20。对于那些包含空格的文件名，这个转义是必须的。既不属于合法字符、也不属于保留字符的其他字符（比如汉字），理论上不需要手动转义，可以直接写在URL里面，比如www.example.com/中国.html，浏览器会自动将它们转义，发给服务器。转义方法是使用这些字符的十六进制UTF-8编码，每两位算作一组，然后每组头部添加百分号（%）。举例来说，汉字中的UTF-8十六进制编码是e4b8ad，每两个字符一组，URL转义后就为%e4%b8%ad。也就是说，URL里面凡是有汉字中的地方，都要写成%e4%b8%ad。因此，访问www.example.com/中国.html这个网址，需要写成下面的样子。www.example.com/%e4%b8%ad%e5%9b%bd.html上面代码中，中的转义形式是%e4%b8%ad，国是%e5%9b%bd。绝对URL和相对URLURL分成两种：绝对URL和相对URL。绝对URL指的是，只靠URL本身就能确定资源的位置。这意味着，URL必须带有资源的完整信息，包含协议、主机、路径等部分。前面的例子都是绝对URL。相对URL指的是，URL不包含资源位置的全部信息，必须结合当前网页的位置，才能定位资源。比如，当前网页的URL是https://www.example.com/path/index.html，该网页上面有一个资源，URL指向a.html，这个就是相对URL。因为只知道a.html，并不能定位资源。浏览器假定，a.html与当前网址在同一个子目录下面，从而得到绝对URLhttps://www.example.com/path/a.html。相对URL如果以斜杠（/）开头，就表示网站的根目录。否则，必须以当前目录为起点，推算资源的位置。比如，相对URL/foo/bar.html表示网站根目录的子目录foo，foo/bar.html表示在当前目录的foo子目录。URL还可以使用两个特殊简写，表示特定位置。.：表示当前目录，比如./a.html（当前目录下的a.html文件）..：表示上级目录，比如../a.html（上级目录下的a.html文件）这两种简写可以多个连用，比如../../表示上两级目录。绝对URL也可以使用这两个简写，比如www.example.com/./index.html等同于www.example.com/index.html，这时.相当于根目录的当前目录，即根目录本身。&lt;base&gt;&lt;base&gt;标签指定网页内部的所有相对URL的计算基准。整张网页只能有一个&lt;base&gt;标签，而且只能放在&lt;head&gt;里面。它是单独使用的标签，没有闭合标签，下面是一个例子。&lt;head&gt;&lt;basehref=&quot;https://www.example.com/files/&quot;target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;base&gt;标签的href属性给出计算的基准网址，target属性给出如何打开链接的说明（参见《链接》一章）。已知计算基准是https://www.example.com/files/，那么相对URLfoo.html，就可以转成绝对URLhttps://www.example.com/files/foo.html。注意，&lt;base&gt;标签必须至少具有href属性或target属性之一。&lt;basehref=&quot;http://foo.com/app/&quot;&gt;&lt;basetarget=&quot;_blank&quot;&gt;一旦设置了&lt;base&gt;，就对整个网页都有效。如果要改变某个链接的行为，只能用绝对链接替代相对链接。尤其需要注意锚点，这时锚点也是针对&lt;base&gt;计算的，而不是针对当前网页的URL。","link":"https://18279493170.github.io/y5JGEyR8T/"},{"title":"css之字体，颜色与背景","content":"字体样式font-family：设置字体；font-style：设置字体的风格，例如倾斜、斜体等；font-weight：设置字体粗细；font-size：设置字体尺寸；font-variant：将小写字母转换为小型大写字母；font-stretch：对字体进行伸缩变形（使用较少，并且主流浏览器都不支持）；font：字体属性的缩写，可以在一个声明中设置多个字体属性。font-familyfont-family属性用来设置元素内文本的字体。由于字体的种类成千上万，而且有些还不是免费的，因此我们的电脑上几乎不可能拥有所有的字体。为了最大程度的保证我们设置的字体能够正常显示，可以通过font-family属性定义一个由若干字体名称组成的列表，字体名称之间使用逗号,分隔，浏览器会首先尝试列表中的第一个字体，如果不支持则尝试下一个，以此类推。font-family属性值描述family-name、generic-familyfamily-name：字体名称，一个字体名称就代表一种字体，比如“微软雅黑”就是一种字体；generic-family：字体族，也就是某种类型的字体组合，一个字体族代表一种类型的字体，其中包含很多相似但又不同的字体，比如“sans-serif”就是一种无衬线字体，其中包含很多种相似的字体。字体的默认值取决于浏览器设置inherit从父元素继承字体的设置常用的字体族（generic-family）：字体族说明字体serif有衬线字体，即在文字笔画的结尾添加特殊的装饰线或衬线&quot;LucidaBright&quot;、&quot;LucidaFax&quot;、Palatino、&quot;PalatinoLinotype&quot;、Palladio、&quot;URWPalladio&quot;、serifsans-serif无衬线字体，即在文字笔画结尾处是平滑的&quot;OpenSans&quot;、&quot;FiraSans&quot;、&quot;LucidaSans&quot;、&quot;LucidaSansUnicode&quot;、&quot;TrebuchetMS&quot;、&quot;LiberationSans&quot;、&quot;NimbusSansL&quot;、sans-serifmonospace等宽字体，即每个文字的宽度都是相同的&quot;FiraMono&quot;、&quot;DejaVuSansMono&quot;、Menlo、Consolas、&quot;LiberationMono&quot;、Monaco、&quot;LucidaConsole&quot;、monospacecursive草书字体，该字体有连笔或者特殊的斜体效果，会给人一种手写的感觉&quot;BrushScriptMT&quot;、&quot;BrushScriptStd&quot;、&quot;LucidaCalligraphy&quot;、&quot;LucidaHandwriting&quot;、&quot;AppleChancery&quot;、cursivefantasy具有特殊艺术效果的字体Papyrus、Herculanum、&quot;PartyLET&quot;、&quot;CurlzMT&quot;、Harrington、fantasy示例:&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSS字体&lt;/title&gt;&lt;style&gt;body{font-family:&quot;LucidaCalligraphy&quot;,cursive,serif,sans-serif;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;font-family属性&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;注意：如果字体族或字体名称中包含空格或多个单词，则必须将它们使用引号包裹起来，例如&quot;TimesNewRoman&quot;、&quot;CourierNew&quot;、&quot;SegoeUI&quot;等，如果是在元素的style属性中使用则必须使用单引号。在网页设计中最常用的字体族是serif和sans-serif，因为它们适合阅读。在显示一些程序代码是通常使用等宽字体，这样可以使用程序代码看起来更加工整。font-stylefont-style属性用来设置字体的样式，例如斜体、倾斜等，该属性的可选值如下：normal默认值，文本以正常字体显示italic文本以斜体显示oblique文本倾斜显示inherit从父元素继承字体样式示例&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSS字体&lt;/title&gt;&lt;style&gt;body{font-style:oblique;}.normal{font-style:normal;}.italic{font-style:italic;}.oblique{font-style:oblique;}.inherit{font-style:inherit;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;pclass=&quot;normal&quot;&gt;normal：显示一个标准的字体&lt;/p&gt;&lt;pclass=&quot;italic&quot;&gt;italic：显示一个斜体的字体&lt;/p&gt;&lt;pclass=&quot;oblique&quot;&gt;oblique：显示一个倾斜的字体&lt;/p&gt;&lt;pclass=&quot;inherit&quot;&gt;inherit：从父元素继承字体样式&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;italic显示的字体的斜体版本，而oblique则只是一个倾斜的普通字体。font-weightfont-weight属性能够设置字体的粗细，可选值如下：normal默认值，标准字体bold粗体字体bolder更粗的字体lighter更细的字体100、200、300、400、500、600、700、800、900由细到粗的设置字体粗细，100为最细的字体，400等同于normal，700等同于boldinherit从父元素继承字体的粗细示例&lt;style&gt;p.weight-100{font-weight:100;}p.weight-200{font-weight:100;}p.normal{font-weight:normal;}p.bold{font-weight:bold;}p.bolder{font-weight:bolder;}&lt;/style&gt;font-sizefont-size属性用来设置字体的大小（字号），可选值如下：xx-small、x-small、small、medium、large、x-large、xx-large以关键字的形式把字体设置为不同的大小，从xx-small到xx-large依次变大，默认值为mediumsmaller为字体设置一个比父元素更小的尺寸larger为字体设置一个比父元素更大的尺寸length以数值加单位的形式把字体设置为一个固定尺寸，例如18px、2em%以百分比的形式为字体设置一个相对于父元素字体的大小inherit从父元素继承字体的尺寸示例:&lt;style&gt;.xx_small{font-size:xx-small;}.x_small{font-size:x-small;}.small{font-size:x-small;}.medium{font-size:x-small;}.large{font-size:large;}.x-large{font-size:x-large;}.xx-large{font-size:xx-large;}.smaller{font-size:smaller;}.larger{font-size:larger;}.font-20{font-size:20px;}&lt;/style&gt;font-variantfont-variant属性可以将文本中的小写英文字母转换为小型大写字母（转换后的大写字母与转换前小写字母的大小相仿，所以称之为小型大写字母）。font-variant属性的可选值如下：normal默认值，浏览器会显示一个标准的字体small-caps将文本中的小写英文字母转换为小型大写字母inherit从父元素继承font-variant属性的值示例:<!DOCTYPEhtml>CSS字体.normal{font-variant:normal}.small{font-variant:small-caps}ThisisaparagraphThisisaparagraphfontfont属性与前面价绍的background属性的功能类似，通过font属性可以同时设置多个字体属性，不同的是，使用font属性需要遵循以下顺序：font：[[font-style||font-variant||font-weight||font-stretch]?font-size[/line-height]?font-family]|caption|icon|menu|message-box|small-caption|status-bar注意：使用font属性时必须按照如上所示的顺序，并且font-size和font-family两个属性不可忽略；font属性中的每个参数仅允许设置一个值，除font-size和font-family属性外，被忽略的属性将被设置为各自的默认值；若要定义line-height属性，则需要使用斜线/将font-size和line-height属性分开。示例:&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSS字体&lt;/title&gt;&lt;style&gt;p.info{font:italicbold12px/30pxarial,sans-serif;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;使用font属性需要遵循以下顺序：&lt;/p&gt;&lt;pclass=&quot;info&quot;&gt;font：[[font-style||font-variant||font-weight||font-stretch]?font-size[/line-height]?font-family]|caption|icon|menu|message-box|small-caption|status-bar&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;颜色设置CSS中提供了一些属性（例如color、background）来设置HTML元素的颜色（例如元素的背景颜色或字体颜色），我们可以通过不同形式的值来指定颜色颜色名称使用颜色名称来设置具体的颜色，比如red、blue、brown、lightseagreen等，颜色名称不区分大小写color:red;十六进制码使用十六进制码以#RRGGBB或#RGB（比如#ff0000）的形式设置具体颜色，&quot;#&quot;后跟6位或3位十六进制字符（0-9,A-F）color:#f03;RGB通过rgb()函数对red、green、blue三原色的强度进行控制，从而实现不同的颜色color:rgb(255,0,51);RGBARGBA扩展了RGB，在RGB的基础上增加了alpha通道来设置颜色的透明度，需要使用rgba()函数实现color:rgba(255,0,0,0.1);HSL通过hsl()函数对颜色的色调、饱和度、亮度进行调节，从而实现不同的颜色color:hsl(120,100%,25%);HSLAHSLA扩展了HSL，在HSL的基础上增加了alpha通道来设置颜色的透明度，需要使用hsla()函数实现color:hsla(240,100%,50%,0.5);颜色名称使用颜色名称来设置颜色是最简单的方法。CSS中定义了一些表示颜色的关键字，如下表中所示，使用这些关键字可以轻松的为元素设置颜色。aqua天蓝black黑色blue蓝色fuchsia品红gray灰色green绿色lime浅绿maroon紫红色navy深蓝olive橄榄色orange橙色purple紫色red红色silver浅灰色teal蓝绿色white白色yellow黄色除了上表中介绍的17个颜色外，浏览器中还支持很多的颜色名称，但不同的浏览器之间对颜色的解析可能存在差异，为了安全起见，不建议您在CSS中使用颜色名称来指定颜色。十六进制码十六进制码是指通过一个以#开头的6位十六进制数（09，af）表示颜色的方式，这个六位数可以分为三组，每组两位，依次表示red、green、blue三种颜色的强度color:#00ff00;提示：在使用十六进制码表示颜色时，如果每组的两个十六进制数是相同的，例如#00ff00、#ffffff、#aabbcc，则可以将它们简写为#0f0、#fff、#abc。RGBRGB是red、green、blue的缩写，它是一种色彩模式，可以通过对red、green、blue三种颜色的控制来实现各式各样的颜色。CSS中要使用RGB模式来设置颜色需要借助rgb()函数，函数的语法格式如下：rgb(red,green,blue)其中red、green、blue分别表示三原色红、绿、蓝的强度，这三个参数的取值可以是0~255之间的整数，也可以是0%~100%之间百分比数值color:rgb(255,165,0);color:rgb(0%,100%,0%);RGBARGBA是RGB的扩展，在RGB的基础上又增加了对Alpha通道的控制，Alpha通道可以设置颜色的透明度。需要借助rgba()函数来使用RGBA模式，该函数需要接收四个参数，除了red、green、blue三种颜色的强度外，还需要一个0~1之间的小数来表示颜色的透明度，其中0表示完全透明，1表示完全不透明。rgba()函数的语法格式如下：rgba(red,green,blue,alpha);其中red、green、blue分别表示三原色红、绿、蓝的强度，alpha表示颜色的透明度color:rgba(255,0,0,0.5);color:rgba(0,255,0,1);HSLHSL是Hue（色调）、Saturation（饱和度）、Lightness（亮度）的缩写，它同样也是一种色彩模式，可以通过对色调、饱和度、亮度三个属性的调节来实现不同颜色的。CSS中使用HSL模式需要借助hsl()函数，函数的语法格式如下：hsl(hue,saturation,lightness)参数hue表示颜色在色盘上的度数（从0到360），0或360表示红色，120表示绿色，240表示蓝色参数saturation为一个百分比数值，表示色彩的饱和度，0%表示灰色，100%表示全彩。参数lightness同样为一个百分比数值，表示颜色的亮度，0%是黑色（没有亮度），50%为最合适的亮度（既不发黑也不过亮），100%是白色（曝光严重）。color:hsl(0,50%,50%);HSLAHSLA是HSL的扩展，在HSLA中增加了对颜色透明度的控制，其余与HSL相同。CSS中使用HSLA模式需要借助hsla()函数hsla(hue,saturation,lightness,alpha)参数alpha是一个0~1之间小数，用来表示颜色的透明度，0表示完全透明，而1表示完全不透明。color:hsla(0,50%,50%,0.5);background（背景）background-color：设置元素的背景颜色；background-image：设置元素的背景图像；background-repeat：控制背景图像是否重复；background-attachment：控制背景图像是否跟随窗口滚动；background-position：控制背景图像在元素中的位置；background-size：设置背景图像的尺寸；background-origin：设置background-position属性相对于什么位置来定位背景图像；background-clip：设置背景图像的显示区域；background：背景属性的缩写，可以在一个声明中设置所有的背景属性。background-color使用background-color属性为元素设置一个背景颜色，该属性支持以下几种属性值：color_name使用具体颜色名称为元素设置背景颜色（例如red）hex_number使用十六进制码为元素设置背景颜色（例如#ff0000）rgb_number使用rgb()函数为元素设置背景颜色（例如rgb(255,0,0)）transparent默认值，设置背景颜色为透明，大多数情况下我们并不会用到它。但如果您不希望某个元素拥有背景颜色，或者不希望用户对浏览器的设置（比如开启夜间模式、护眼模式）影响到您的设计，那么就可以使用transparent来将颜色设置为透明的inherit从父元素继承对背景颜色的设置示例#bg{color:white;background-color:blue;margin:20px;/*设置外边距为20px*/padding:20px;/*设置内边距为20px*/border:10pxdottedyellow;/*设置一个宽10px的黄色虚线边框*/}background-color属性能够为元素设置一种纯色的背景，这种颜色会填充元素的内容、内边距以及边框区域（也可以理解为边框及以内的所有区域），对于元素边框以外的区域（外边距）则没有影响。background-imagebackground-image用来为某个元素设置背景图像，默认情况下浏览器会从元素内容的左上角开始（若有内边距则从元素内边距区域的左上角开始），在水平和垂直方向上重复背景图像，以填充整个元素区域，您可以使用background-repeat属性来控制背景图像是否重复或如何重复。background-image属性:url('URL')指向图像的路径，可以将url()看作是一个函数，括号中的URL为图像的具体路径none默认值，不显示背景图像inherit从父元素继承背景图像的设置示例background-image:url('./bg-image.png');背景图像的覆盖区域与背景颜色相同，同样会填充元素的内容、内边距以及边框区域，对于元素边框以外的区域（外边距）则没有影响。background-repeat默认情况下背景图像会从元素内容的左上角开始（若有内边距则从元素内边距区域的左上角开始），在水平和垂直方向上重复背景图像以填充整个元素区域（不包括元素的外边距区域），您可以使用background-repeat属性用来设置背景图像是否重复或如何重复epeat默认值，背景图像将在垂直方向和水平方向上重复repeat-x背景图像仅在水平方向上重复repeat-y背景图像仅在垂直方向上重复no-repeat背景图像仅显示一次，不在任何方向上重复inherit从父元素继承background-repeat属性的设置background-image:url('./bg-image.png');background-repeat:repeat-x;background-positionbackground-position属性用来设置背景图像的起始位置lefttop（左上）、leftcenter（左中）、leftbottom（左下）、righttop（右上）、rightcenter（右中）、rightbottom（右下）、centertop（中上）、centercenter（居中）、centerbottom（中下）使用一些关键词表示背景图像的位置，如果您仅设置第一个关键词，那么第二个将默认为centerx%y%使用百分比表示背景图像距离元素左上角的距离，x%为水平方向，y%为垂直方向，左上角为0%0%，右下角是100%100%，如果您仅设置第一个值，那么另一个值将是50%，默认值为0%0%xposypos使用像素（px）或者其它CSS单位表示背景图像距离元素左上角的距离，xpos为水平方向，ypos为垂直方向，左上角为0px0px，右下角视元素的尺寸而定，百分比和单位的形式可以混用，如果您仅设置第一个值，那么另一个值将默认为50%background-image:url('./bg-image.png');background-repeat:no-repeat;background-position:0%50%;background-attachmentbackground-attachment属性用来设置背景图像是固定在某个位置还是跟随页面一起滚动scroll默认值，背景图像随着页面元素的滚动而移动fixed当页面的其余部分滚动时，背景图像固定不动inherit从父元素继承background-attachment属性的设置body{background-image:url('./bg-image.png');background-repeat:repeat-x;background-attachment:fixed;}background-sizebackground-size属性用来设置背景图像的尺寸xposypos使用像素（px）或其它CSS单位来设置背景图像的高度和宽度，xpos表示宽度，ypos表示高度，如果只设置第一个值，那么第二个值将被设置为默认值auto（自动）x%y%使用百分比表示背景图像相对于所在元素宽度与高度的百分比，x%表示宽度，y%表示高度，如果只设置第一个值，那么第二个值将被设置为默认值auto（自动）cover保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以完全覆盖元素所在的区域，这么做可能会导致背景图像的某些部分超出元素区域而无法显示contain保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以完整的显示在元素所在区域，背景图像可能无法完全覆盖整个元素区域【示例】使用background-size属性设置背景图像的尺寸，并将背景图像横向铺满整个元素区域：body{background-image:url('./bg-image.png');background-repeat:repeat-x;background-size:contain;}background-originbackground-origin是CSS3中新增的属性。在使用background-position属性来设置背景图像的位置时，默认是以元素左上角的位置来计算的。您还可以使用background-origin属性来设置background-position属性相对哪个位置来定位背景图像padding-box相对于元素的内边距区域来定位背景图像border-box相对于元素的边框区域来定位背景图像content-box相对于元素的内容区域来定位背景图像background-image:url('./bg-image.png');background-repeat:no-repeat;background-origin:border-box;background-position:5px5px;background-clipbackground-clip是CSS3中新增的属性，通过它可以设置背景图像的显示区域border-box默认值，在元素边框及以内的区域显示背景图像padding-box在元素内边距及以内的区域显示背景图像content-box在元素内容区域显示背景图像background-image:url('./bg-image.png');background-clip:content-box;backgroundbackground是背景属性的简写形式，通过它不仅可以为元素设置某个背景属性，还可以同时设置多个或者所有的背景属性。在设置多个背景属性时并没有固定的顺序，但推荐使用如下顺序进行设置：background-color||background-image||background-position[/background-size]?||background-repeat||background-attachment||background-origin||background-clip注意：每个属性之间使用空格进行分隔；如果同时设置background-position和background-size属性，这两个属性之间需要使用斜线/分隔，并且需要遵循background-position属性在前background-size属性在后的顺序；如果同时设置background-origin和background-clip属性，需要遵循background-origin属性在前background-clip属性在后的顺序。如果background-origin与background-clip属性的值相同，则可以只设置一个值。background:#cccurl('./bg-image.png')0px0px/containrepeat-xborder-box;background属性还支持设置多组属性值（比如上面示例中的#cccurl('./bg-image.png')0px0px/containrepeat-xborder-box就可以看作是一组属性），每组属性值之间使用逗号,分隔。但需要注意的是background-color属性不能设置多个，并且只能在最后一组属性值中设置。如果设置的多组属性中，背景图像之间存在重叠，那么前面设置的背景图像会覆盖在后面的背景图像之上background:url(&quot;./css.png&quot;)10px10px/60px60pxno-repeatpadding-box,url(&quot;./css.png&quot;)50px30px/120px120pxno-repeatcontent-box,url(&quot;./css.png&quot;)140px40px/200px100pxno-repeatcontent-box#58a;","link":"https://18279493170.github.io/vVlLKpZjB/"},{"title":"css之注释，引用与单位","content":"CSS注释在CSS中注释以/*开头（起始符），以*/结尾（结束符），/*与*/是成对出现的，所有在/*与*/之间的内容都会被看作注释的内容。CSS中的注释只有这一种写法，无论是在单行中使用还是跨越多行使用，只要保证注释的内容在/*与*/之间即可。例如：&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSS注释&lt;/title&gt;&lt;style&gt;1/*为所有h1标签设置CSS样式*/h1{color:blue;/*设置字体颜色为蓝色*/2/*text-align:center;*//*设置对齐方式为居中对齐*/}3/*为所有/*为所有p标签*/设置CSS样式*/p{color:red;/*设置字体颜色为红色*//*font-size:18px;*//*设置字体大小为18像素*/}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;CSS注释&lt;/h1&gt;&lt;p&gt;CSS注释单行注释与多行注释&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;浏览器会忽略注释中的内容，所以在开发或调试CSS代码时，如果您不希望某段CSS代码执行，也可以使用/**/将这段代码注释起来，这样浏览器就不会再执行这段CSS代码，如上2CSS中添加注释的数量没有限制，您可以在自己认为需要的地方添加注释。但需要注意的是，在CSS中注释不能嵌套使用，注释开始符/在遇到第一个注释结束符/后就会结束注释，之后出现的*/会被浏览器当作CSS样式，这么做的后果就是会导致后续的CSS样式无法正常解析。如上3html引用css方式行内式概念：​称为行内样式、行间样式、内联样式​是通过标签的style属性来设置元素的样式基本语法格式：&lt;标签名style=&quot;属性1:属性值1;属性2:属性值2;属性3:属性值3;&quot;&gt;内容&lt;/标签名&gt;实际上任何HTML标签都拥有style属性，可以设置行内样式比如：&lt;divstyle=&quot;color:red;font-size:12px;&quot;&gt;行内式&lt;/div&gt;要点：style其实就是标签的属性样式属性和值中间是:多组属性值之间用;隔开缺点：没有实现样式与结构分离定义内联样式需要在每个HTML标签中定义style属性，很不方便；在内联样式中使用双引号或单引号时要特别小心，因为HTML标签的属性通常都会使用双引号来包裹属性的值，例如&lt;inputtype=&quot;text&quot;&gt;；在内联样式中定义的样式不能再其它任何地方重用；内联样式在后期维护时很不方便，因为一个网站通常有很多页面组成，当修改页面样式时需要对页面逐个修改；添加过多的内联样式会导致HTML文档的体积增大。内嵌式概念：​称为内部样式、内嵌样式​是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义基本语法格式：&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;内嵌式&lt;/title&gt;&lt;style&gt;body{background-color:linen;}h1{color:maroon;margin-left:40px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;内嵌式&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;要点：style标签一般位于head标签中type=“text/css”在HTML5中可以省略只能控制当前的页面缺点：没有彻底分离,会导致文档的体积变大会导致代码冗余，不利于后期维护外部样式表（外链式）概念：​称为链入式外部样式表是最常见也是最推荐的引用CSS的方式，您只需要将CSS样式定义在一个.css格式的文件中，然后使用HTML的标签将这个.css格式的样式文件应用到HTML文档中。基本语法格式：&lt;head&gt;&lt;linkrel=&quot;stylesheet&quot;type=&quot;text/css&quot;href=&quot;css文件路径&quot;/&gt;&lt;/head&gt;要点：link是个单标签link标签需要放在head头部标签中，并且指定link标签的三个属性CSS样式定义在单独的.css格式的文件中，所以可以在多个页面之间引用，若要修改网页的样式，只需要修改这个CSS样式文件即可，很方便。rel定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件type定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表href定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。导入样式表使用@import来引用外部样式表，这一点与使用标签比较相似。格式：&lt;style&gt;@importurl(&quot;./style.css&quot;);/*@import&quot;./style.css&quot;;*/&lt;/style&gt;注意：在HTML文档中使用@import时，@import需要定义在&lt;style&gt;标签中。如果&lt;style&gt;标签中还有其它的CSS样式，那么@import就必须定义在所有样式的最前面；@import同样可以在.css格式的文件中使用，但同样需要定义在所有样式的前面；@import是在CSS2.1中新增的功能，所以一些低版本的浏览器可能会不支持；在页面加载时，使用标签引用的样式文件会随页面同时加载，而使用@import引用的样式文件会等待页面加载完成后再加载。如果@import引用的样式文件过大、加载时间过长的话，在页面加载完成后就会出现没有样式的情况，影响用户体验。CSS长度单位相对长度单位相对长度单位指的是这个单位没有一个固定的值，它的值受到其它元素属性（例如浏览器窗口的大小、父级元素的大小）的影响，在响应式布局方面相对长度单位非常适用。下表中列举了CSS中支持的相对长度单位：单位描述示例em相对于自身font-size（字体大小）属性的值，如果自身没有设置，则继承父元素font-size属性的值，1em等同于font-size属性值，例如font-size的值为16px，那么1em就等于16px，2em就等于32pxfont-size的值为16px，那么1em就等于16px，2em就等于32pxp{line-height:2em;}rem相对于根元素的font-size属性的大小，比如根元素的font-size是100px，那么1.2rem就相当于120pxp{font-size:1.2rem;}ex相对于所用字体中小写英文字母x的高度，若无法确定x的高度则使用0.5em计算p{font-size:1ex;}ch相对于所用字体中数字0的高度，若无法确定0的高度则使用0.5em计算p{line-height:3ch}vw相对于浏览器窗口的宽度，1vw=窗口宽度的1%p{font-size:5vw;}vh相对于浏览器窗口的高度，1vh=窗口高度的1%p{font-size:5vh;}vminvw与vh中较小的值p{font-size:5vmin;}vmaxvw与vh中较大的值p{font-size:5vmax;}%相对于父元素宽度或字体大小的百分比div{width:55%}示例：&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSS中的单位&lt;/title&gt;&lt;style&gt;.box{width:60vw;height:88vh;border:1exsolidblack;font-size:16px;}.info{font-size:2em;}.ex&gt;span{font-size:3ex;}.ch&gt;span{font-size:4ch;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;divclass=&quot;box&quot;&gt;这是16px的字体&lt;pclass=&quot;info&quot;&gt;这是2em的字体&lt;/p&gt;&lt;pclass=&quot;ex&quot;&gt;x：&lt;span&gt;这是3ex的字体&lt;/span&gt;&lt;/p&gt;&lt;pclass=&quot;ch&quot;&gt;0：&lt;span&gt;这是4ch的字体&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<!DOCTYPEhtml>CSS中的单位.box{width:60vw;height:88vh;border:1exsolidblack;font-size:16px;}.info{font-size:2em;}.ex>span{font-size:3ex;}.ch>span{font-size:4ch;}这是16px的字体这是2em的字体x：这是3ex的字体0：这是4ch的字体绝对长度单位绝对长度单位表示一个真实的物理尺寸，它的大小是固定的，不会因为其它元素尺寸的变化而变化。下表中列举了CSS中支持的绝对长度单位：单位描述示例cm厘米p{font-size:0.5cm;}mm毫米p{font-size:5mm;}in英寸（1in=96px=2.54cm）p{font-size:1in;}px像素（1px=1/96in）p{font-size:16px;}ptpoint，是一种专用的印刷单位“磅”，也可以称为“点”（1pt=1/72in）p{font-size:16pt;}pcpica，中文可称为“派卡”，印刷行业用于描述字体大小的单位，相当于我国新四号铅字的尺寸（1pc=12pt）p{font-size:5pc;}示例:&lt;!DOCTYPEhtml&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSS中的单位&lt;/title&gt;&lt;style&gt;.box{width:4in;height:4.5cm;border:2mmsolidblack;font-size:16px;}.pt{font-size:2pt;}.pc{font-size:3pc;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;divclass=&quot;box&quot;&gt;这是16px的字体&lt;pclass=&quot;pt&quot;&gt;这是2pt的字体&lt;/p&gt;&lt;pclass=&quot;pc&quot;&gt;这是3pc的字体&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;<!DOCTYPEhtml>CSS中的单位.box{width:4in;height:4.5cm;border:2mmsolidblack;font-size:16px;}.pt{font-size:2pt;}.pc{font-size:3pc;}这是16px的字体这是2pt的字体这是3pc的字体","link":"https://18279493170.github.io/ciLaEKxY9/"},{"title":"css之选择器","content":"定义选择器由HTML元素的id、class属性或元素名本身以及一些特殊符号构成，用来指定要为哪个HTML元素定义样式。选择器是CSS样式规则中重要的组成部分，我们可以将选择器看作是CSS样式与HTML元素之间的匹配模式，与选择器关联的样式规则会应用于选择器所指定的HTML元素上。CSS中提供了多种不同类型的选择器，您可以根据自己的喜好来选择使用。通用选择器通用选择器用星号*表示，它不匹配某个特定的HTML元素，而是匹配HTML文档中的每个元素。在开发中，我们通常使用通用选择器来清除HTML元素中默认的内外边距，如下所示：*{margin:0auto;padding:0;}注意：虽然通用选择器内的样式规则能够应用于HTML文档中的每个元素，但并不建议在生产环境中过于频繁地使用通用选择器。正是因为通用选择器会匹配网页上每个元素的特点，频繁的使用会给浏览器带来太多不必要的压力。标签选择器一个完整的HTML文档由各式各样的标签组成，而标签选择器可以通过具体的标签名称来匹配文档内所有同名的标签，如下所示：p{color:blue;}p选择器能够匹配文档中所有的&lt;p&gt;标签。ID选择器ID选择器用来匹配HTML文档中具有指定ID属性的标签，ID选择器的定义需要用到井号#，后面紧跟ID属性的值，如下所示：#nav{color:red;}#nav选择器能够匹配文档中具有id=&quot;nav&quot;属性的标签。类选择器类选择器可以根据标签的class属性匹配具体的HTML标签，所有符合条件的标签都会根据选择器内的样式进行格式化。类选择器的定义需要用到一个英文的句号.，后面紧跟class属性的值，如下所示：.black{color:black;}.black选择器能够匹配文档中所有具有class=&quot;black&quot;属性的标签。(交集选择器)由于class属性不是唯一的，可以应用于不同的标签，因此您还可以在定义类选择器时指定具体的标签，如下所示：p.black{color:black;}p.black选择器仅会将其中的样式应用到所有具有class=&quot;black&quot;属性的&lt;p&gt;标签中，对于其它的具有class=&quot;black&quot;属性的标签则没有影响。另外，一个HTML标签中class属性可能不止一个，例如：&lt;pclass=&quot;infoselected&quot;&gt;&lt;/p&gt;&lt;pclass=&quot;info&quot;&gt;&lt;/p&gt;假如我们要为所有class属性包含info的元素设置粗体，为所有class属性包含selected的元素设置红色字体，为class属性中既包含info又包含selected的元素设置蓝色背景，则可以写成下面这样：.info{font-weight:bold;}.selected{color:red;}.info.selected{background:blue;}这种由多个class属性值所组成的类选择器我们可以称之为“多类选择器”，而前面介绍的由单个class属性值定义的类选择器可以称为“单类选择器”。注意：多类选择器中，多个class属性之间是紧挨着的（例如.info.selected），不需要使用空格分开。后代选择器当一个&lt;p&gt;标签嵌套在一个&lt;div&gt;标签内部的时候，就可以将这个&lt;p&gt;标签看作是&lt;div&gt;标签的后代。当我们需要选择一个标签的后代标签时，就可以使用后代选择器。后代选择器的定义方式就是将标签名、class属性或id属性等按照标签的嵌套关系由外到内的依次罗列，中间使用空格分开，如下所示：ullia{text-decoration:none;}ullia选择器仅会匹配无序列表&lt;ul&gt;标签的所有后代&lt;a&gt;标签。子选择器子选择器与后代选择器类似，不过子选择器只会匹配某个元素的直接后代（元素与其子元素之间只有一层嵌套关系），子选择器由两个或多个选择器组成，选择器之间用大于号&gt;分隔开，如下所示：p&gt;strong{color:red;}&lt;!--p&gt;strong选择器会将下面代码中第一个&lt;p&gt;标签的子标签&lt;strong&gt;内的文字设置为红色，但对第二个&lt;p&gt;标签中的&lt;strong&gt;标签则没有影响。--&gt;&lt;p&gt;欢迎访问&lt;strong&gt;徐某人&lt;/strong&gt;！&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;徐某人&lt;/strong&gt;&lt;/em&gt;徐某人个人博客&lt;/p&gt;相邻兄弟选择器相邻兄弟选择器用于匹配某个元素之后紧邻的另一个元素，这两个元素拥有同一个父级元素并且不存在嵌套关系。相邻兄弟选择器的定义需要用到加号+，加号两边为相邻的两个元素，选择器会匹配加号后面的元素，如下所示：h1+p{color:blue;font-size:18px;}ul.task+p{color:#f0f;text-indent:30px;}h1+p选择器会匹配同一父级元素下紧邻&lt;h1&gt;标签并在其后的&lt;p&gt;标签。ul.task+p选择器则会匹配同一父级元素下紧邻&lt;ul&gt;标签并在其后的&lt;p&gt;标签，但&lt;ul&gt;要具有class=&quot;task&quot;属性。通用兄弟选择器通用兄弟选择器与相邻兄弟选择器非常相似，但却没有那么严格。通用兄弟选择器同样会匹配同一父级元素下的兄弟元素，但兄弟元素之间无需紧邻。定义通用兄弟选择器需要用到波浪号~，波浪号两边为同一父级元素下的两个元素，选择器会匹配波浪号后面的元素，如下所示：h1∼p{color:blue;font-size:18px;}h1∼p选择器会匹配同一父级元素下&lt;h1&gt;标签之后的所用&lt;p&gt;标签。分组选择器(并集选择器)分组选择器可以将同样的样式规则应用到多个选择器中，每个选择器之间使用逗号,进行分隔，这么做可以避免定义重复的样式规则，最大程度地减少CSS样式表中的代码。例如，在CSS样式表中，不同的选择器中可能包含同样的样式规则，如下所示：h1{font-size:36px;font-weight:normal;}h2{font-size:28px;font-weight:normal;}h3{font-size:22px;font-weight:normal;}我们可以看到选择器h1、h2、h3中包含相同的样式font-weight:normal;，这时就可以先使用分组选择器为h1、h2、h3定义它们之间同样的样式规则，然后再分别定义它们之间不同的样式规则，如下所示：h1,h2,h3{font-weight:normal;}h1{font-size:36px;}h2{font-size:28px;}h3{font-size:22px;}任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分.class,p,span,#box{color:red;font-size:25px;}属性选择器属性选择器用来匹配具有特定属性的元素。属性选择器的定义方式与标签选择器相似，只不过需要在标签的后面使用方括号[]来指定标签具有的属性信息，如下所示：input[type=&quot;text&quot;]{color:blue;}input[type=&quot;text&quot;]选择器会匹配所有具有type=&quot;text&quot;属性的&lt;input&gt;标签。属性选择器中方括号[]内的属性信息还支持以下几种写法：[target]：选择所有带有target属性元素；[target=_blank]：选择所有具有target=&quot;_blank&quot;属性的元素；[title~=flower]：选择title属性包含单词“flower”的所有元素；[lang|=en]：选择lang属性正好是“en”或以“en”为开头的所有元素。链接伪类选择器伪类选择器：用冒号，比如:link{},用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，选择第1个，第n个元素等等伪类选择器很多，比如链接伪类，结构伪类等等a:link选中未访问的链接a:visited选中已访问的链接a:hover选中有鼠标停留的链接a:active选中点击的链接注意：a标签在浏览器中具有默认样式，所以实际运用时都需要给链接单独指定样式实际上，很少写全四个状态，使用多个状态时，它们的顺序尽量不要颠倒，按照上面列出的顺序来写，否则可能会引起错误a{font-weight:700;font-size:16px;color:gray;}a:hover{color:red;/*鼠标经过的时候，由原来的灰色变成红色*/}","link":"https://18279493170.github.io/pXlWeIOAz/"},{"title":"css之简介","content":"定义CSS是“CascadingStyleSheet”的缩写，中文意思为“层叠样式表”，它是一种标准的样式表语言，用于描述网页的表现形式（例如网页元素的位置、大小、颜色等）。CSS的主要作用是定义网页的样式（美化网页），对网页中元素的位置、字体、颜色、背景等属性进行精确控制。CSS不仅可以静态地修饰网页，还可以配合JavaScript动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持CSS。发展史20世纪90年代初HTML语言诞生，这时的HTML只包含很少的属性来控制网页的显示效果。伴随着HTML的成长，各式各样的样式语言也随之出现，不同的浏览器结合它们各自的样式语言来控制页面的显示效果。经过不断的发展，HTML中添加了越来越多的属性来满足页面设计者的需求，随着这些属性的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿，于是CSS便诞生了。1994年，哈坤·利提出了CSS的最初建议，并决定与正在设计Argo浏览器的伯特·波斯（BertBos）合作，共同开发CSS。1994年底，哈坤·利在芝加哥的一次会议上第一次正式提出了CSS的建议，之后又在1995年的WWW网络会议上再次提出了CSS，在会议上伯特·波斯展示了支持CSS的Argo浏览器，哈坤·利也展示了支持CSS的Arena浏览器。同年，W3C组织（WorldWideWebConsortium）成立，该组织对CSS的发展很感兴趣，为此还专门组织了一次讨论会。最终CSS的全部开发成员都加入了W3C组织，并负责CSS标准的制定，至此CSS的发展走上正轨。W3C，中文名为“万维网联盟”，也称为“W3C理事会”，由万维网的发明者蒂姆·伯纳斯·李于1994年10月在麻省理工学院计算机科学实验室成立，是Web技术领域最具权威和影响力的国际中立性技术标准机构。发展至今，CSS总共经历了4个版本的迭代：CSS1.01996年12月W3C发布了CSS的第一个版本——CSS1.0（https://www.w3.org/TR/CSS1/）。CSS2.01998年5月，CSS2.0版本正式发布（https://www.w3.org/TR/CSS2/）。CSS2.12004年2月，CSS2.1正式发布。该版本在CSS2.0的基础上略微做了改动，删除了许多不被浏览器支持的属性。CSS3早在2001年，W3C就着手开始准备开发CSS的第三个版本，到目前为止该版本还没有最终定稿。虽然完整的CSS3标准还没有最终发布，但各主流浏览器已经开始支持其中的绝大部分特性。特点CSS是Web领域的一个突破，它为HTML提供了一种描述元素样式的方式，使用CSS和HTML可以制作出外形优美的网页。总体来说CSS具有以下特点：丰富的样式定义CSS提供了丰富的外观属性，可以在网页中实现各式各样的效果，例如：为任何元素设置不同的边框，以及边框与元素之间的内外间距；改变文字的大小、颜色、字体，为文字添加修饰（例如下划线、删除线）；为网页设置背景颜色或者背景图片等等。易于使用和修改CSS的样式信息不仅可以定义在HTML元素的style属性中，也可以定义在HTML文档&lt;head&gt;标签内的&lt;style&gt;标签中，还可以定义在专门的.css格式的文件中，之后再将其引用到HTML文档。推荐使用最后一种定义方式（定义单独的.css格式文件），这样可以将CSS样式统一存放，方便后期维护。多页面应用前面说了可以将CSS样式单独存放在一个.css格式的文件中，这个文件不属于任何页面，我们可以在不同的页面引用这个.css格式的文件，这样就可以统一不同页面的风格。层叠层叠就是指可以对同一个HTML元素多次定义CSS样式，后面定义的样式会覆盖前面定义的样式。例如整个站点引用了同样的CSS样式文件，但想要调整其中某个页面的某些元素，这时就可以针对想要调整的元素单独定义一份样式文件并引用到页面中。这样后来单独定义的样式就会覆盖前面的样式，在浏览器同样只会看到最后设置的效果。页面压缩一个网页其中通常包含大量的HTML元素，为了实现某些效果我们往往还需要为这些元素定义样式文件，如果将它们放到一起就会使得我们的HTML文档过于臃肿。而将CSS样式定义在单独的样式文件中，把CSS样式与HTML文档分开的话就可以大大减小HTML文档的体积，这样浏览器加载HTML文档所用的时间也会减少。另外，CSS样式可以重复使用，不同的元素可以使用相同的CSS样式，这样可以避免定义重复的样式，CSS样式文件的体积也会相应的减小，从而进一步缩短页面加载的时间。语法CSS样式由一系列规则组成，这些规则由Web浏览器解析，然后应用于HTML文档相应的元素上。CSS样式规则由三个部分组成，分别是选择器、属性和值：选择器：由HTML元素的id、class属性或元素名本身以及一些特殊符号构成，用来指定要为哪个HTML元素定义样式，例如选择器p就表示为页面中的所有&lt;p&gt;标签定义样式；属性：您希望给HTML元素设置的样式名称，由一系列关键词组成，例如color（颜色）、border（边框）、font（字体）等，CSS中提供了众多属性，您可以通过W3C官网查看；值：由数值和单位或者关键字组成，用来控制某个属性的显示效果，例如color属性的值可以是red或#F1F1F1等。例如：h1{color:blue;text-align;center}选择器h1表示要为网页中所有的&lt;h1&gt;标签定义样式；属性color表示字体颜色，值blue则表示将字体设置为蓝色；属性text-align表示文本的对齐方式，值center则表示将文本的对齐方式设置为居中对齐。在CSS的语法规则中，属性和值之间需要使用冒号:进行分隔，每个属性和值的组合可以看作一个声明，每个声明的末尾都需要使用分号;作为结尾，属于同一选择器的声明需要使用花括号{}包裹起来。为了使CSS更具可读性，您可以在定义CSS时每一行代码上只放置一个声明，如下所示：h1{color:blue;text-align:center;}CSS中的属性和大部分值都是不区分大小写的，但CSS中的选择器通常区分大小写，例如类选择器.bianchengbang和.BianChengBang就表示两个不同的选择器。","link":"https://18279493170.github.io/r2NkbjM3z/"}]}